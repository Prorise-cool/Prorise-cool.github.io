<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><title>Python语法前篇（十五）：第十四章：深入解析并发编程 | 格物致知</title><meta name="keywords" content="Python-语法篇"><meta name="author" content="Prorise"><meta name="copyright" content="Prorise"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#cee8ff"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="Python语法前篇（十五）：第十四章：深入解析并发编程"><meta name="application-name" content="Python语法前篇（十五）：第十四章：深入解析并发编程"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#cee8ff"><meta property="og:type" content="article"><meta property="og:title" content="Python语法前篇（十五）：第十四章：深入解析并发编程"><meta property="og:url" content="https://prorise-cool.github.io/2025/07/01/python%E8%AF%AD%E6%B3%95%E5%89%8D%E7%AF%87%E5%8D%81%E4%BA%94%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/index.html"><meta property="og:site_name" content="格物致知"><meta property="og:description" content="第十四章：深入解析并发编程14. 并发编程基本概念并发编程是指程序设计中允许多个任务同时执行的编程模式，它的核心目标是 提升执行效率。通过并发编程，原本需要 20 分钟执行的代码可能只需要 1 分钟就能完成。 进程调度机制解析CPU 在执行程序时会涉及进程调度，主要有两种切换情况：  I&amp;#x2F;"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://bu.dusays.com/2025/06/17/685113b7c39b1.webp"><meta property="article:author" content="Prorise"><meta property="article:tag" content="全栈, Full Stack, 前端, 后端, Node.js, Vue, React, 数据库, Linux, Docker, 个人博客, 技术分享"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://bu.dusays.com/2025/06/17/685113b7c39b1.webp"><meta name="description" content="第十四章：深入解析并发编程14. 并发编程基本概念并发编程是指程序设计中允许多个任务同时执行的编程模式，它的核心目标是 提升执行效率。通过并发编程，原本需要 20 分钟执行的代码可能只需要 1 分钟就能完成。 进程调度机制解析CPU 在执行程序时会涉及进程调度，主要有两种切换情况：  I&amp;#x2F;"><link rel="shortcut icon" href="/img/icons/favicon.ico"><link rel="canonical" href="https://prorise-cool.github.io/2025/07/01/python%E8%AF%AD%E6%B3%95%E5%89%8D%E7%AF%87%E5%8D%81%E4%BA%94%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"><link rel="preconnect" href="//cdn.cbd.int"><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="google-site-verification" content="xxx"><meta name="baidu-site-verification" content="code-xxx"><meta name="msvalidate.01" content="xxx"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/6.0.0/css/all.min.css" media="print" onload="this.media=&quot;all&quot;"><link rel="stylesheet" href="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/node-snackbar/0.1.16/snackbar.min.css" media="print" onload="this.media=&quot;all&quot;"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media=&quot;all&quot;"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media=&quot;all&quot;"><script async="" src="https://www.googletagmanager.com/gtag/js?id=[object Object]"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","[object Object]")</script><script>const GLOBAL_CONFIG = {
  linkPageTop: {"enable":true,"title":"与数百名博主无限进步","addFriendPlaceholder":"昵称（请勿包含博客等字样）：\n网站地址（要求博客地址，请勿提交个人主页）：\n头像图片url（请提供尽可能清晰的图片，我会上传到我自己的图床）：\n描述：\n站点截图（可选）：\n"},
  peoplecanvas: undefined,
  postHeadAiDescription: {"enable":true,"gptName":"Prorise","mode":"tianli","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"S-DNA1JM95BX2F9L0N","Referer":"https://xx.xx/"},
  diytitle: undefined,
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: 'https://twikoo.prorise666.site/',
  commentBarrageConfig:{"enable":true,"maxBarrage":1,"barrageTime":4000,"accessToken":"b39753735ed0ed5ffeb771bc108e3158","mailMd5":"ec3291d59a8d7d3675df8a0537fcbc979f0fa611c8df55841fb7f4fd162bd07a"},
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: {"mode":"both","api":"https://img2color-go.vercel.app/api?img=","cover_change":true},
  authorStatus: {"skills":["🤣 全栈开发工程师","🙂 前端架构设计师","🙃 后端服务构建者","🤩 移动端应用开发","🤯 数据库设计专家","🥳 DevOps运维实践者","🤭 技术栈多面手","😎 性能优化达人"]},
  algolia: {"appId":"K8Y7M0RMXQ","apiKey":"11fa7380e2694483a44b143044e69e6e","indexName":"prorise_blog","hits":{"per_page":6},"languages":{"input_placeholder":"输入关键词后按下回车查找","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":3,"position":"top","messagePrev":"距离上次更新已经过了","messageNext":"天，文章内容可能已经过时。"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    simplehomepage: false,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: Prorise","link":"链接: ","source":"来源: 格物致知","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: true,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={configTitle:"格物致知",title:"Python语法前篇（十五）：第十四章：深入解析并发编程",postAI:"false",pageFillDescription:"第十四章：深入解析并发编程, 14. 并发编程基本概念, 进程调度机制解析, 进程的三大状态与生命周期, 14.1 同步与异步编程模型, 同步和异步, 阻塞和非阻塞, 14.2 多进程编程技术, 进程基础, 进程创建方法, 方法一：使用 Process 类创建进程, 方法二：继承 Process 类创建进程, 多进程常用方法表, 进程号与进程信息获取, 进程间通信示例, 复杂进程通信示例, 进程池详解, 进程池的主要方法, ProcessPoolExecutor 示例, 进程号与进程信息获取, 进程状态特殊情况, 僵尸进程, 孤儿进程, 14.3 多线程编程深入解析, 线程基础, 线程创建方法, 方法一：使用 Thread 类创建线程, 方法二：继承 Thread 类创建线程, 线程常用方法表, 线程使用实例, 基本线程示例, 守护线程示例, 线程池详解, ThreadPoolExecutor 主要方法, 完整示例, Event 事件同步机制, Event 主要方法, 定时器(Timer), 14.4 多进程 VS 多线程性能分析, 不同场景的最优选择, 计算密集型任务测试, IO 密集型任务测试, 14.5 协程技术详解, 协程基础概念, 协程效率对比, 串行执行, 使用 yield 实现协程切换, greenlet 模块（了解）, greenlet 核心方法与属性, gevent 模块（了解）, gevent 基础操作, gevent 常用 API 详解, 实际应用场景示例, greenlet 与 gevent 的区别与选择, asyncio 协程技术, asyncio 与原生协程, asyncio 常用 API, Task 对象, Future 对象, 异步上下文管理器, 14.6 GIL 锁与 Python 并发性能, GIL 的本质与工作原理, 并发与并行的区别, 线程安全与并发控制, 线程安全问题示例, 使用线程锁解决安全问题, Python 中的锁机制全面解析, Python 锁类型及其特性, 互斥锁(Lock), 可重入锁(RLock), 条件变量(Condition) - 根据条件控制锁, 信号量(Semaphore) - 控制并发数量, 有界信号量(BoundedSemaphore)详解, 事件对象(Event), 栅栏对象(Barrier), 线程安全队列(Queue), 死锁问题分析与解决, 死锁示例, 死锁解决方案, 原子操作与锁优化, threading.local 对象 - 线程本地存储, functools.lru_cache 带锁的缓存, 锁的高级应用模式, 读写锁模式, 使用 readerwriterlock 库实现读写锁, 锁排序（解决死锁）, 两阶段锁定, 超时重试模式, 多进程与多线程结合的混合模型, 细粒度锁与粗粒度锁, 14.7 消息队列与进程通信, 队列基础知识, 队列使用示例, 优先级队列示例第十四章深入解析并发编程并发编程基本概念并发编程是指程序设计中允许多个任务同时执行的编程模式它的核心目标是提升执行效率通过并发编程原本需要分钟执行的代码可能只需要分钟就能完成进程调度机制解析在执行程序时会涉及进程调度主要有两种切换情况操作触发切换当程序遇到操作时操作系统会剥夺该程序对的执行权限时间片用尽触发切换当一个程序长时间占用时操作系统也会剥夺程序对的执行权限所谓操作指的为阻断程序的操作类似于函数会将程序暂停运行达到某一个条件后才会接触阻塞状态时间片即分配给各个程序的时间每个线程被分配一个时间段称作它的时间片即该进程允许运行的时间使各个程序从表面上看是同时进行的如果在时间片结束时进程还在运行则将被剥夺并分配给另一个进程如果进程在时间片结束前阻塞或结束则当即进行切换而不会造成资源浪费在宏观上我们可以同时打开多个应用程序每个程序并行不悖同时运行但在微观上由于只有一个一次只能处理程序要求的一部分如何处理公平一种方法就是引入时间片每个程序轮流执行进程的三大状态与生命周期进程在其生命周期中会经历三种基本状态首先一个程序想要被运行当用户双击图标后此时程序就会从硬盘加载到内存所有的程序想要被执行就必须经历就绪态然后等待执行就绪态之后会进入进程调度然后运行运行时会出现以下几种情况时间片运行完毕程序也执行完毕释放资源后退出程序运行过程遇到操作读写发送网络请求它是不需要工作的只要运行遇到了操作系统就会把拿走执行其他的时间片程序就会进入阻塞态当请求完成后它就会结束阻塞态回到就绪态里排队同步与异步编程模型同步和异步同步任务提交之后原地等待任务的返回结果等待的过程中不做任何事情异步任务提交之后不再等待任务的返回结果而是去做一些其他的事情这两个概念主要描述任务的提交方式实际应用在开发中同步请求会阻塞页面渲染而异步请求则可以在后台处理数据不影响用户体验阻塞和非阻塞这两个概念主要描述进程的运行状态阻塞对应进程的阻塞态非阻塞对应进程的就绪态运行态结合同步异步和阻塞非阻塞可以形成四种组合同步阻塞同步非阻塞异步阻塞异步非阻塞利用率最高的一种模式在实际开发中异步非阻塞模式是高并发系统的首选模式因为它允许程序在等待操作时继续执行其他任务多进程编程技术进程基础进程是程序在计算机中的一次执行过程程序是静态的可执行文件占用磁盘空间进程是动态的执行过程占用计算机运行资源类比一个工厂有三个车间每个车间一个工人共人并行处理任务相当于一个程序创建三个进程每个进程一个线程共人并行处理任务进程创建方法功能创建进程对象参数绑定要执行的目标函数进程名默认是整数元组用于给函数位置传参字典给函数键值传参方法一使用类创建进程创建进程的标准方法子进程执行过程中触发的函数子进程父进程子进程正在执行参数模拟耗时操作子进程执行完毕密集型任务进程计算完成结果为父进程创建多个进程体现并行处理能力创建四个检测执行不同人物张三李四将进程添加到列表中启动进程等待所有进程结束所有进程执行完毕总耗时秒如果使用单进程顺序执行耗时会更长因为是两个任务在执行多进程可以充分利用多核并行处理任务重要提示在系统中必须在条件下创建进程这是因为使用方式创建进程会重新导入模块可能导致递归创建进程方法二继承类创建进程通过继承类创建进程继承类的自定义进程重写方法进程启动后会执行该方法子进程父进程子进程正在执行参数模拟耗时操作子进程执行完毕密集型任务进程重写方法执行密集型计算进程计算完成结果为父进程创建多个进程体现并行处理能力创建四个进程实例张三李四将进程添加到列表中启动进程等待所有进程结束所有进程执行完毕总耗时秒多进程常用方法表方法名说明实际应用场景创建进程对象指定新进程要执行的函数启动进程开始执行进程的任务等待进程结束协调多个进程的执行顺序检查进程是否存活监控进程状态强制终止进程中断异常或超时的进程创建进程安全的队列进程间数据传递添加元素到队列向队列中放入数据从队列获取元素从队列获取数据创建管道对象进程间双向通信进程号与进程信息获取在多进程编程中获取进程信息对于调试和管理至关重要的模块提供了方法来获取当前进程的信息打印当前进程的信息获取当前进程对象进程名称进程父进程进程授权键进程是否活跃自定义进程名进程间通信示例子进程执行的函数子进程函数想往父进程发送消息就往这个队列里放子进程启动向队列中添加数据我是一个队列数据模拟任务执行子进程结束父进程创建队列创建一个子进程对象启动子进程主进程从队列中获取数据主进程等待子进程数据阻塞等待数据主进程收到来自于子进程的消息等待子进程结束主进程结束复杂进程通信示例子进程执行的函数带有共享资源的工作函数队列锁值数组休眠时间获取进程进程开始执行使用锁来保证数据安全相当于和的组合安全的修改数组元素进程修改数组元素为向队列中添加数据这是一条来自于进程的信息休眠模拟工作进程执行完毕解释输出逻辑创建了个进程它们共享同一个数组初始值为每个进程获取锁后会将数组中的每个元素进行平方操作由于进程是按顺序启动的但执行顺序不确定所以第一个获得锁的进程将平方为第二个获得锁的进程将平方为第三个获得锁的进程将平方为第四个获得锁的进程将平方但由于整数溢出导致最后两个元素变成了和负数进程完成的顺序取决于参数所以最先完成的是第一个进程创建队列创建锁创建一个共享值表示类型创建一个共享数组创建多个子进程进程池详解进程池是一种管理多个进程的方式可以简化并行计算的编程的模块中的类和模块的类都提供了进程池功能进程池的主要方法方法描述使用场景创建进程池进程数默认为核数初始化进程池阻塞执行任务需要顺序执行且等待结果的场景非阻塞执行任务需要异步执行的场景并行执行映射任务对列表元素并行处理关闭进程池不再接受新任务完成任务提交后立即终止所有工作进程需要强制停止时等待所有工作进程退出在后使用示例进程池工作函数进程岁我的父进程是我结束进程了方法提交任务到进程池返回一个对象参数这里的作为函数的第二个参数传入小明等待对象返回结果对象示例工作进程函数进程岁我的父进程是我结束进程了准备参数列表张三号方法将函数应用于参数列表并返回结果列表的工作原理它接收两个参数要执行的函数和可迭代的参数列表它会自动将参数列表中的每个元素分配给不同的进程来执行每个进程会调用并传入中的一个元素作为参数所有进程执行完毕后会收集所有进程的返回值并按原始参数的顺序返回结果列表这样实现了并行处理提高了计算效率打印每个进程的返回结果进程号与进程信息获取在多进程编程中获取进程信息对于调试和管理至关重要的模块提供了方法来获取当前进程的信息打印当前进程的信息获取当前进程对象进程名称进程父进程进程授权键授权键用于在进程间通信时进行身份验证进程是否活跃自定义进程名进程状态特殊情况僵尸进程子进程死后还会有一些资源占用进程号进程的运行状态运行时间等待父进程通过系统调用进行资源回收相当于子进程死了之后需要父进程来给他收尸除了进程之外所有的进程最后都会步入僵尸进程在一种情况下是会带来危害的子进程退出之后父进程没有及时处理僵尸进程就会一直占用资源如果产生了大量僵尸进程资源过度使用系统没有可用的进程号导致系统不能产生新的进程注意在中子进程退出后会立即被系统回收不会产生真正的僵尸进程在系统中不需要显式调用来回收子进程资源孤儿进程子进程处于存活状态父进程意外死亡操作系统就会开设一个孤儿院进程用来管理孤儿进程回收孤儿进程相关资源知识点操作系统会自动处理孤儿进程将它们的父进程更改为进程为所以孤儿进程不会造成资源泄漏问题多线程编程深入解析线程基础线程是轻量级的进程也是多任务编程的一种方式一个进程中可以包含多个线程线程也是一个运行行为消耗计算机资源一个进程中的所有线程共享这个进程的资源线程的创建和销毁消耗资源远小于进程一个工厂至少有一个车间一个车间中至少有一个工人工人去利用车间的设备工作一个程序至少有一个进程一个进程中至少有一个线程线程去利用进程的资源工作线程创建方法方法一使用类创建线程线程开始工作线程结束工作线程线程启动线程等待线程结束主线程结束方法二继承类创建线程线程开始执行线程执行完毕消息线程子进程操作完毕线程子进程操作完毕主进程执行完毕线程常用方法表方法名说明实际应用场景启动线程开始执行线程任务定义线程执行的任务重写该方法自定义线程行为等待线程结束协调线程执行顺序等待线程结束有超时时间防止无限等待检查线程是否活动监控线程状态获取线程名称调试和日志记录设置线程名称便于识别不同线程设置为守护线程随主线程结束而结束的后台任务检查是否为守护线程确认线程类型获取线程唯一标识线程获取当前线程对象在函数中获取当前执行线程线程使用实例基本线程示例访问网站下载文件读取长度为单线程下载所有网站多线程下载网站多线程下载所有网站等待所有线程结束准备一些网站用于演示单线程下载单线程下载开始单线程下载结束耗时秒多线程下载开始多线程下载结束耗时秒密集型任务如网络请求适合使用多线程可以显著提高性能这是因为当一个线程等待操作完成时其他线程可以继续执行守护线程示例线程启动线程结束设置为守护线程主线程结束时线程也会结束已经被废弃的现在使用参数代替启动普通线程启动守护线程这里需要启动线程否则不会执行等待普通线程完成等待线程完成检测线程状态线程是否存活线程是否存活线程是否存活主线程休眠一段时间以便守护线程有机会执行主线程结束守护线程特性守护线程会随着主线程的结束而结束不管它是否执行完成适用于需要在后台运行但不要求必须完成的任务如监控日志记录等守护线程系统资源监控器持续监控使用率和内存使用情况并记录到日志中系统监控守护线程启动使用率内存使用率系统资源占用过高请及时处理系统监控线程异常系统监控守护线程结束创建并启动系统监控守护线程主线程继续执行一段时间守护线程在后台运行主线程运行中监控守护线程在后台运行运行秒后结束主线程结束守护线程将自动终止监控守护线程是否存活主线程结束守护线程将自动终止线程池详解线程池是一种管理线程资源的方式它预先创建一定数量的线程然后复用这些线程来执行任务避免了频繁创建和销毁线程的开销定义一个耗时函数使用方法提交任务给线程池执行返回对象列表任务已提交主线程继续执行等待所有任务完成并获取结果任务执行完毕结果为总共耗时秒线程池在语句结束时自动关闭主要方法方法名简洁解释适用场景异步执行函数返回对象单独提交任务并获取结果对每个输入并行执行函数批量处理类似任务关闭执行器资源释放获取任务执行结果获取异步任务的返回值添加任务完成回调函数任务完成后的后续处理返回已完成任务的迭代器先处理先完成的任务等待任务完成任务同步点深入理解线程池最大的好处是控制并发数量防止系统资源被耗尽在实际开发中建议将线程数设置为核心数的倍具体取决于任务是密集型还是密集型完整示例耗时任务不同的值耗时不同任务完成后触发的回调函数任务完成结果为方法示例提交任务完成等待结果获取任务执行结果会阻塞直到所有任务完成返回已完成任务的迭代器任务完成总耗时秒方法示例对每一个输入并行执行函数返回结果迭代器与不同会自动收集结果并按输入顺序返回不需要手动调用任务提交完成直接获取有序结果转换为列表时会按照输入顺序返回结果如果任务未完成会在这里阻塞等待结果总耗时秒示例添加任务完成回调函数添加回调函数任务完成后自动调用已添加回调函数主线程继续执行等待所有任务完成耗时秒适用场景任务完成后的后续处理适合需要在任务完成时执行额外操作而不阻塞主线程示例等待任务完成任务已提交等待所有任务完成等待所有任务完成完成的任务数未完成的任务数所有任务执行完毕结果为耗时秒适用场景任务同步点适合需要等待一组任务全部或部分完成后再继续执行的情况事件同步机制是一种线程同步机制用于协调多个线程的执行顺序它本质上是一个内部的标志位线程可以等待这个标志位被设置也可以设置或清除这个标志位创建一个事件对象模拟公交车到站的函数模拟公交车到站过程公交车即将到站模拟行驶时间公交车已到站设置事件通知等待的乘客发射信号让等车的人上车模拟乘客等车乘客名称等待公交车到站等车中阻塞等待信号出发创建公交车线程创建多个乘客线程乘客模拟乘客陆续到站主要方法方法名描述使用场景设置事件标志为通知等待的线程继续执行清除事件标志为重置事件状态使线程再次等待检查事件状态判断事件是否已被设置等待事件被设置阻塞线程直到事件被设置或超时应用场景适合实现一次性通知多个线程的场景比如多个工作线程等待初始化完成多个消费者等待数据准备就绪等在开发中可用于协调多个后台任务的启动时机定时器定时器是线程的一个特殊应用用于在指定时间后执行某个操作的模块提供了类来实现这一功能延迟执行的问候函数要问候的对象名称说哈哈我是延迟秒后才执行的创建一个定时器秒后执行函数参数为小明小明启动定时器定时器已启动但函数还未执行主线程继续执行不会被阻塞实用技巧可用于实现超时处理延迟重试定时清理等场景例如在网络编程中可以用设置请求超时机制在数据同步中可以用定期执行同步任务多进程多线程性能分析在中由于全局解释器锁的存在多线程并不能真正实现并行计算因此根据任务特性选择合适的并发模型十分重要不同场景的最优选择任务类型多进程多线程推荐选择计算密集型效率高可利用多核受限制效率相对较低多进程密集型资源占用大资源占用小效率与多进程相当多线程实际应用建议现代开发中约以上的程序属于密集型适合使用多线程对于数据分析图像处理等计算密集型任务则推荐使用多进程也可以考虑混合使用多进程下每个进程内再使用多线程计算密集型任务测试计算密集型任务对比测试计算密集型任务执行大量计算使用多进程或多线程取消相应的注释来测试多进程结果大概是秒多线程结果大概是秒花费时间密集型任务测试密集型任务对比测试密集型任务使用模拟操作模拟等待创建个任务使用多进程或多线程取消相应的注释来测试多进程结果约秒多线程结果约秒花费时间性能陷阱多线程在密集型任务中表现出色但过多的线程可能导致线程切换开销增大反而降低效率经验值是控制线程数为核心数的倍协程技术详解协程基础概念协程也称为微线程是一种用户态内的上下文切换技术可以在单线程下实现并发效果协程通过巧妙的编程技巧实现了程序主动让出和恢复执行的能力使得单线程内可以模拟出并发的效果进程资源单位系统分配资源的基本单位拥有独立的内存空间线程执行单位调度和执行的最小单位共享所属进程的内存空间协程根本不存在它是程序员人为创造出来的切换保存状态当程序遇到的时候通过我们的代码让我们的程序自动完成切换也就是通过代码监听一旦程序遇到就在代码层面自动切换给的感觉就是我们的程序没有换句话说也就是我们欺骗了协程的核心原理是切换保存状态即在多个任务之间来回切换每次切换都保存当前任务的执行状态下次切换回来继续执行在中可以通过关键字模块或库实现协程深入理解协程不是提升计算效率而是提升效率在密集型应用中协程可以让在等待的同时执行其他任务从而提高资源利用率协程的切换不需要操作系统参与开销远小于线程切换概念资源占用切换开销实现方式适用场景进程高独立内存空间高涉及内存映射操作系统调度密集型需要隔离的任务线程中共享内存但有独立栈中上下文切换操作系统调度混合型任务兼顾计算与协程低共享线程内全部资源低用户态切换程序自行控制密集型高并发网络应用协程效率对比对于计算密集型任务时使用协程反而会降低效率串行执行计算密集型函数执行简单累加计算计算密集型函数执行简单累加计算顺序执行然后执行保留两位小数串行执行总共用时秒串行执行总共用时秒使用实现协程切换带的计算密集型函数主动让出执行权保存当前执行状态使用的生成器进行交替执行创建生成器对象切换到执行一步会执行到下一个后暂停执行内部会与交替执行保留两位小数协程用时秒约秒注意事项对于计算密集型任务协程切换反而会增加开销降低效率但对于密集型任务协程切换可以显著提高效率这是因为在等待期间协程可以切换到其他任务继续执行避免了空闲模块了解是一个轻量级的协程库提供了基本的协程实现它允许在不使用回调函数的情况下在不同函数间来回切换执行实现了所谓的确定性切换协程函数函数正在运行模拟某些操作主动切换到函数执行协程函数函数正在运行模拟某些操作切换回函数执行创建两个对象将函数封装为对象将函数封装为对象从函数开始执行启动协程核心方法与属性方法属性名描述使用场景示例获取当前正在执行的对象在函数内获取当前协程将控制权切换到另一个协程间的主动切换传递参数获取当前的父协程层级管理向对象中抛出异常协程异常处理错误信息判断是否已经执行完毕协程状态检查已执行完毕获取当前的帧对象调试和检查协程状态绑定到的可调用对象查看协程的目标函数使用技巧适合实现简单的协程切换但不支持自动在操作时切换因此常与事件循环结合使用如库的优势在于它的轻量和灵活性可以构建复杂的协程调度系统模块了解是基于的协程库增加了事件循环和自动切换功能它通过猴子补丁将标准库中的阻塞操作替换为非阻塞版本使普通的同步代码能够以异步方式执行是一个基于协程的网络库它使用在或等事件循环之上提供高级同步实现了标准库里面大部分的阻塞式系统调用包括和等模块可以使用猴子补丁将这些阻塞式调用变为协作式运行猴子补丁的功能很强大但是也带来了很多的风险尤其是像这种直接进行替换的补丁整个进程所使用的模块都会被替换可能自己的代码能住但是其它第三方库有时候问题并不好排查即使排查出来也是很棘手所以就像松本建议的那样如果要使用猴子补丁那么只是做功能追加尽量避免大规模的覆盖虽然猴子补丁仍然是邪恶的但在这种情况下它是有用的邪恶基础操作应用猴子补丁将标准库的阻塞操作替换为非阻塞版本必须在导入其他模块前调用确保所有操作都被替换替换所有可能的阻塞调用协程函数模拟操作主动让出控制权协程函数模拟操作主动让出控制权协程函数模拟操作主动让出控制权创建三个协程创建协程但不立即执行创建协程但不立即执行创建协程但不立即执行等待所有协程完成类似于多线程中的方法常用详解方法类名描述使用场景实际应用示例创建并运行协程启动异步任务启动多个请求并行处理等待多个协程完成同步点等待所有任务完成批量处理多个数据源协程休眠并让出控制权模拟操作主动让出控制权测试协程调度防止密集任务阻塞等待对象协程完成等待部分任务完成等待最快完成的结果终止协程取消不需要的任务实现任务超时取消应用猴子补丁将同步库变为异步兼容使用前替换标准库函数协程安全的队列协程间通信和数据传递生产者消费者模式实现事件通知机制协程间同步和通知完成信号传递协程池限制并发数量控制网络请求并发数多路复用监控多个文件描述符自定义事件循环使用注意事项所有协程运行在同一线程中不能跨线程同步数据是协程安全的可以用于协程间通信不能有长时间阻塞的密集型操作会阻塞整个事件循环最好使用自身的非阻塞库或已打补丁的标准库猴子补丁会修改全局状态可能影响第三方库的行为应在所有导入前应用调试协程比调试线程更困难错误追踪可能会更复杂实际应用场景示例替换标准库获取内容的函数要获取的网址响应状态码内容长度开始请求进行请求操作会自动切换完成请求耗时秒请求出错要获取的列表创建协程任务等待所有任务完成获取结果打印结果结果汇总状态码内容长度字节总耗时秒与的区别与选择特性实际应用建议基本原理轻量级上下文切换基于增加事件循环简单任务用复杂系统用处理不提供操作支持提供自动切换机制网络应用选择自定义调度选择切换方式需要显式调用在操作时自动切换手动控制流程用自动化处理用复杂度简单仅提供基本切换复杂提供完整生态系统小型项目用大型项目用适用场景简单协程调度高并发网络应用爬虫服务代理服务器首选性能轻量开销小比略重但实用性强极致性能用平衡性能和开发效率用学习曲线简单容易理解较复杂概念较多入门协程从开始再过渡到社区支持基础库更新较少活跃有完整生态长期项目建议使用选择建议如果只需要轻量级的上下文切换可以使用如果需要处理密集型应用特别是网络编程建议使用大多数实际项目中是更好的选择因为它提供了更完整的功能和自动化的处理协程技术随着的发展协程技术已经有了显著进步从引入的库开始对协程的原生支持不断增强到年已经拥有更成熟更高效的协程生态系统与原生协程引入的语法使得协程编程变得更加直观和强大这是目前最推荐的协程实现方式模拟从网络获取数据的异步函数开始获取数据延迟秒成功获取数据长度数据异步操作的主函数程序开始时间串行执行示例串行执行请求两个数据串行执行结果程序结束时间程序耗时秒并行执行请求两个数据并行执行示例批量等待所有任务完成并行执行结果程序结束时间程序耗时秒在中可以直接使用运行主协程常用方法函数描述使用场景示例运行协程程序入口点创建任务并行执行协程并行运行多个协程批量并发任务带超时的等待实现超时控制非阻塞睡眠模拟延迟协程安全的队列协程间数据传递低级异步原语自定义异步操作防止取消传播保护关键协程按完成顺序返回结果处理最先完成的任务对象是中用于封装协程的对象可以用于并发执行多个任务可以通过对象等待协程完成进入模拟操作离开创建任务等待任务完成返回值对象是的基类表示一个未完成的结果在底层异步操作中常常用来表示某些未决的操作结果定义一个异步函数用于设置的结果异步等待秒模拟耗时操作设置的结果为定义主异步函数获取当前正在运行的事件循环创建对象它代表一个尚未完成的异步操作创建对象创建一个任务来执行函数不等待其完成立即返回等待完成并获取其结果等待完成打印的结果的结果运行主异步函数异步上下文管理器异步上下文管理器允许在进入和退出时执行异步操作常用于异步资源管理资源获取资源释放执行任务中锁与并发性能全局解释器锁是解释器的一个特性它确保同一时刻只有一个线程可以执行字节码这个特性对多线程编程有着深远影响也是导致速度慢的两大原因之一其另外一个原因是因为是解释形语言但后续可通过技术实现的预编译但唯独这个原因没有解决在早期开发时为解决垃圾回收机制内部问题采用了锁所以程序无法直接利用多核的优势全局解释器锁是特有的一个物件作用是让一个进程中同一时刻只能有一个线程可以被调用如果程序想利用计算机的多核优势让同时处理一些任务适合用多进程开发即使资源开销大如果程序不想利用计算机的多核优势适合用多线程开发的本质与工作原理本质上是一把互斥锁用于保护解释器的内部状态主要解决了对象的内存管理问题特性描述实现方式互斥锁作用对象解释器进程控制范围字节码执行释放时机操作执行固定字节码数量后影响范围仅影响不受影响深入理解并非语言本身的特性而是实现的产物它解决了简单引用计数式内存管理的线程安全问题但也限制了多线程程序利用多核性能的能力工作示意伪代码获取锁执行一定数量的字节码释放锁以允许其他线程运行等待再次获取这也就导致了每一个线程都需要在执行获取字节码时都要经历拿锁解锁的过程并发与并行的区别并发和并行是两个在计算机科学中经常出现的概念虽然常被混用但有着本质区别特性并发并行定义多个任务在同一时间间隔内发生多个任务在同一时刻发生重点任务切换与调度任务的同时执行资源需求可以在单处理器上通过时间片轮转实现需要多个处理器或核心执行方式任务交替执行共享处理器时间每个任务有独立的处理器同时执行适用场景密集型任务如网络请求文件读写计算密集型任务如图像处理科学计算实现难度相对简单关注任务调度相对复杂需考虑数据分割同步和合并实现多线程协程多进程关键理解由于的存在的多线程实际上只能实现并发而不能实现真正的并行要实现并行需要使用多进程或依赖不受限制的扩展库如使用扩展的线程安全与并发控制线程安全指在多线程环境下程序能够正确地处理共享资源不会因为多线程同时访问而导致数据不一致尽管的能减轻一些并发问题但并不能完全保证线程安全线程安全问题示例共享的全局变量增加计数器但使用了非原子操作的方式模拟线程安全问题读取修改写入过程中可能被中断读取当前值模拟线程在读取后被切换的情况随机休眠一个很小的时间增加线程切换的可能性在本地修改写回全局变量运行多个线程同时增加计数器理论上应该等于预期结果实际结果丢失的增量完成的迭代次数开始时间为运行个线程每个线程增加计数器次理论上最终结果应该是但由于线程安全问题实际结果会小于这个值累计用时秒使用线程锁解决安全问题共享的全局变量创建一个线程锁增加计数器使用线程锁确保线程安全使用线程锁保护临界区在锁的保护下直接修改全局变量运行多个线程同时增加计数器理论上应该等于预期结果实际结果丢失的增量完成的迭代次数开始时间为运行个线程每个线程增加计数器次使用线程锁后最终结果应该正确等于累计用时秒线程锁作用与注意事项锁确保同一时刻只有一个线程能访问共享资源锁会影响性能特别是在竞争激烈的情况下锁的粒度需要权衡粒度太细会增加锁操作开销太粗会降低并发度锁可能引发死锁问题需谨慎设计锁的获取顺序中的锁机制全面解析的模块提供了多种锁和同步原语用于不同并发控制场景深入理解这些锁的特性和适用场景对于开发可靠的并发程序至关重要锁类型及其特性锁类型描述独占性可重入性公平性注意事项基本互斥锁是否非公平最简单的锁同一线程不能重复获取可重入锁是是非公平同一线程可多次获取必须对应释放相同次数条件变量非公平基于锁实现提供机制信号量否非公平限制资源访问线程数量有界信号量否非公平限制资源数量防止过度释放事件对象用于线程间通知而非资源控制栅栏对象使多个线程同步到达某点再继续线程安全队列先进先出内部带锁用于线程间数据传递进程锁是否非公平用于进程间同步的锁异步锁是否用于协程间的同步互斥锁互斥锁是最基本的锁类型它确保同一时刻只有一个线程可以访问受保护的资源访问共享资源的函数线程用于标识不同线程尝试获取锁添加超时参数防止无限等待线程获取锁读取修改写入操作需要原子性保护模拟处理延时增加竞争概率线程修改共享数据当前值为释放锁线程释放锁线程获取锁失败访问共享资源的函数使用语句自动释放锁简化代码线程获取锁读取修改写入操作需要原子性保护模拟处理延时增加竞争概率线程修改共享数据当前值为线程释放锁使用线程池创建多个线程等待所有线程完成最终共享数据值为方法描述参数返回值获取锁是否阻塞超时时间秒布尔值表示是否获取成功释放锁无无如果当前线程未持有锁则抛出检查锁状态无布尔值表示锁是否被某个线程持有支持语句无锁对象自身语句退出时调用异常信息无自动释放锁可重入锁可重入锁允许同一个线程多次获取该锁而不会导致自我死锁这在递归调用或者嵌套加锁场景中特别有用创建可重入锁嵌套列表数据结构递归处理数据要处理的数据项可以是列表或单个元素当前递归深度用于缩进显示获取锁创建缩进效果增强可读性增加缩进量使层次更明显打印当前处理的数据项和深度线程处理深度递归处理逻辑列表节点处理继续向下递归发现列表开始遍历子元素显示子项的索引增强结构可视化处理子项递归调用这里会再次获取同一个锁叶子节点处理递归终止条件发现元素进行处理处理结果释放锁创建多个线程访问嵌套数据每个线程处理完整的数据结构错开线程启动时间等待所有线程结束所有线程都结束了方法描述与的区别获取锁记录获取线程和次数释放锁计数器减只有为时才真正释放检查当前线程是否持有锁没有此方法使用建议一般推荐使用而非因为它更安全更灵活即使在不需要重入功能的场景下也不会有明显性能损失条件变量根据条件控制锁条件变量是一种高级的同步原语同步原语就是让多个线程能够和谐相处的机制它允许线程等待特定条件满足后再继续执行条件变量内部包含一个锁用于控制对共享状态的访问线程安全的缓冲区使用条件变量控制生产者消费者模型初始化缓冲区共享数据缓冲区最大容量创建条件变量基于生产者方法向缓冲区添加数据使用条件变量的语句自动获取和释放锁当缓冲区已满时等待消费者处理生产者缓冲区已满等待消费者等待唤醒通知自动释放锁让其他线程能访问缓冲区添加数据到缓冲区生产者添加到缓冲区当前大小通知所有等待的消费者有新数据可用消费者方法从缓冲区获取数据当缓冲区为空时等待生产者添加数据消费者缓冲区为空等待生产者从缓冲区取出数据消费者从缓冲区取出当前大小通知所有等待的生产者缓冲区有空间生产者任务生产个产品产品模拟生产时间消费者任务每个消费者消费个产品模拟消费时间消费者处理主函数创建并启动生产者和消费者线程创建共享缓冲区创建生产者和消费者线程个生产者个消费者启动所有线程等待所有线程完成所有生产和消费任务已完成方法描述参数注意事项初始化条件变量可选的或不指定则创建获取底层锁同底层锁的方法一般通过语句使用释放底层锁无一般通过语句自动释放等待条件超时时间秒调用前必须已获得锁等待直到条件为真条件函数超时时间简化循环等待模式唤醒个等待的线程要唤醒的线程数不会立即释放锁唤醒所有等待的线程无适用于广播通知使用注意调用会释放锁允许其他线程修改条件状态使用可以避免虚假唤醒问题调用后锁不会立即释放需要当前线程退出块使用而非可以避免信号丢失问题信号量控制并发数量信号量是一种计数器用于控制同时访问特定资源的线程数量常用于限制并发访问数创建信号量限制最多三个线程同时访问资源模拟优先的资源池资源资源资源跟踪资源使用情况保护资源分配的锁工作线程函数模拟使用受限资源尝试获取信号量工作线程等待获取资源等同于和中工作线程获取资源信号量检查中的每个资源如果该资源不在字典的值中则认为是可用的工作线程没有找到可用资源理论上不应该发生记录资源使用情况工作线程分配到资源当前使用情况模拟使用资源工作线程使用资源时间秒释放资源工作线程释放资源当前使用情况创建线程池并启动三个线程方法描述参数返回值初始化信号量初始计数器值无获取信号量是否阻塞超时时间布尔值表示是否获取成功释放信号量释放的数量无支持语句无信号量对象自身语句退出时调用异常信息无自动释放信号量有界信号量详解有界信号量是信号量的一个变种它会检查释放操作是否会导致计数器超过初始值如果超过则抛出异常这可以帮助检测程序中的信号量使用错误创建有界信号量初始值为演示有界信号量与普通信号量的区别获取信号量次获取信号量次获取信号量次信号量已用完再获取将阻塞释放全部信号量释放信号量次释放信号量次释放信号量次超出初始值的释放将抛出异常尝试额外释放一次这一行不会执行捕获预期异常意外错误允许无限制地调用即使计数器超过初始值在计数器超过初始值时会抛出异常生产环境推荐使用或安全的使用语句保证程序安全事件对象事件对象是最简单的线程通信机制之一它允许一个线程发送信号给其他线程适合简单的一次性通知场景创建事件对象工作线程函数等待开始信号工作线程准备完毕等待开始信号等待开始信号收到信号开始工作工作线程开始工作记录结果工作线程完成工作工作线程完成工作用时秒创建线程池等待所有线程准备完毕发送开始信号发送开始信号等待所有线程完成工作所有工作线程完成方法描述参数返回值设置事件唤醒所有等待的线程无无清除事件标志无无判断事件是否已设置无布尔值等待事件被设置超时时间如果超时返回否则返回使用场景启动信号所有线程等待统一开始停止信号通知所有线程停止工作一次性通知当某条件满足时通知等待线程栅栏对象栅栏是一种同步原语它要求固定数量的线程都到达栅栏点后才允许所有线程继续执行这对于分阶段任务的同步特别有用定义参与方数量创建栅栏对象当个线程都到达时才继续工作线程函数模拟多阶段工作工作线程工作线程开始第一阶段工作模拟第一阶段工作工作线程完成第一阶段用时秒等待其他线程等待所有线程完成第一阶段工作线程通过第一个栅栏开始第二阶段模拟第二阶段工作工作线程完成第二阶段用时秒等待其他线程等待所有线程完成第二阶段工作线程通过第二个栅栏工作全部完成工作线程检测到栅栏被破坏创建工作线程等待所有线程完成所有工作阶段已完成方法描述参数返回值初始化栅栏参与方数量所有线程到达时执行的回调等待超时无等待所有参与方到达覆盖默认超时时间线程的到达序号将栅栏重置到初始状态无无正在等待的线程会抛出将栅栏置于损坏状态无无所有等待线程会抛出参与方数量属性无整数当前等待的线程数属性无整数栅栏是否处于损坏状态属性无布尔值注意事项如果等待超时栅栏会进入损坏状态如果等待时的线程被中断栅栏也会损坏可以通过方法重新使用已损坏的栅栏线程安全队列模块提供的类是一个线程安全的队列实现通常用于线程间的数据传递和任务分发创建线程安全队列最多容纳个任务结果队列无大小限制用于通知工作线程结束的标志生产者线程产生任务任务将任务放入队列生产者添加到队列当前队列大小随机延迟添加结束标记生产者所有任务已产生设置退出标志消费者线程处理任务直到所有任务都处理完毕或有新任务到来从队列获取任务最多等待秒模拟处理任务消费者开始处理将处理结果放入结果队列结果耗时秒标记任务完成消费者完成处理队列为空且设置了退出标志时结束循环消费者队列暂时为空等待任务消费者退出创建生产者线程和消费者线程创建生产者线程创建消费者线程等待所有线程结束打印结果队列中的所有结果处理结果消费者的结果方法属性描述参数返回值特性初始化队列队列最大大小表示无限无放入元素元素是否阻塞超时时间无队列满时可能阻塞或抛出异常获取元素是否阻塞超时时间队列元素队列空时可能阻塞或抛出异常标记任务完成无无等待队列中所有任务处理完成无无返回队列大小无整数检查队列是否为空无布尔值检查队列是否已满无布尔值非阻塞版本的元素无队列满时抛出异常非阻塞版本的无队列元素队列空时抛出异常变种后进先出队列栈优先级队列元素为优先级数据元组简单的无界队列不支持和死锁问题分析与解决死锁是指两个或多个线程互相等待对方释放资源导致程序无法继续执行的情况死锁示例创建两个锁第一个任务先获取再获取任务开始尝试获取锁获取号锁任务获取到等待一会让任务有机会获取任务尝试获取尝试获取号锁但可能永远阻塞于此任务同时获取了两把锁使用两把锁保护的代码释放锁任务释放了任务释放了第二个任务先获取再获取任务开始尝试获取锁获取号锁任务获取到等待一会任务尝试获取尝试获取号锁但可能永远阻塞于此任务同时获取了两把锁使用两把锁保护的代码释放锁任务释放了任务释放了创建两个线程启动线程等待一段时间后检查是否发生死锁检查线程是否还活着线程状态活跃已结束线程状态活跃已结束检测到可能的死锁情况死锁的四个必要条件互斥条件资源不能被共享一次只能被一个线程使用请求与保持条件线程已获得资源但又提出新的资源请求不剥夺条件线程已获得的资源不能强制被剥夺循环等待条件线程之间形成头尾相接的循环等待资源关系死锁解决方案创建两个锁安全地获取两个锁使用超时机制避免死锁第一个锁第二个锁线程名称是否成功获取两个锁尝试获取第一个锁获取到第一个锁尝试获取第二个锁获取到第二个锁成功获取两个锁获取第二个锁失败释放第一个锁避免死锁获取第二个锁失败释放第一个锁并重试短暂休眠减少活锁可能性获取第一个锁失败重试短暂休眠避免忙等修复死锁的任务使用安全获取锁函数任务开始执行任务任务同时持有两把锁执行关键代码模拟工作释放锁任务释放任务释放任务无法获取所需的锁任务取消修复死锁的任务使用一致的锁获取顺序任务开始执行按与任务相同的顺序获取锁避免死锁任务任务同时持有两把锁执行关键代码模拟工作释放锁任务释放任务释放任务无法获取所需的锁任务取消创建两个线程启动线程等待线程结束所有线程执行完毕没有死锁死锁预防方法按顺序获取锁使所有线程按相同顺序获取锁超时机制使用设置获取锁的超时时间一次性获取所有锁创建更高级别的锁来同时获取多个锁使用显式资源分级为资源分配层级只允许按层级顺序获取避免嵌套锁设计简化的锁策略减少同时持有多个锁的情况使用语句确保锁在异常情况下也能被释放原子操作与锁优化在并发编程中原子操作是指不可被中断的操作它们要么完全执行要么完全不执行提供了一些原子操作工具可以减少对锁的依赖对象线程本地存储线程本地存储提供了一种每个线程拥有自己独立数据副本的机制避免了共享状态带来的并发问题我们可以往上挂载对象这样我们的每一个线程就会有属于自己的独立数据创建线程本地存储对象处理请求的工作函数为当前线程设置上下文信息模拟处理请求的各个阶段请求开始处理线程用户验证处理响应计算总处理时间请求完成处理总耗时秒线程处理请求的某个阶段访问线程本地变量无需传递参数模拟阶段处理请求阶段完成用户所有请求处理完成带锁的缓存装饰器提供了一个线程安全的缓存机制当一个函数的计算逻辑十分复杂我们就可以采用缓存来优化这一点缓存演示计算斐波那契数列的第个数使用缓存优化性能演示缓存的效果不使用缓存的计算时间测试无缓存版本无缓存计算耗时秒测试有缓存版本首次使用缓存计算耗时秒再次调用应该直接从缓存获取结果再次使用缓存计算耗时秒显示缓存信息缓存信息锁的高级应用模式读写锁模式中的读写锁主要用于在多线程环境中控制对共享资源的访问它允许多个线程同时读取共享数据但在写操作时其他线程不能进行读或写操作具体的应用场景包括数据共享与并发读取当多个线程需要读取同一份数据时使用读锁可以提高并发性允许多个线程同时访问数据而不需要每次访问都加锁写操作的独占性当有线程进行写操作时需要获取写锁这样可以确保写操作的独占性避免数据竞争和不一致性性能优化在读多写少的场景下读写锁能提高性能因为它允许多个线程并行读取数据而只有在写入时才会阻塞其他线程我们先从原生实现读写锁来作为演示掌握了原生的方式我们可以使用第三方库来帮我们快速实现读写锁读写锁实现允许多个读取者同时访问或单个写入者独占访问初始化读写锁当前读取者数量当前写入者数量等待写入的线程数当前持有写锁的线程获取读锁当有写入者或正在等待的写入者时读取者需要等待释放读锁最后一个读取者通知所有等待的线程获取写锁获取当前线程增加等待写入计数等待没有读取者和写入者减少等待写入计数释放写锁释放未持有的写锁通知所有等待的线程支持语句的上下文管理器获取读锁和写锁的方法获取读锁上下文管理器获取写锁上下文管理器共享数据和读写锁读取者线程读取者获取读锁读取共享数据模拟读取操作读取者读取到读取者之间的休息写入者线程写入者准备新数据获取写锁修改共享数据模拟写入操作写入者更新为写入者之间的休息创建读取者和写入者线程启动所有线程等待所有线程完成最终数据使用库实现读写锁读写锁实现示例库提供了三种读写锁实现读者优先第一读者写者问题写者优先第二读者写者问题公平优先第三读者写者问题每种锁都有对应的可降级版本带后缀允许将锁从写模式降级到读模式创建一个公平优先的读写锁共享数据用于演示的读取函数读取者获得读锁模拟读取操作读取者完成读取读取者释放读锁用于演示的写入函数写入者获得写锁模拟写入操作写入者完成写入写入者释放写锁演示读读不互斥演示读读不互斥演示读写互斥演示读写互斥先启动一个长时间的读取线程给读取线程一点时间获取锁尝试启动写入线程应该被阻塞直到读取完成演示写写互斥演示写写互斥先启动一个长时间的写入线程给第一个写入线程一点时间获取锁尝试启动另一个写入线程应该被阻塞直到第一个写入完成演示锁获取超时演示锁获取超时先启动一个长时间的写入线程给写入线程一点时间获取锁尝试获取读锁但设置较短的超时时间读取者成功获得读锁不应该发生读取者获取读锁超时预期行为演示读读不互斥演示读写互斥演示写写互斥演示锁获取超时读写锁特性描述优势适用场景读共享写独占多个读取可并发写入需独占提高读多写少场景的并发性配置数据缓存系统数据集读写优先级可以设置读优先或写优先根据应用需求调整性能特性根据读写比例调整策略升级降级支持锁的升级读写或降级写读灵活处理复杂访问模式先检查后修改的操作使用建议读多写少的场景推荐使用读写锁注意防止写饥饿即读取者太多导致写入者长时间等待锁排序解决死锁为避免死锁一个常用的技术是确保所有线程按照相同的顺序获取多个锁模拟银行账户初始化账户用于账户排序的唯一账户余额在账户间转账使用账户排序策略避免死锁转出账户转入账户转账金额线程名称按照账户从小到大的顺序获取锁确保所有线程获取锁的顺序一致尝试锁定账户已锁定账户模拟网络延迟尝试锁定账户已锁定账户执行转账操作已从转账元到创建两个账户初始状态创建两个线程同时进行相反方向的转账转账线程转账线程启动线程等待线程结束最终状态两阶段锁定两阶段锁定是一种事务并发控制协议分为获取阶段和释放阶段可以保证事务的可串行化演示两阶段锁定协议的简单数据库初始化数据库简单的数据项每个数据项的锁执行两阶段锁定事务需要读取的数据项列表需要写入的数据项列表事务操作函数事务是否成功按字母顺序排序所有需要锁定的项避免死锁阶段获取锁阶段增长阶段事务开始获取锁对于读取项获取共享锁对于写入项获取排他锁这里简化为都使用排他锁事务已锁定获取的锁超时执行事务操作事务操作完成事务错误阶段释放锁阶段收缩阶段事务已释放转账事务账户余额不足模拟操作耗时执行转账已从转账到执行事务的线程函数线程尝试转账从到成功失败线程转账耗时秒创建数据库实例初始账户状态创建并启动多个线程从转到从转到从转到等待所有线程完成最终账户状态总金额总金额应该不变超时重试模式在并发环境中有时获取锁可能会失败超时重试模式可以增加获取锁的成功概率同时避免永久阻塞共享资源更新共享资源使用超时重试模式工作线程最大重试次数是否成功更新随机生成操作标识用于跟踪工作线程操作尝试更新资源初始回退时间尝试获取锁设置超时时间工作线程操作获取到锁当前值模拟资源更新操作随机决定操作时间有时可能很长更新资源工作线程操作更新成功新值耗时秒释放锁工作线程操作释放锁工作线程操作获取锁超时重试使用指数退避策略每次重试间隔加长指数增长工作线程操作达到最大重试次数放弃操作工作线程函数工作线程要执行的操作次数尝试更新资源线程之间的间隔工作线程完成次成功更新创建多个工作线程等待所有线程完成最终资源值多进程与多线程结合的混合模型对于复杂应用常常需要结合多进程和多线程的优势多进程跨越限制利用多核心每个进程内使用多线程处理任务模拟密集型任务发送请求并处理响应线程完成请求状态码线程请求失败模拟密集型任务处理数据模拟密集型计算解析数据进程处理了行数据每个进程的工作函数使用线程池处理任务进程启动创建线程池处理任务提交所有请求任务到线程池收集结果处理时出错模拟一些数据处理密集型任务进程完成所有任务测试列表将分成组每个进程处理个创建进程池提交任务到进程池收集所有进程的结果进程返回结果个请求任务处理了行数据进程执行出错总执行时间秒这种混合模型充分利用了的并发性能多进程并行跨越限制在多个核心上同时执行代码每进程多线程处理进程内的密集型任务提高并发性任务队列有效分配和管理工作负载平衡资源利用细粒度锁与粗粒度锁锁的粒度指锁保护资源的范围大小细粒度锁保护小范围资源提高并发度粗粒度锁保护大范围资源简化编程但可能降低并发度共享资源粗粒度锁用于整个账户操作细粒度锁分别用于读取和写入操作粗粒度锁示例锁定整个账户操作模拟读取余额操作模拟网络延迟或处理时间模拟更新余额操作粗粒度锁转账当前余额细粒度锁示例分别锁定读取和写入操作锁定读取操作模拟处理时间这里可以执行一些不需要锁定的计算锁定写入操作细粒度锁转账当前余额测试函数创建共享账户测试粗粒度锁创建个使用粗粒度锁的线程等待所有线程完成粗粒度锁总耗时秒重置账户和线程列表测试细粒度锁创建个使用细粒度锁的线程等待所有线程完成细粒度锁总耗时秒性能比较细粒度锁比粗粒度锁快倍锁粒度优点缺点适用场景粗粒度锁简单易维护不易死锁并发性能低可能导致线程等待简单应用对性能要求不高的场景细粒度锁并发性能高资源利用率高实现复杂可能造成死锁高性能要求资源访问模式明确的场景消息队列与进程通信在并发编程中队列是一种常用的数据结构它遵循先进先出的原则适合用于线程或进程间的通信而堆栈则遵循后进先出的原则中的和模块提供了多种类型的队列每种队列适用于不同的场景队列基础知识的模块和模块提供了多种队列类型主要包括队列类型模块特点适用场景线程安全的队列线程间通信线程安全的队列堆栈需要后进先出的场景优先级队列任务具有优先级的场景进程安全的队列进程间通信带有任务完成通知机制的队列生产者消费者模型队列使用示例生产者进程函数生产者函数负责生产数据并放入队列小吃生产者生产了放入队列模拟耗时操作生产结束信号生产者结束消费者进程函数消费者函数负责从队列中获取数据并消费从队列中获取项目若获取到结束信号则退出循环消费者消费了消费者结束创建一个队列对象启动生产者进程启动消费者进程优先级队列示例优先级队列按任务的优先级顺序处理任务数字越小优先级越高以下是如何使用的示例创建优先级队列优先级队列的元素是元组第一个元素是优先级第二个元素是任务按照优先级处理任务处理任务优先级队列为空任务处理完毕添加任务到优先级队列普通任务紧急任务中等优先级任务另一个紧急任务低优先级任务创建任务处理线程等待所有任务处理完毕所有任务处理完毕",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2025-06-17 17:51:07",postMainColor:""}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0F1C2E')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#cee8ff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/index_media.css" media="(max-width:0),screen and (prefers-reduced-motion:reduce)" onload="this.media=`screen`"><link rel="stylesheet" href="/css/post-ui.css"><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://bu.dusays.com/2025/06/16/684f747174bc3.webp"><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"><script async="" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="/" title="博客"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="博客"><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" href="/" title="后续项目..."><img class="back-menu-item-icon" src="https://image.anheyu.com/favicon.ico" alt="后续项目..."><span class="back-menu-item-text">后续项目...</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">格物致知</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)" rel="external nofollow noreferrer">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><span>文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size:.9em"></i><span> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size:.9em"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size:.9em"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><span>个人</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size:.9em"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size:.9em"></i><span> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/todolist/"><i class="fas fa-check-double faa-tada"></i><span> 代办清单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><span>预览</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?server=netease&amp;id=3117791189"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size:.9em"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size:.9em"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/messages/"><i class="fas fa-comments faa-tada"></i><span> 评论总览</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><span>关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size:.9em"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size:.9em"></i><span> 即刻短文</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size:.9em"></i><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="background-change-button"><a class="site-page" onclick="toggleWinbox()" title="切换背景" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-palette"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" rel="external nofollow noreferrer" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole()"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://tc.z.wiki/autoupload/iXoPwUD80CPTvQUyITTBFOykMT9FcWW5SasRoXZEs3Wyl5f0KlZfm6UsKj-HyTuv/20250609/bYMH/418X445/ef9a3f68-d36a-441a-95fe-8179b1a25992.png" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://tc.z.wiki/autoupload/iXoPwUD80CPTvQUyITTBFOykMT9FcWW5SasRoXZEs3Wyl5f0KlZfm6UsKj-HyTuv/20250609/bYMH/418X445/ef9a3f68-d36a-441a-95fe-8179b1a25992.png"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://tc.z.wiki/autoupload/iXoPwUD80CPTvQUyITTBFOykMT9FcWW5SasRoXZEs3Wyl5f0KlZfm6UsKj-HyTuv/20250609/cYu3/347X390/zfb.png" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://tc.z.wiki/autoupload/iXoPwUD80CPTvQUyITTBFOykMT9FcWW5SasRoXZEs3Wyl5f0KlZfm6UsKj-HyTuv/20250609/cYu3/347X390/zfb.png"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title">最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">音乐</div><span class="author-content-item-title">灵魂的碰撞💥</span></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/07/"><span class="card-archive-list-date">七月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/06/"><span class="card-archive-list-date">六月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">14</span><span>篇</span></div></a></li></ul></div></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);" rel="external nofollow noreferrer"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/" itemprop="url">后端技术</a><i class="anzhiyufont anzhiyu-icon-angle-right post-meta-separator"></i><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Python/" itemprop="url">Python</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/Python-%E8%AF%AD%E6%B3%95%E7%AF%87/" tabindex="-1" itemprop="url"> <span><i class="anzhiyufont anzhiyu-icon-hashtag"></i>Python-语法篇</span></a></span></div></div><h1 class="post-title" itemprop="name headline">Python语法前篇（十五）：第十四章：深入解析并发编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2025-07-01T08:13:45.000Z" title="发表于 2025-07-01 16:13:45">2025-07-01</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-06-17T09:51:07.160Z" title="更新于 2025-06-17 17:51:07">2025-06-17</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span data-flag-title="Python语法前篇（十五）：第十四章：深入解析并发编程"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="twikoo_visitors" title="访问量"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator"> </span><span class="post-meta-position" title="作者IP属地为广东"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>广东</span><span class="post-meta-separator"></span><span class="post-meta-commentcount"><i class="anzhiyufont anzhiyu-icon-comments post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2025/07/01/python%E8%AF%AD%E6%B3%95%E5%89%8D%E7%AF%87%E5%8D%81%E4%BA%94%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/#post-comment" tabindex="-1"><span id="twikoo-count"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></a></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://bu.dusays.com/2025/06/17/685113b7c39b1.webp"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope="" itemtype="https://prorise-cool.github.io/2025/07/01/python%E8%AF%AD%E6%B3%95%E5%89%8D%E7%AF%87%E5%8D%81%E4%BA%94%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"><header><a class="post-meta-categories" href="/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/" itemprop="url">后端技术</a><a class="post-meta-categories" href="/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Python/" itemprop="url">Python</a><a href="/tags/Python-%E8%AF%AD%E6%B3%95%E7%AF%87/" tabindex="-1" itemprop="url">Python-语法篇</a><h1 id="CrawlerTitle" itemprop="name headline">Python语法前篇（十五）：第十四章：深入解析并发编程</h1><span itemprop="author" itemscope="" itemtype="http://schema.org/Person">Prorise</span><time itemprop="dateCreated datePublished" datetime="2025-07-01T08:13:45.000Z" title="发表于 2025-07-01 16:13:45">2025-07-01</time><time itemprop="dateCreated datePublished" datetime="2025-06-17T09:51:07.160Z" title="更新于 2025-06-17 17:51:07">2025-06-17</time></header><div id="postchat_postcontent"><h2 id="第十四章：深入解析并发编程"><a href="#第十四章：深入解析并发编程" class="headerlink" title="第十四章：深入解析并发编程"></a>第十四章：深入解析并发编程</h2><h3 id="14-并发编程基本概念"><a href="#14-并发编程基本概念" class="headerlink" title="14. 并发编程基本概念"></a>14. 并发编程基本概念</h3><p>并发编程是指程序设计中允许多个任务同时执行的编程模式，它的核心目标是 <strong>提升执行效率</strong>。通过并发编程，原本需要 20 分钟执行的代码可能只需要 1 分钟就能完成。</p><h4 id="进程调度机制解析"><a href="#进程调度机制解析" class="headerlink" title="进程调度机制解析"></a>进程调度机制解析</h4><p>CPU 在执行程序时会涉及进程调度，主要有两种切换情况：</p><ol><li><strong>I/O 操作触发切换</strong>：当程序遇到 I/O 操作时，操作系统会剥夺该程序对 CPU 的执行权限</li><li><strong>时间片用尽触发切换</strong>：当一个程序长时间占用 CPU 时，操作系统也会剥夺程序对 CPU 的执行权限</li></ol><p>所谓 I/O 操作，指的为 <code>阻断</code> 程序的操作，类似于 <code>input()</code> 函数会将程序暂停运行，达到某一个条件后才会接触阻塞状态</p><p>时间片即 CPU 分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片，即该进程允许运行的时间，使各个程序从表面上看是同时进行的。如果在时间片结束时进程还在运行，则 CPU 将被剥夺并分配给另一个进程。如果进程在时间片结束前阻塞或结束，则 CPU 当即进行切换。而不会造成 CPU 资源浪费。</p><p>在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。</p><p>但在微观上：由于只有一个 CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。</p><h4 id="进程的三大状态与生命周期"><a href="#进程的三大状态与生命周期" class="headerlink" title="进程的三大状态与生命周期"></a>进程的三大状态与生命周期</h4><p>进程在其生命周期中会经历三种基本状态：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/assets/image-20250426212152903.png" alt="image-20250426212152903"></p><p>首先一个程序想要被运行，当用户双击图标后，此时程序就会从硬盘加载到内存，所有的程序想要被执行就必须经历就绪态，然后等待 CPU 执行，就绪态之后会进入进程调度，然后运行</p><p>运行时会出现以下几种情况：</p><blockquote><ul><li>1.时间片运行完毕，程序也执行完毕，释放资源后退出</li><li>2.程序运行过程遇到 I/O 操作（读写、发送网络请求）它是不需要 CPU 工作的，只要运行遇到了 I/O，操作系统就会把 CPU 拿走，执行其他的时间片，程序就会进入阻塞态，当 IO 请求完成后它就会结束阻塞态，回到就绪态里排队</li></ul></blockquote><h3 id="14-1-同步与异步编程模型"><a href="#14-1-同步与异步编程模型" class="headerlink" title="14.1 同步与异步编程模型"></a>14.1 同步与异步编程模型</h3><h4 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h4><p>同步：任务提交之后，原地等待任务的返回结果，等待的过程中不做任何事情</p><p>异步：任务提交之后，不再等待任务的返回结果，而是去做一些其他的事情</p><p>这两个概念主要 <strong>描述任务的提交方式</strong>：</p><blockquote><p>📝 <strong>实际应用</strong>：在 Web 开发中，同步请求会阻塞页面渲染，而异步请求（AJAX）则可以在后台处理数据，不影响用户体验。</p></blockquote><h4 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h4><p>这两个概念主要 <strong>描述进程的运行状态</strong>：</p><ul><li><strong>阻塞</strong>：对应进程的阻塞态</li><li><strong>非阻塞</strong>：对应进程的就绪态、运行态</li></ul><p>结合同步/异步和阻塞/非阻塞，可以形成四种组合：</p><ul><li>同步阻塞</li><li>同步非阻塞</li><li>异步阻塞</li><li><strong>异步非阻塞</strong>（CPU 利用率最高的一种模式）</li></ul><blockquote><p>🔍 在实际开发中，异步非阻塞模式是高并发系统的首选模式，因为它允许程序在等待 I/O 操作时继续执行其他任务。</p></blockquote><hr><h3 id="14-2-多进程编程技术"><a href="#14-2-多进程编程技术" class="headerlink" title="14.2 多进程编程技术"></a>14.2 多进程编程技术</h3><h4 id="进程基础"><a href="#进程基础" class="headerlink" title="进程基础"></a>进程基础</h4><p><strong>进程</strong> 是程序在计算机中的一次执行过程：</p><ul><li><strong>程序</strong> 是静态的可执行文件，占用磁盘空间</li><li><strong>进程</strong> 是动态的执行过程，占用计算机运行资源</li></ul><p>类比：一个工厂有三个车间，每个车间一个工人（共 3 人），并行处理任务，相当于一个程序创建三个进程，每个进程一个线程（共 3 人），并行处理任务。</p><h4 id="进程创建方法"><a href="#进程创建方法" class="headerlink" title="进程创建方法"></a>进程创建方法</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line">Process(target,name,args,kwargs)</span><br><span class="line"><span class="string">''''''</span><span class="string">''''''</span><span class="string">'''''</span></span><br><span class="line"><span class="string">功能 ： 创建进程对象</span></span><br><span class="line"><span class="string">参数 ：  </span></span><br><span class="line"><span class="string">	  target 绑定要执行的目标函数 </span></span><br><span class="line"><span class="string">   	  name 进程名，默认是Process-x(整数)</span></span><br><span class="line"><span class="string">	  args 元组，用于给target函数位置传参</span></span><br><span class="line"><span class="string">	  kwargs 字典，给target函数键值传参</span></span><br><span class="line"><span class="string">'''</span><span class="string">''''''</span><span class="string">''''''</span><span class="string">''''</span></span><br></pre></td></tr></tbody></table></figure><h5 id="方法一：使用-Process-类创建进程"><a href="#方法一：使用-Process-类创建进程" class="headerlink" title="方法一：使用 Process 类创建进程"></a>方法一：使用 Process 类创建进程</h5><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建进程的标准方法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">worker_function</span>(<span class="params">name, age</span>):</span><br><span class="line">    <span class="string">"""子进程执行过程中触发的函数"""</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"子进程ID:<span class="subst">{os.getpid()}</span>,父进程ID<span class="subst">{os.getppid()}</span>"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"子进程正在执行，参数name=<span class="subst">{name}</span>,age=<span class="subst">{age}</span>"</span>)</span><br><span class="line">    <span class="comment"># 模拟耗时操作</span></span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"子进程<span class="subst">{name}</span>执行完毕"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cpu_intensive_task</span>(<span class="params">number</span>):</span><br><span class="line">    <span class="string">"""CPU密集型任务"""</span></span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(number):</span><br><span class="line">        result += i * i</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"进程<span class="subst">{os.getpid()}</span> 计算完成，结果为<span class="subst">{result}</span>"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"父进程ID:<span class="subst">{os.getpid()}</span>"</span>)</span><br><span class="line">    start_time = time.time()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建多个进程，体现并行处理能力</span></span><br><span class="line">    processes = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建四个检测执行不同人物</span></span><br><span class="line">    p1 = Process(target=worker_function, args=(<span class="string">"张三"</span>,), kwargs={<span class="string">"age"</span>: <span class="number">20</span>})</span><br><span class="line">    p2 = Process(target=worker_function, args=(<span class="string">"李四"</span>,), kwargs={<span class="string">"age"</span>: <span class="number">30</span>})</span><br><span class="line">    p3 = Process(target=cpu_intensive_task, args=(<span class="number">10000</span>,))</span><br><span class="line">    p4 = Process(target=cpu_intensive_task, args=(<span class="number">20000</span>,))</span><br><span class="line"></span><br><span class="line">    processes.extend([p1, p2, p3, p4]) <span class="comment"># 将进程添加到列表中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> processes:</span><br><span class="line">        p.start() <span class="comment"># 启动进程</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待所有进程结束</span></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> processes:</span><br><span class="line">        p.join()</span><br><span class="line"></span><br><span class="line">    end_time = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"所有进程执行完毕，总耗时<span class="subst">{end_time - start_time:<span class="number">.2</span>f}</span>秒"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"如果使用单进程顺序执行，耗时会更长，因为是两个任务在执行，多进程可以充分利用多核CPU并行处理任务"</span>)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><blockquote><p>⚠️ <strong>重要提示</strong>：在 Windows 系统中，必须在 <code>if __name__ == '__main__'</code> 条件下创建进程，这是因为 Windows 使用 spawn 方式创建进程，会重新导入模块，可能导致递归创建进程。</p></blockquote><h5 id="方法二：继承-Process-类创建进程"><a href="#方法二：继承-Process-类创建进程" class="headerlink" title="方法二：继承 Process 类创建进程"></a>方法二：继承 Process 类创建进程</h5><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过继承Process类创建进程</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkerProcess</span>(<span class="title class_ inherited__">Process</span>):</span><br><span class="line">    <span class="string">"""继承Process类的自定义进程"""</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="variable language_">self</span>.age = age</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">"""重写run方法，进程启动后会执行该方法"""</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f"子进程ID:<span class="subst">{os.getpid()}</span>,父进程ID<span class="subst">{os.getppid()}</span>"</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f"子进程正在执行，参数name=<span class="subst">{self.name}</span>,age=<span class="subst">{self.age}</span>"</span>)</span><br><span class="line">        <span class="comment"># 模拟耗时操作</span></span><br><span class="line">        time.sleep(<span class="number">5</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f"子进程<span class="subst">{self.name}</span>执行完毕"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPUIntensiveProcess</span>(<span class="title class_ inherited__">Process</span>):</span><br><span class="line">    <span class="string">"""CPU密集型任务进程"""</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, number</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="variable language_">self</span>.number = number</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">"""重写run方法，执行CPU密集型计算"""</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="variable language_">self</span>.number):</span><br><span class="line">            result += i * i</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f"进程<span class="subst">{os.getpid()}</span> 计算完成，结果为<span class="subst">{result}</span>"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"父进程ID:<span class="subst">{os.getpid()}</span>"</span>)</span><br><span class="line">    start_time = time.time()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建多个进程，体现并行处理能力</span></span><br><span class="line">    processes = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建四个进程实例</span></span><br><span class="line">    p1 = WorkerProcess(<span class="string">"张三"</span>, <span class="number">20</span>)</span><br><span class="line">    p2 = WorkerProcess(<span class="string">"李四"</span>, <span class="number">30</span>)</span><br><span class="line">    p3 = CPUIntensiveProcess(<span class="number">10000</span>)</span><br><span class="line">    p4 = CPUIntensiveProcess(<span class="number">20000</span>)</span><br><span class="line"></span><br><span class="line">    processes.extend([p1, p2, p3, p4]) <span class="comment"># 将进程添加到列表中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> processes:</span><br><span class="line">        p.start() <span class="comment"># 启动进程</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待所有进程结束</span></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> processes:</span><br><span class="line">        p.join()</span><br><span class="line"></span><br><span class="line">    end_time = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"所有进程执行完毕，总耗时<span class="subst">{end_time - start_time:<span class="number">.2</span>f}</span>秒"</span>)</span><br></pre></td></tr></tbody></table></figure><h4 id="多进程常用方法表"><a href="#多进程常用方法表" class="headerlink" title="多进程常用方法表"></a>多进程常用方法表</h4><table><thead><tr><th>方法名</th><th>说明</th><th>实际应用场景</th></tr></thead><tbody><tr><td><code>Process(target=...)</code></td><td>创建进程对象</td><td>指定新进程要执行的函数</td></tr><tr><td><code>start()</code></td><td>启动进程</td><td>开始执行进程的任务</td></tr><tr><td><code>join()</code></td><td>等待进程结束</td><td>协调多个进程的执行顺序</td></tr><tr><td><code>is_alive()</code></td><td>检查进程是否存活</td><td>监控进程状态</td></tr><tr><td><code>terminate()</code></td><td>强制终止进程</td><td>中断异常或超时的进程</td></tr><tr><td><code>Queue()</code></td><td>创建进程安全的队列</td><td>进程间数据传递</td></tr><tr><td><code>put(item)</code></td><td>添加元素到队列</td><td>向队列中放入数据</td></tr><tr><td><code>get()</code></td><td>从队列获取元素</td><td>从队列获取数据</td></tr><tr><td><code>Pipe()</code></td><td>创建管道对象</td><td>进程间双向通信</td></tr></tbody></table><h4 id="进程号与进程信息获取"><a href="#进程号与进程信息获取" class="headerlink" title="进程号与进程信息获取"></a>进程号与进程信息获取</h4><p>在多进程编程中，获取进程信息对于调试和管理至关重要。Python 的 <code>multiprocessing</code> 模块提供了 <code>current_process()</code> 方法来获取当前进程的信息。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_info</span>():</span><br><span class="line">    <span class="string">"""打印当前进程的信息"""</span></span><br><span class="line">    <span class="comment"># 获取当前进程对象</span></span><br><span class="line">    process = multiprocessing.current_process()</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"进程名称: <span class="subst">{process.name}</span>"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"进程ID: <span class="subst">{process.pid}</span>"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"父进程ID: <span class="subst">{os.getppid()}</span>"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"进程授权键: <span class="subst">{process.authkey}</span>"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"进程是否活跃: <span class="subst">{process.is_alive()}</span>"</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p = multiprocessing.Process(target=process_info, name=<span class="string">"自定义进程名"</span>)</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br></pre></td></tr></tbody></table></figure><h4 id="进程间通信示例"><a href="#进程间通信示例" class="headerlink" title="进程间通信示例"></a>进程间通信示例</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process,Queue</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment">## 子进程执行的函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">worker</span>(<span class="params">q</span>):</span><br><span class="line">    <span class="string">"""子进程函数，想往父进程发送消息，就往这个队列里放"""</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"子进程启动"</span>)</span><br><span class="line">    <span class="comment"># 向队列中添加数据</span></span><br><span class="line">    q.put(<span class="string">"我是一个队列数据"</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>) <span class="comment"># 模拟任务执行</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"子进程结束"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    q = Queue() <span class="comment"># 父进程创建队列</span></span><br><span class="line">    <span class="comment"># 创建一个子进程对象</span></span><br><span class="line">    p = Process(target=worker, args=(q,))</span><br><span class="line">    <span class="comment"># 启动子进程</span></span><br><span class="line">    p.start()</span><br><span class="line">    <span class="comment"># 主进程从队列中获取数据</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"主进程等待子进程数据...."</span>)</span><br><span class="line">    message = q.get() <span class="comment"># 阻塞等待数据</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"主进程收到来自于子进程的消息：<span class="subst">{message}</span>"</span>)</span><br><span class="line">    <span class="comment"># 等待子进程结束</span></span><br><span class="line">    p.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"主进程结束"</span>)</span><br></pre></td></tr></tbody></table></figure><h4 id="复杂进程通信示例"><a href="#复杂进程通信示例" class="headerlink" title="复杂进程通信示例"></a>复杂进程通信示例</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue, Lock, Value, Array</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 子进程执行的函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">worker_with_args</span>(<span class="params">q, lock, value, arr, sleep_num</span>):</span><br><span class="line">    <span class="string">"""带有共享资源的工作函数</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        q: 队列</span></span><br><span class="line"><span class="string">        lock: 锁</span></span><br><span class="line"><span class="string">        value: 值</span></span><br><span class="line"><span class="string">        arr: 数组</span></span><br><span class="line"><span class="string">        sleep_num: 休眠时间</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 获取进程id</span></span><br><span class="line">    pid = os.getpid()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"进程<span class="subst">{pid}</span>开始执行"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用锁来保证数据安全</span></span><br><span class="line">    <span class="keyword">with</span> lock:  <span class="comment"># 相当于lock.acquire()和lock.release()的组合</span></span><br><span class="line">        value.value += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)):</span><br><span class="line">            arr[i] **= <span class="number">2</span>  <span class="comment"># 安全的修改数组元素</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f"进程<span class="subst">{pid}</span>修改数组元素<span class="subst">{i}</span>为<span class="subst">{arr[i]}</span>"</span>)</span><br><span class="line">    <span class="comment"># 向队列中添加数据</span></span><br><span class="line">    q.put(<span class="string">f"这是一条来自于进程<span class="subst">{pid}</span>的信息"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 休眠模拟工作</span></span><br><span class="line">    time.sleep(sleep_num)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"进程<span class="subst">{pid}</span>执行完毕"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    解释输出逻辑:</span></span><br><span class="line"><span class="string">    1. 创建了4个进程，它们共享同一个数组arr，初始值为[1,2,3,4,5]</span></span><br><span class="line"><span class="string">    2. 每个进程获取锁后，会将数组中的每个元素进行平方操作(arr[i] **= 2)</span></span><br><span class="line"><span class="string">    3. 由于进程是按顺序启动的，但执行顺序不确定，所以:</span></span><br><span class="line"><span class="string">       - 第一个获得锁的进程将[1,2,3,4,5]平方为[1,4,9,16,25]</span></span><br><span class="line"><span class="string">       - 第二个获得锁的进程将[1,4,9,16,25]平方为[1,16,81,256,625]</span></span><br><span class="line"><span class="string">       - 第三个获得锁的进程将[1,16,81,256,625]平方为[1,256,6561,65536,390625]</span></span><br><span class="line"><span class="string">       - 第四个获得锁的进程将[1,256,6561,65536,390625]平方，但由于整数溢出，</span></span><br><span class="line"><span class="string">         导致最后两个元素变成了0和负数</span></span><br><span class="line"><span class="string">    4. 进程完成的顺序取决于sleep_num参数(1,2,3,4)，所以最先完成的是第一个进程</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 创建队列</span></span><br><span class="line">    q = Queue()</span><br><span class="line">    <span class="comment"># 创建锁</span></span><br><span class="line">    lock = Lock()</span><br><span class="line">    <span class="comment"># 创建一个共享值</span></span><br><span class="line">    value = Value(<span class="string">"i"</span>, <span class="number">0</span>)  <span class="comment"># "i"表示int类型</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建一个共享数组</span></span><br><span class="line">    arr = Array(<span class="string">"i"</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建多个子进程</span></span><br><span class="line">    processes = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        p = Process(target=worker_with_args, args=(q, lock, value, arr, i + <span class="number">1</span>))</span><br><span class="line">        p.start()</span><br><span class="line">        processes.extend([p])</span><br></pre></td></tr></tbody></table></figure><h4 id="进程池详解"><a href="#进程池详解" class="headerlink" title="进程池详解"></a>进程池详解</h4><p>进程池是一种管理多个进程的方式，可以简化并行计算的编程。Python 的 <code>multiprocessing</code> 模块中的 <code>Pool</code> 类和 <code>concurrent.futures</code> 模块的 <code>ProcessPoolExecutor</code> 类都提供了进程池功能。</p><h5 id="进程池的主要方法"><a href="#进程池的主要方法" class="headerlink" title="进程池的主要方法"></a>进程池的主要方法</h5><table><thead><tr><th>方法</th><th>描述</th><th>使用场景</th></tr></thead><tbody><tr><td><code>Pool(processes=None)</code></td><td>创建进程池，进程数默认为 CPU 核数</td><td>初始化进程池</td></tr><tr><td><code>apply(func, args)</code></td><td>阻塞执行任务</td><td>需要顺序执行且等待结果的场景</td></tr><tr><td><code>apply_async(func, args)</code></td><td>非阻塞执行任务</td><td>需要异步执行的场景</td></tr><tr><td><code>map(func, iterable)</code></td><td>并行执行映射任务</td><td>对列表元素并行处理</td></tr><tr><td><code>close()</code></td><td>关闭进程池，不再接受新任务</td><td>完成任务提交后</td></tr><tr><td><code>terminate()</code></td><td>立即终止所有工作进程</td><td>需要强制停止时</td></tr><tr><td><code>join()</code></td><td>等待所有工作进程退出</td><td>在 close()后使用</td></tr></tbody></table><h5 id="ProcessPoolExecutor-示例"><a href="#ProcessPoolExecutor-示例" class="headerlink" title="ProcessPoolExecutor 示例"></a>ProcessPoolExecutor 示例</h5><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ProcessPoolExecutor</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">worker_function</span>(<span class="params">name,age</span>):</span><br><span class="line">    <span class="string">"""进程池工作函数"""</span></span><br><span class="line">    pid = os.getpid()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"进程<span class="subst">{pid}</span>：<span class="subst">{name}</span>，<span class="subst">{age}</span>岁"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f"我的父进程是<span class="subst">{os.getppid()}</span> 我结束进程了"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">with</span> ProcessPoolExecutor(max_workers=<span class="number">4</span>) <span class="keyword">as</span> executor:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">            <span class="comment"># submit方法提交任务到进程池，返回一个Future对象</span></span><br><span class="line">            <span class="comment"># submit参数: function, *args, **kwargs</span></span><br><span class="line">            <span class="comment"># 这里的i作为worker_function函数的第二个参数age传入</span></span><br><span class="line">            future = executor.submit(worker_function, <span class="string">f"小明<span class="subst">{i}</span>"</span>, i)</span><br><span class="line">            <span class="comment"># 等待future对象返回结果</span></span><br><span class="line">            result = future.result()</span><br><span class="line">            <span class="built_in">print</span>(result)</span><br></pre></td></tr></tbody></table></figure><p>Pool 对象示例</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">worker_function</span>(<span class="params">args</span>):</span><br><span class="line">    <span class="string">"""工作进程函数"""</span></span><br><span class="line">    name,age = args</span><br><span class="line">    pid = os.getpid()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"进程<span class="subst">{pid}</span>：<span class="subst">{name}</span>，<span class="subst">{age}</span>岁"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f"我的父进程是<span class="subst">{os.getppid()}</span> 我结束进程了"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">with</span> Pool() <span class="keyword">as</span> pool:</span><br><span class="line">        <span class="comment"># 准备参数列表</span></span><br><span class="line">        args_list = [(<span class="string">f"张三<span class="subst">{i}</span>号"</span>, i+<span class="number">18</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>)]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># map方法将函数应用于参数列表，并返回结果列表</span></span><br><span class="line">        <span class="comment"># pool.map 的工作原理:</span></span><br><span class="line">        <span class="comment"># 1. 它接收两个参数：要执行的函数(worker_function)和可迭代的参数列表(args_list)</span></span><br><span class="line">        <span class="comment"># 2. 它会自动将参数列表中的每个元素分配给不同的进程来执行</span></span><br><span class="line">        <span class="comment"># 3. 每个进程会调用worker_function并传入args_list中的一个元素作为参数</span></span><br><span class="line">        <span class="comment"># 4. 所有进程执行完毕后，map会收集所有进程的返回值，并按原始参数的顺序返回结果列表</span></span><br><span class="line">        <span class="comment"># 5. 这样实现了并行处理，提高了计算效率</span></span><br><span class="line">        result_list = pool.<span class="built_in">map</span>(worker_function, args_list)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 打印每个进程的返回结果</span></span><br><span class="line">        <span class="keyword">for</span> result <span class="keyword">in</span> result_list:</span><br><span class="line">            <span class="built_in">print</span>(result)</span><br></pre></td></tr></tbody></table></figure><h4 id="进程号与进程信息获取-1"><a href="#进程号与进程信息获取-1" class="headerlink" title="进程号与进程信息获取"></a>进程号与进程信息获取</h4><p>在多进程编程中，获取进程信息对于调试和管理至关重要。Python 的 <code>multiprocessing</code> 模块提供了 <code>current_process()</code> 方法来获取当前进程的信息。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_info</span>():</span><br><span class="line">    <span class="string">"""打印当前进程的信息"""</span></span><br><span class="line">    <span class="comment"># 获取当前进程对象</span></span><br><span class="line">    process = multiprocessing.current_process()</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"进程名称: <span class="subst">{process.name}</span>"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"进程ID: <span class="subst">{process.pid}</span>"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"父进程ID: <span class="subst">{os.getppid()}</span>"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"进程授权键: <span class="subst">{process.authkey}</span>"</span>) <span class="comment"># 授权键用于在进程间通信时进行身份验证。</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"进程是否活跃: <span class="subst">{process.is_alive()}</span>"</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p = multiprocessing.Process(target=process_info, name=<span class="string">"自定义进程名"</span>)</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br></pre></td></tr></tbody></table></figure><h5 id="进程状态特殊情况"><a href="#进程状态特殊情况" class="headerlink" title="进程状态特殊情况"></a>进程状态特殊情况</h5><h6 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h6><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">子进程死后还会有一些资源占用(进程号，进程的运行状态，运行时间)，等待父进程通过系统调用</span></span><br><span class="line"><span class="string">进行资源回收</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">相当于子进程死了之后，需要父进程来给他"收尸"</span></span><br><span class="line"><span class="string">除了init进程之外，所有的进程最后都会步入僵尸进程</span></span><br><span class="line"><span class="string">在一种情况下是会带来危害的:</span></span><br><span class="line"><span class="string">子进程退出之后，父进程没有及时处理，僵尸进程就会一直占用资源</span></span><br><span class="line"><span class="string">如果产生了大量僵尸进程，资源过度使用，系统没有可用的进程号，导致系统不能产生新的进程</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>注意：在 Windows 中，子进程退出后会立即被系统回收，不会产生真正的僵尸进程，在 Windows 系统中，不需要显式调用 wait 来回收子进程资源</p></blockquote><h6 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h6><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">子进程处于存活状态，父进程意外死亡，操作系统就会开设一个孤儿院（init进程），用来管理</span></span><br><span class="line"><span class="string">孤儿进程，回收孤儿进程相关资源</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>📝 <strong>知识点</strong>：操作系统会自动处理孤儿进程，将它们的父进程更改为 init 进程（PID 为 1），所以孤儿进程不会造成资源泄漏问题。</p></blockquote><h3 id="14-3-多线程编程深入解析"><a href="#14-3-多线程编程深入解析" class="headerlink" title="14.3 多线程编程深入解析"></a>14.3 多线程编程深入解析</h3><h4 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h4><p><strong>线程</strong> 是轻量级的进程，也是多任务编程的一种方式：</p><ul><li>一个进程中可以包含多个线程</li><li>线程也是一个运行行为，消耗计算机资源</li><li>一个进程中的所有线程共享这个进程的资源</li><li>线程的创建和销毁消耗资源远小于进程</li></ul><p>一个工厂至少有一个车间，一个车间中至少有一个工人，工人去利用车间的设备工作；</p><p>一个程序至少有一个进程，一个进程中至少有一个线程，线程去利用进程的资源工作。</p><h4 id="线程创建方法"><a href="#线程创建方法" class="headerlink" title="线程创建方法"></a>线程创建方法</h4><h5 id="方法一：使用-Thread-类创建线程"><a href="#方法一：使用-Thread-类创建线程" class="headerlink" title="方法一：使用 Thread 类创建线程"></a>方法一：使用 Thread 类创建线程</h5><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">worker_function</span>(<span class="params">name,delay</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"线程<span class="subst">{name}</span>开始工作"</span>)</span><br><span class="line">    time.sleep(delay)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"线程<span class="subst">{name}</span>结束工作"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    t1 = Thread(target=worker_function,args=(<span class="string">"线程1"</span>,<span class="number">2</span>))</span><br><span class="line">    t2 = Thread(target=worker_function,args=(<span class="string">"线程2"</span>,<span class="number">4</span>))</span><br><span class="line">    <span class="comment"># 启动线程</span></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    <span class="comment"># 等待线程结束</span></span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"主线程结束"</span>)</span><br></pre></td></tr></tbody></table></figure><h5 id="方法二：继承-Thread-类创建线程"><a href="#方法二：继承-Thread-类创建线程" class="headerlink" title="方法二：继承 Thread 类创建线程"></a>方法二：继承 Thread 类创建线程</h5><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span>(<span class="title class_ inherited__">Thread</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,message</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="variable language_">self</span>.message = message</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f"线程<span class="subst">{self.name}</span>开始执行"</span>)</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f"线程<span class="subst">{self.name}</span>执行完毕，消息：<span class="subst">{self.message}</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    t1 = MyThread(name=<span class="string">"线程1"</span>,message=<span class="string">"子进程操作完毕"</span>)</span><br><span class="line">    t2 = MyThread(name=<span class="string">"线程2"</span>,message=<span class="string">"子进程操作完毕"</span>)</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"主进程执行完毕"</span>)</span><br></pre></td></tr></tbody></table></figure><h4 id="线程常用方法表"><a href="#线程常用方法表" class="headerlink" title="线程常用方法表"></a>线程常用方法表</h4><table><thead><tr><th>方法名</th><th>说明</th><th>实际应用场景</th></tr></thead><tbody><tr><td><code>start()</code></td><td>启动线程</td><td>开始执行线程任务</td></tr><tr><td><code>run()</code></td><td>定义线程执行的任务</td><td>重写该方法自定义线程行为</td></tr><tr><td><code>join()</code></td><td>等待线程结束</td><td>协调线程执行顺序</td></tr><tr><td><code>join(timeout)</code></td><td>等待线程结束，有超时时间</td><td>防止无限等待</td></tr><tr><td><code>is_alive()</code></td><td>检查线程是否活动</td><td>监控线程状态</td></tr><tr><td><code>getName()</code></td><td>获取线程名称</td><td>调试和日志记录</td></tr><tr><td><code>setName(name)</code></td><td>设置线程名称</td><td>便于识别不同线程</td></tr><tr><td><code>setDaemon(T/F)</code></td><td>设置为守护线程</td><td>随主线程结束而结束的后台任务</td></tr><tr><td><code>isDaemon()</code></td><td>检查是否为守护线程</td><td>确认线程类型</td></tr><tr><td><code>getId()</code></td><td>获取线程 ID</td><td>唯一标识线程</td></tr><tr><td><code>current_thread</code></td><td>获取当前线程对象</td><td>在函数中获取当前执行线程</td></tr></tbody></table><h4 id="线程使用实例"><a href="#线程使用实例" class="headerlink" title="线程使用实例"></a>线程使用实例</h4><h5 id="基本线程示例"><a href="#基本线程示例" class="headerlink" title="基本线程示例"></a>基本线程示例</h5><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">download_file</span>(<span class="params">url,session</span>):</span><br><span class="line">    <span class="string">"""访问网站下载文件"""</span></span><br><span class="line">    <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> response:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f"读取<span class="subst">{url}</span> 长度为<span class="subst">{<span class="built_in">len</span>(response.content)}</span>"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">download_all_sites</span>(<span class="params">urls</span>):</span><br><span class="line">    <span class="string">"""单线程下载所有网站"""</span></span><br><span class="line">    <span class="keyword">with</span> requests.Session() <span class="keyword">as</span> session:</span><br><span class="line">        <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">            download_file(url,session)</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">download_site_thread</span>(<span class="params">url,session</span>):</span><br><span class="line">    <span class="string">"""多线程下载网站"""</span></span><br><span class="line">    download_file(url,session)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">download_all_sites_thread</span>(<span class="params">urls</span>):</span><br><span class="line">    <span class="string">"""多线程下载所有网站"""</span></span><br><span class="line">    threads = []</span><br><span class="line">    <span class="keyword">with</span> requests.Session() <span class="keyword">as</span> session:</span><br><span class="line">        <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">            thread = Thread(target=download_site_thread, args=(url,session))</span><br><span class="line">            threads.append(thread)</span><br><span class="line">            thread.start()</span><br><span class="line">        <span class="comment"># 等待所有线程结束</span></span><br><span class="line">        <span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">            thread.join()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 准备一些网站用于演示</span></span><br><span class="line">    sites = [</span><br><span class="line">        <span class="string">"https://www.baidu.com"</span>,</span><br><span class="line">        <span class="string">"https://www.sina.com.cn"</span>,</span><br><span class="line">        <span class="string">"https://www.qq.com"</span>,</span><br><span class="line">        <span class="string">"https://www.163.com"</span>,</span><br><span class="line">        <span class="string">"https://www.sohu.com"</span>,</span><br><span class="line">    ]</span><br><span class="line">    <span class="comment"># 单线程下载</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"=======单线程下载开始========"</span>)</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    download_all_sites(sites)</span><br><span class="line">    end_time = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"单线程下载结束，耗时<span class="subst">{end_time-start_time}</span>秒"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\n=======多线程下载开始========"</span>)</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    download_all_sites_thread(sites)</span><br><span class="line">    end_time = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"多线程下载结束，耗时<span class="subst">{end_time-start_time}</span>秒"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\nIO密集型任务（如网络请求）适合使用多线程，可以显著提高性能"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"这是因为当一个线程等待IO操作完成时，其他线程可以继续执行"</span>)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h5 id="守护线程示例"><a href="#守护线程示例" class="headerlink" title="守护线程示例"></a>守护线程示例</h5><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">worker_function</span>(<span class="params">thread_name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"线程 <span class="subst">{thread_name}</span> 启动"</span>)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"线程 <span class="subst">{thread_name}</span> 结束"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    t1 = Thread(target=worker_function, args=(<span class="string">"Thread-1"</span>,))</span><br><span class="line">    t2 = Thread(target=worker_function, args=(<span class="string">"Thread-2"</span>,))</span><br><span class="line">    <span class="comment"># 设置t3为守护线程，主线程结束时，t3线程也会结束</span></span><br><span class="line">    t3 = Thread(target=worker_function, args=(<span class="string">"Thread-3"</span>,), daemon=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># t3.setDaemon(True) # 已经被废弃的API，现在使用daemon=True参数代替</span></span><br><span class="line">    <span class="comment"># 启动普通线程</span></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    <span class="comment"># 启动守护线程</span></span><br><span class="line">    t3.start()  <span class="comment"># 这里需要启动t3线程，否则t3不会执行</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待普通线程完成</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"等待线程<span class="subst">{t1.name}</span> + <span class="subst">{t2.name}</span>完成..."</span>)</span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 检测线程状态</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"线程<span class="subst">{t1.name}</span>是否存活：<span class="subst">{t1.is_alive()}</span>"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"线程<span class="subst">{t2.name}</span>是否存活：<span class="subst">{t2.is_alive()}</span>"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"线程<span class="subst">{t3.name}</span>是否存活：<span class="subst">{t3.is_alive()}</span>"</span>)  <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 主线程休眠一段时间，以便守护线程有机会执行</span></span><br><span class="line">    time.sleep(<span class="number">10</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"主线程结束"</span>)</span><br></pre></td></tr></tbody></table></figure><blockquote><p>💡 <strong>守护线程特性</strong>：守护线程会随着主线程的结束而结束，不管它是否执行完成。适用于需要在后台运行但不要求必须完成的任务，如监控、日志记录等。</p></blockquote><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> psutil</span><br><span class="line">logging.basicConfig(</span><br><span class="line">    level=logging.INFO,</span><br><span class="line">    <span class="built_in">format</span>=<span class="string">'%(asctime)s %(levelname)s %(message)s'</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">system_monitor</span>(<span class="params">interval=<span class="number">1</span></span>):</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    守护线程：系统资源监控器</span></span><br><span class="line"><span class="string">    持续监控CPU使用率和内存使用情况，并记录到日志中</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    logging.info(<span class="string">'系统监控守护线程启动'</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            cpu_usage = psutil.cpu_percent(interval=interval)</span><br><span class="line">            mem_usage = psutil.virtual_memory().percent</span><br><span class="line">            logging.info(<span class="string">f'CPU使用率：<span class="subst">{cpu_usage}</span>% 内存使用率：<span class="subst">{mem_usage}</span>%'</span>)</span><br><span class="line">            time.sleep(interval)</span><br><span class="line">            <span class="keyword">if</span> cpu_usage &gt; <span class="number">80</span> <span class="keyword">or</span> mem_usage &gt; <span class="number">80</span>:</span><br><span class="line">                logging.warning(<span class="string">'系统资源占用过高，请及时处理'</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logging.error(<span class="string">f'系统监控线程异常：<span class="subst">{e}</span>'</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        logging.info(<span class="string">'系统监控守护线程结束'</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 创建并启动系统监控守护线程</span></span><br><span class="line">    monitor_thread = Thread(target=system_monitor,args=(<span class="number">1</span>,),daemon=<span class="literal">True</span>,name=<span class="string">"MonitorThread"</span>)</span><br><span class="line">    monitor_thread.start()</span><br><span class="line">    <span class="comment"># 主线程继续执行一段时间，守护线程在后台运行</span></span><br><span class="line">    logging.info(<span class="string">"主线程运行中，监控守护线程在后台运行..."</span>)</span><br><span class="line">    time.sleep(<span class="number">30</span>)  <span class="comment"># 运行30秒后结束</span></span><br><span class="line">    <span class="comment"># 主线程结束，守护线程将自动终止</span></span><br><span class="line">    logging.info(<span class="string">f"监控守护线程是否存活: <span class="subst">{monitor_thread.is_alive()}</span>"</span>)</span><br><span class="line">    logging.info(<span class="string">"主线程结束，守护线程将自动终止"</span>)</span><br></pre></td></tr></tbody></table></figure><h4 id="线程池详解"><a href="#线程池详解" class="headerlink" title="线程池详解"></a>线程池详解</h4><p>线程池是一种管理线程资源的方式，它预先创建一定数量的线程，然后复用这些线程来执行任务，避免了频繁创建和销毁线程的开销。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个耗时函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">time_consuming_task</span>(<span class="params">n</span>):</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> n * n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">4</span>) <span class="keyword">as</span> executor:</span><br><span class="line">        <span class="comment"># 使用submit方法提交任务给线程池执行，返回Future对象列表</span></span><br><span class="line">        futures = [executor.submit(time_consuming_task, i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">21</span>)]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"任务已提交，主线程继续执行........."</span>)</span><br><span class="line">        <span class="comment"># 等待所有任务完成，并获取结果</span></span><br><span class="line">        results = [future.result() <span class="keyword">for</span> future <span class="keyword">in</span> futures]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f"任务执行完毕，结果为：<span class="subst">{results}</span>"</span>)</span><br><span class="line">    end_time = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"总共耗时：<span class="subst">{end_time - start_time}</span>秒"</span>)</span><br><span class="line">    <span class="comment">### 线程池在with语句结束时自动关闭</span></span><br></pre></td></tr></tbody></table></figure><h5 id="ThreadPoolExecutor-主要方法"><a href="#ThreadPoolExecutor-主要方法" class="headerlink" title="ThreadPoolExecutor 主要方法"></a>ThreadPoolExecutor 主要方法</h5><table><thead><tr><th>方法名</th><th>简洁解释</th><th>适用场景</th></tr></thead><tbody><tr><td><code>submit(fn, *args)</code></td><td>异步执行函数，返回 Future 对象</td><td>单独提交任务并获取结果</td></tr><tr><td><code>map(func, *iterables)</code></td><td>对每个输入并行执行函数</td><td>批量处理类似任务</td></tr><tr><td><code>shutdown(wait=True)</code></td><td>关闭执行器</td><td>资源释放</td></tr><tr><td><code>result()</code></td><td>获取任务执行结果</td><td>获取异步任务的返回值</td></tr><tr><td><code>add_done_callback(fn)</code></td><td>添加任务完成回调函数</td><td>任务完成后的后续处理</td></tr><tr><td><code>as_completed()</code></td><td>返回已完成任务的迭代器</td><td>先处理先完成的任务</td></tr><tr><td><code>wait()</code></td><td>等待任务完成</td><td>任务同步点</td></tr></tbody></table><blockquote><p>🔍 <strong>深入理解</strong>：线程池最大的好处是控制并发数量，防止系统资源被耗尽。在实际开发中，建议将线程数设置为 CPU 核心数的 1-5 倍，具体取决于任务是 I/O 密集型还是 CPU 密集型。</p></blockquote><h5 id="完整示例"><a href="#完整示例" class="headerlink" title="完整示例"></a>完整示例</h5><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor,as_completed,wait</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">time_consuming_task</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="string">"""耗时任务"""</span></span><br><span class="line">    time.sleep(n % <span class="number">3</span> +<span class="number">1</span>) <span class="comment"># 不同的n值，耗时不同</span></span><br><span class="line">    <span class="keyword">return</span> n * n</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task_done_callback</span>(<span class="params">future</span>):</span><br><span class="line">    <span class="string">"""任务完成后触发的回调函数"""</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"任务完成，结果为<span class="subst">{future.result()}</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"===== 1. submit方法示例 ====="</span>)</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">3</span>) <span class="keyword">as</span> executor:</span><br><span class="line">        future_list = [executor.submit(time_consuming_task, i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"提交任务完成，等待结果..."</span>)</span><br><span class="line">        <span class="comment"># result()：获取任务执行结果，会阻塞直到所有任务完成</span></span><br><span class="line">        <span class="comment"># as_completed(): 返回已完成任务的迭代器</span></span><br><span class="line">        <span class="keyword">for</span> future <span class="keyword">in</span> as_completed(future_list):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f"任务<span class="subst">{future.result()}</span>完成"</span>)</span><br><span class="line">    end_time = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"总耗时：<span class="subst">{end_time - start_time}</span>秒"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\n===== 2. map方法示例 ====="</span>)</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">4</span>) <span class="keyword">as</span> executor:</span><br><span class="line">        <span class="comment"># map()：对每一个输入并行执行函数，返回结果迭代器</span></span><br><span class="line">        <span class="comment"># 与submit不同，map会自动收集结果并按输入顺序返回</span></span><br><span class="line">        <span class="comment"># 不需要手动调用future.result()</span></span><br><span class="line">        results = executor.<span class="built_in">map</span>(time_consuming_task, <span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"任务提交完成，直接获取有序结果..."</span>)</span><br><span class="line">        <span class="comment"># 转换为列表时会按照输入顺序返回结果，如果任务未完成会在这里阻塞等待</span></span><br><span class="line">        results_list = <span class="built_in">list</span>(results)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f"结果：<span class="subst">{results_list}</span>"</span>)</span><br><span class="line">    end_time = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"总耗时：<span class="subst">{end_time - start_time}</span>秒"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\n===== 3. add_done_callback示例 ====="</span>)</span><br><span class="line">    <span class="comment"># add_done_callback(fn): 添加任务完成回调函数</span></span><br><span class="line">    start_time = time.time()</span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">4</span>) <span class="keyword">as</span> executor:</span><br><span class="line">        futures = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">6</span>):</span><br><span class="line">            future = executor.submit(time_consuming_task, i)</span><br><span class="line">            <span class="comment"># 添加回调函数，任务完成后自动调用</span></span><br><span class="line">            future.add_done_callback(task_done_callback)</span><br><span class="line">            futures.append(future)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"已添加回调函数，主线程继续执行..."</span>)</span><br><span class="line">        <span class="comment"># 等待所有任务完成</span></span><br><span class="line">        <span class="keyword">for</span> future <span class="keyword">in</span> futures:</span><br><span class="line">            future.result()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"耗时：<span class="subst">{time.time() - start_time}</span>秒"</span>)</span><br><span class="line">    <span class="comment"># 适用场景：任务完成后的后续处理，适合需要在任务完成时执行额外操作而不阻塞主线程</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\n===== 4. wait示例 ====="</span>)</span><br><span class="line">    <span class="comment"># wait(): 等待任务完成</span></span><br><span class="line">    start_time = time.time()</span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">4</span>) <span class="keyword">as</span> executor:</span><br><span class="line">        futures = [executor.submit(time_consuming_task, i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>)]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"任务已提交，等待所有任务完成..."</span>)</span><br><span class="line">        <span class="comment"># 等待所有任务完成</span></span><br><span class="line">        done, not_done = wait(futures)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f"完成的任务数: <span class="subst">{<span class="built_in">len</span>(done)}</span>, 未完成的任务数: <span class="subst">{<span class="built_in">len</span>(not_done)}</span>"</span>)</span><br><span class="line">        results = [future.result() <span class="keyword">for</span> future <span class="keyword">in</span> done]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f"所有任务执行完毕，结果为：<span class="subst">{results}</span>"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"耗时：<span class="subst">{time.time() - start_time}</span>秒"</span>)</span><br><span class="line">    <span class="comment"># 适用场景：任务同步点，适合需要等待一组任务全部或部分完成后再继续执行的情况</span></span><br></pre></td></tr></tbody></table></figure><h4 id="Event-事件同步机制"><a href="#Event-事件同步机制" class="headerlink" title="Event 事件同步机制"></a>Event 事件同步机制</h4><p>Event 是一种线程同步机制，用于协调多个线程的执行顺序。它本质上是一个内部的标志位，线程可以等待这个标志位被设置，也可以设置或清除这个标志位。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Event</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment">## 创建一个事件对象</span></span><br><span class="line">event = Event()</span><br><span class="line"></span><br><span class="line"><span class="comment">## 模拟公交车到站的函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bus_stop</span>():</span><br><span class="line">    <span class="string">"""模拟公交车到站过程"""</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'公交车即将到站'</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)  <span class="comment"># 模拟行驶时间</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'公交车已到站&lt;====&gt;'</span>*<span class="number">10</span>)</span><br><span class="line">    <span class="comment"># 设置事件，通知等待的乘客</span></span><br><span class="line">    event.<span class="built_in">set</span>()  <span class="comment"># 发射信号，让等车的人上车</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">passenger</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="string">"""模拟乘客等车</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        name: 乘客名称</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 等待公交车到站</span></span><br><span class="line">    <span class="built_in">print</span>(name, <span class="string">'等车中'</span>)</span><br><span class="line">    event.wait()  <span class="comment"># 阻塞等待信号</span></span><br><span class="line">    <span class="built_in">print</span>(name, <span class="string">'出发！！！！！！！！！！！！！！！！！！！！！！！！！！'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 创建公交车线程</span></span><br><span class="line">    t1 = Thread(target=bus_stop)</span><br><span class="line">    t1.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建多个乘客线程</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">        t = Thread(target=passenger, args=(<span class="string">f'乘客<span class="subst">{i}</span>'</span>,))</span><br><span class="line">        t.start()</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)  <span class="comment"># 模拟乘客陆续到站</span></span><br></pre></td></tr></tbody></table></figure><h5 id="Event-主要方法"><a href="#Event-主要方法" class="headerlink" title="Event 主要方法"></a>Event 主要方法</h5><table><thead><tr><th>方法名</th><th>描述</th><th>使用场景</th></tr></thead><tbody><tr><td><code>set()</code></td><td>设置事件标志为 True</td><td>通知等待的线程继续执行</td></tr><tr><td><code>clear()</code></td><td>清除事件标志为 False</td><td>重置事件状态，使线程再次等待</td></tr><tr><td><code>is_set()</code></td><td>检查事件状态</td><td>判断事件是否已被设置</td></tr><tr><td><code>wait()</code></td><td>等待事件被设置</td><td>阻塞线程直到事件被设置或超时</td></tr></tbody></table><blockquote><p>🌟 <strong>应用场景</strong>：Event 适合实现一次性通知多个线程的场景，比如多个工作线程等待初始化完成、多个消费者等待数据准备就绪等。在 Web 开发中，可用于协调多个后台任务的启动时机。</p></blockquote><h4 id="定时器-Timer"><a href="#定时器-Timer" class="headerlink" title="定时器(Timer)"></a>定时器(Timer)</h4><p>定时器是线程的一个特殊应用，用于在指定时间后执行某个操作。Python 的 <code>threading</code> 模块提供了 <code>Timer</code> 类来实现这一功能。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Timer</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delayed_greeting</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="string">"""延迟执行的问候函数</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        name: 要问候的对象名称</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"<span class="subst">{name}</span>说: 哈哈，我是延迟1秒后才执行的!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 创建一个定时器，1秒后执行hello函数，参数为"小明"</span></span><br><span class="line">timer = Timer(<span class="number">1</span>, delayed_greeting, args=(<span class="string">"小明"</span>,))</span><br><span class="line"><span class="comment">## 启动定时器</span></span><br><span class="line">timer.start()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"定时器已启动，但greeting函数还未执行..."</span>)</span><br><span class="line"><span class="comment">## 主线程继续执行，不会被阻塞</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>💡 <strong>实用技巧</strong>：Timer 可用于实现超时处理、延迟重试、定时清理等场景。例如，在网络编程中，可以用 Timer 设置请求超时机制；在数据同步中，可以用 Timer 定期执行同步任务。</p></blockquote><h3 id="14-4-多进程-VS-多线程性能分析"><a href="#14-4-多进程-VS-多线程性能分析" class="headerlink" title="14.4 多进程 VS 多线程性能分析"></a>14.4 多进程 VS 多线程性能分析</h3><p>在 Python 中，由于 GIL(全局解释器锁)的存在，多线程并不能真正实现并行计算。因此，根据任务特性选择合适的并发模型十分重要。</p><h4 id="不同场景的最优选择"><a href="#不同场景的最优选择" class="headerlink" title="不同场景的最优选择"></a>不同场景的最优选择</h4><table><thead><tr><th>任务类型</th><th>多进程</th><th>多线程</th><th>推荐选择</th></tr></thead><tbody><tr><td>计算密集型</td><td>效率高，可利用多核</td><td>受 GIL 限制，效率相对较低</td><td>多进程</td></tr><tr><td>IO 密集型</td><td>资源占用大</td><td>资源占用小，效率与多进程相当</td><td>多线程</td></tr></tbody></table><blockquote><p>📊 <strong>实际应用建议</strong>：现代开发中，约 90%以上的程序属于 IO 密集型，适合使用多线程；对于数据分析、图像处理等计算密集型任务，则推荐使用多进程。也可以考虑混合使用：多进程下每个进程内再使用多线程。</p></blockquote><h4 id="计算密集型任务测试"><a href="#计算密集型任务测试" class="headerlink" title="计算密集型任务测试"></a>计算密集型任务测试</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">计算密集型任务对比测试</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>():</span><br><span class="line">    <span class="string">"""计算密集型任务"""</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000000</span>):  <span class="comment"># 执行大量计算</span></span><br><span class="line">        res += i</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    l = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="comment"># 使用多进程或多线程(取消相应的注释来测试)</span></span><br><span class="line">        p = Process(target=task)  <span class="comment"># 多进程：结果大概是1.65秒</span></span><br><span class="line">        <span class="comment"># p = Thread(target=task)   # 多线程：结果大概是4.18秒</span></span><br><span class="line">        </span><br><span class="line">        p.start()</span><br><span class="line">        l.append(p)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> l:</span><br><span class="line">        p.join()</span><br><span class="line"></span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"花费时间"</span>, end - start_time)</span><br></pre></td></tr></tbody></table></figure><h4 id="IO-密集型任务测试"><a href="#IO-密集型任务测试" class="headerlink" title="IO 密集型任务测试"></a>IO 密集型任务测试</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">IO密集型任务对比测试</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>():</span><br><span class="line">    <span class="string">"""IO密集型任务，使用sleep模拟IO操作"""</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)  <span class="comment"># 模拟IO等待</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    l = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):  <span class="comment"># 创建100个任务</span></span><br><span class="line">        <span class="comment"># 使用多进程或多线程(取消相应的注释来测试)</span></span><br><span class="line">        <span class="comment"># p = Process(target=task)  # 多进程：结果约19.34秒</span></span><br><span class="line">        p = Thread(target=task)   <span class="comment"># 多线程：结果约1.01秒</span></span><br><span class="line">        </span><br><span class="line">        p.start()</span><br><span class="line">        l.append(p)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> l:</span><br><span class="line">        p.join()</span><br><span class="line"></span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"花费时间"</span>, end - start_time)</span><br></pre></td></tr></tbody></table></figure><blockquote><p>⚠️ <strong>性能陷阱</strong>：多线程在 IO 密集型任务中表现出色，但过多的线程可能导致线程切换开销增大，反而降低效率。经验值是控制线程数为 CPU 核心数的 2-4 倍。</p></blockquote><h3 id="14-5-协程技术详解"><a href="#14-5-协程技术详解" class="headerlink" title="14.5 协程技术详解"></a>14.5 协程技术详解</h3><h4 id="协程基础概念"><a href="#协程基础概念" class="headerlink" title="协程基础概念"></a>协程基础概念</h4><p><strong>协程</strong>（Coroutine）也称为微线程，是一种用户态内的上下文切换技术，可以在单线程下实现并发效果。协程通过巧妙的编程技巧实现了程序主动让出和恢复执行的能力，使得单线程内可以 “模拟” 出并发的效果。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">进程：资源单位 - 系统分配资源的基本单位，拥有独立的内存空间</span></span><br><span class="line"><span class="string">线程：执行单位 - CPU调度和执行的最小单位，共享所属进程的内存空间</span></span><br><span class="line"><span class="string">协程：根本不存在，它是程序员人为创造出来的(切换+保存状态)</span></span><br><span class="line"><span class="string">当程序遇到IO的时候，通过我们的代码，让我们的程序自动完成切换</span></span><br><span class="line"><span class="string">也就是通过代码监听IO，一旦程序遇到IO，就在代码层面自动切换，给CPU的感觉就是我们的程序没有IO</span></span><br><span class="line"><span class="string">换句话说也就是我们欺骗了CPU</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></tbody></table></figure><p>协程的核心原理是 “<strong>切换+保存状态</strong>“，即在多个任务之间来回切换，每次切换都保存当前任务的执行状态，下次切换回来继续执行。在 Python 中，可以通过 <code>yield</code> 关键字、<code>greenlet</code> 模块或 <code>asyncio</code> 库实现协程。</p><blockquote><p>🔍 <strong>深入理解</strong>：协程不是提升计算效率，而是提升 IO 效率。在 IO 密集型应用中，协程可以让 CPU 在等待 IO 的同时执行其他任务，从而提高资源利用率。协程的切换不需要操作系统参与，开销远小于线程切换。</p></blockquote><table><thead><tr><th>概念</th><th>资源占用</th><th>切换开销</th><th>实现方式</th><th>适用场景</th></tr></thead><tbody><tr><td>进程</td><td>高（独立内存空间）</td><td>高（涉及内存映射）</td><td>操作系统调度</td><td>CPU 密集型，需要隔离的任务</td></tr><tr><td>线程</td><td>中（共享内存但有独立栈）</td><td>中（上下文切换）</td><td>操作系统调度</td><td>混合型任务，兼顾计算与 IO</td></tr><tr><td>协程</td><td>低（共享线程内全部资源）</td><td>低（用户态切换）</td><td>程序自行控制</td><td>IO 密集型，高并发网络应用</td></tr></tbody></table><h4 id="协程效率对比"><a href="#协程效率对比" class="headerlink" title="协程效率对比"></a>协程效率对比</h4><p>对于计算密集型任务时，使用协程反而会降低效率！</p><h5 id="串行执行"><a href="#串行执行" class="headerlink" title="串行执行"></a>串行执行</h5><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">    <span class="string">"""计算密集型函数1"""</span></span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000000</span>):</span><br><span class="line">        n += i  <span class="comment"># 执行简单累加计算</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f2</span>():</span><br><span class="line">    <span class="string">"""计算密集型函数2"""</span></span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000000</span>):</span><br><span class="line">        n += i  <span class="comment"># 执行简单累加计算</span></span><br><span class="line"></span><br><span class="line">start_time = time.time()</span><br><span class="line">f1()  <span class="comment"># 顺序执行f1</span></span><br><span class="line">f2()  <span class="comment"># 然后执行f2</span></span><br><span class="line"><span class="comment">## 保留两位小数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"串行执行总共用时：%.2f秒"</span> % (time.time() - start_time))  <span class="comment"># 串行执行总共用时：0.84秒</span></span><br></pre></td></tr></tbody></table></figure><h5 id="使用-yield-实现协程切换"><a href="#使用-yield-实现协程切换" class="headerlink" title="使用 yield 实现协程切换"></a>使用 yield 实现协程切换</h5><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">    <span class="string">"""带yield的计算密集型函数1"""</span></span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000000</span>):</span><br><span class="line">        n += i</span><br><span class="line">        <span class="keyword">yield</span>  <span class="comment"># 主动让出执行权，保存当前执行状态</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f2</span>():</span><br><span class="line">    <span class="string">"""使用f1的生成器进行交替执行"""</span></span><br><span class="line">    g = f1()  <span class="comment"># 创建生成器对象</span></span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000000</span>):</span><br><span class="line">        n += i</span><br><span class="line">        <span class="built_in">next</span>(g)  <span class="comment"># 切换到f1执行一步，f1会执行到下一个yield后暂停</span></span><br><span class="line"></span><br><span class="line">start_time = time.time()</span><br><span class="line">f2()  <span class="comment"># 执行f2，内部会与f1交替执行</span></span><br><span class="line"><span class="comment">## 保留两位小数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"yield协程用时：%.2f秒"</span> % (time.time() - start_time))  <span class="comment"># 约1.45秒</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>⚠️ <strong>注意事项</strong>：对于计算密集型任务，协程切换反而会增加开销，降低效率；但对于 IO 密集型任务，协程切换可以显著提高效率。这是因为在 IO 等待期间，协程可以切换到其他任务继续执行，避免了 CPU 空闲。</p></blockquote><h4 id="greenlet-模块（了解）"><a href="#greenlet-模块（了解）" class="headerlink" title="greenlet 模块（了解）"></a>greenlet 模块（了解）</h4><p>greenlet 是一个轻量级的协程库，提供了基本的协程实现。它允许在不使用回调函数的情况下，在不同函数间来回切换执行，实现了所谓的 “确定性切换”。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> greenlet <span class="keyword">import</span> greenlet</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func_a</span>():</span><br><span class="line">    <span class="string">"""协程函数a"""</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'函数a正在运行'</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)  <span class="comment"># 模拟某些操作</span></span><br><span class="line">        b.switch()  <span class="comment"># 主动切换到函数b执行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func_b</span>():</span><br><span class="line">    <span class="string">"""协程函数b"""</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'函数b正在运行'</span>)</span><br><span class="line">        time.sleep(<span class="number">2</span>)  <span class="comment"># 模拟某些操作</span></span><br><span class="line">        a.switch()  <span class="comment"># 切换回函数a执行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 创建两个greenlet对象</span></span><br><span class="line">    a = greenlet(func_a)  <span class="comment"># 将函数封装为greenlet对象</span></span><br><span class="line">    b = greenlet(func_b)  <span class="comment"># 将函数封装为greenlet对象</span></span><br><span class="line">    <span class="comment"># 从函数a开始执行</span></span><br><span class="line">    a.switch()  <span class="comment"># 启动协程a</span></span><br></pre></td></tr></tbody></table></figure><h5 id="greenlet-核心方法与属性"><a href="#greenlet-核心方法与属性" class="headerlink" title="greenlet 核心方法与属性"></a>greenlet 核心方法与属性</h5><table><thead><tr><th>方法/属性名</th><th>描述</th><th>使用场景</th><th>示例</th></tr></thead><tbody><tr><td><code>greenlet.getcurrent()</code></td><td>获取当前正在执行的 greenlet 对象</td><td>在函数内获取当前协程</td><td><code>current = greenlet.getcurrent()</code></td></tr><tr><td><code>greenlet.switch(value=None)</code></td><td>将控制权切换到另一个 greenlet</td><td>协程间的主动切换</td><td><code>g.switch('传递参数')</code></td></tr><tr><td><code>greenlet.parent</code></td><td>获取当前 greenlet 的父 greenlet</td><td>协程层级管理</td><td><code>parent = g.parent</code></td></tr><tr><td><code>throw(type, value=None, tb=None)</code></td><td>向 greenlet 对象中抛出异常</td><td>协程异常处理</td><td><code>g.throw(ValueError, '错误信息')</code></td></tr><tr><td><code>dead</code></td><td>判断 greenlet 是否已经执行完毕</td><td>协程状态检查</td><td><code>if g.dead: print('已执行完毕')</code></td></tr><tr><td><code>gr_frame</code></td><td>获取 greenlet 当前的帧对象</td><td>调试和检查协程状态</td><td><code>frame = g.gr_frame</code></td></tr><tr><td><code>run</code></td><td>绑定到 greenlet 的可调用对象</td><td>查看协程的目标函数</td><td><code>func = g.run</code></td></tr></tbody></table><blockquote><p>💡 <strong>使用技巧</strong>：greenlet 适合实现简单的协程切换，但不支持自动在 IO 操作时切换，因此常与事件循环结合使用，如 gevent 库。greenlet 的优势在于它的轻量和灵活性，可以构建复杂的协程调度系统。</p></blockquote><h4 id="gevent-模块（了解）"><a href="#gevent-模块（了解）" class="headerlink" title="gevent 模块（了解）"></a>gevent 模块（了解）</h4><p>gevent 是基于 greenlet 的协程库，增加了事件循环和自动 IO 切换功能。它通过 “猴子补丁”（monkey patching）将标准库中的阻塞操作替换为非阻塞版本，使普通的同步代码能够以异步方式执行。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">gevent 是一个基于协程的 Python 网络库，它使用 greenlet 在 libev 或 libuv </span></span><br><span class="line"><span class="string">等事件循环之上提供高级同步 API。gevent 实现了python 标准库里面大部分的阻塞式系统调用，</span></span><br><span class="line"><span class="string">包括 socket、ssl、threading 和 select 等模块，</span></span><br><span class="line"><span class="string">可以使用 "猴子补丁" 将这些阻塞式调用变为协作式运行。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">猴子补丁的功能很强大，但是也带来了很多的风险，尤其是像 gevent 这种直接进行 API替换的补丁，</span></span><br><span class="line"><span class="string">整个 Python 进程所使用的模块都会被替换，可能自己的代码能 hold 住，</span></span><br><span class="line"><span class="string">但是其它第三方库，有时候问题并不好排查，即使排查出来也是很棘手，所以，</span></span><br><span class="line"><span class="string">就像松本建议的那样，如果要使用猴子补丁，那么只是做功能追加，</span></span><br><span class="line"><span class="string">尽量避免大规模的 API 覆盖。 虽然猴子补丁仍然是邪恶的(evil)，</span></span><br><span class="line"><span class="string">但在这种情况下它是 "有用的邪恶(useful evil)"。</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></tbody></table></figure><h5 id="gevent-基础操作"><a href="#gevent-基础操作" class="headerlink" title="gevent 基础操作"></a>gevent 基础操作</h5><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey</span><br><span class="line"></span><br><span class="line"><span class="comment">## 应用猴子补丁，将标准库的阻塞操作替换为非阻塞版本</span></span><br><span class="line"><span class="comment">## 必须在导入其他模块前调用，确保所有IO操作都被替换</span></span><br><span class="line">monkey.patch_all()  <span class="comment"># 替换所有可能的阻塞调用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="string">"""协程函数1"""</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'Running in foo'</span>)</span><br><span class="line">    gevent.sleep(<span class="number">0</span>)  <span class="comment"># 模拟IO操作，主动让出控制权</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'Explicit context switch to foo'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>():</span><br><span class="line">    <span class="string">"""协程函数2"""</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'Running in bar'</span>)</span><br><span class="line">    gevent.sleep(<span class="number">0</span>)  <span class="comment"># 模拟IO操作，主动让出控制权</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'Explicit context switch to bar'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">baz</span>():</span><br><span class="line">    <span class="string">"""协程函数3"""</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'Running in baz'</span>)</span><br><span class="line">    gevent.sleep(<span class="number">0</span>)  <span class="comment"># 模拟IO操作，主动让出控制权</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'Explicit context switch to baz'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 创建三个协程</span></span><br><span class="line">g1 = gevent.spawn(foo)  <span class="comment"># 创建协程但不立即执行</span></span><br><span class="line">g2 = gevent.spawn(bar)  <span class="comment"># 创建协程但不立即执行</span></span><br><span class="line">g3 = gevent.spawn(baz)  <span class="comment"># 创建协程但不立即执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 等待所有协程完成</span></span><br><span class="line">gevent.joinall([g1, g2, g3])  <span class="comment"># 类似于多线程中的join方法</span></span><br></pre></td></tr></tbody></table></figure><h5 id="gevent-常用-API-详解"><a href="#gevent-常用-API-详解" class="headerlink" title="gevent 常用 API 详解"></a>gevent 常用 API 详解</h5><table><thead><tr><th>方法/类名</th><th>描述</th><th>使用场景</th><th>实际应用示例</th></tr></thead><tbody><tr><td><code>gevent.spawn(function, *args, **kwargs)</code></td><td>创建并运行协程</td><td>启动异步任务</td><td>启动多个 HTTP 请求并行处理</td></tr><tr><td><code>gevent.joinall(greenlets, timeout=None, raise_error=False)</code></td><td>等待多个协程完成</td><td>同步点，等待所有任务完成</td><td>批量处理多个数据源</td></tr><tr><td><code>gevent.sleep(seconds=0)</code></td><td>协程休眠并让出控制权</td><td>模拟 IO 操作，主动让出控制权</td><td>测试协程调度，防止 CPU 密集任务阻塞</td></tr><tr><td><code>gevent.wait(objects=None, timeout=None, count=None)</code></td><td>等待对象(协程)完成</td><td>等待部分任务完成</td><td>等待最快完成的结果</td></tr><tr><td><code>gevent.kill(greenlet, exception=GreenletExit)</code></td><td>终止协程</td><td>取消不需要的任务</td><td>实现任务超时取消</td></tr><tr><td><code>gevent.monkey.patch_all(socket=True, dns=True, ...)</code></td><td>应用猴子补丁</td><td>将同步库变为异步兼容</td><td>使用前替换标准库函数</td></tr><tr><td><code>gevent.queue.Queue</code></td><td>协程安全的队列</td><td>协程间通信和数据传递</td><td>生产者-消费者模式实现</td></tr><tr><td><code>gevent.event.Event</code></td><td>事件通知机制</td><td>协程间同步和通知</td><td>完成信号传递</td></tr><tr><td><code>gevent.pool.Pool</code></td><td>协程池</td><td>限制并发数量</td><td>控制网络请求并发数</td></tr><tr><td><code>gevent.select.select()</code></td><td>IO 多路复用</td><td>监控多个文件描述符</td><td>自定义事件循环</td></tr></tbody></table><blockquote><p>⚠️ <strong>使用 gevent 注意事项</strong>：</p><ol><li>所有协程运行在同一线程中，不能跨线程同步数据</li><li>gevent.queue.Queue 是协程安全的，可以用于协程间通信</li><li>不能有长时间阻塞的 CPU 密集型操作，会阻塞整个事件循环</li><li>最好使用 gevent 自身的非阻塞库或已打补丁的标准库</li><li>猴子补丁会修改全局状态，可能影响第三方库的行为，应在所有导入前应用</li><li>调试协程比调试线程更困难，错误追踪可能会更复杂</li></ol></blockquote><h5 id="实际应用场景示例"><a href="#实际应用场景示例" class="headerlink" title="实际应用场景示例"></a>实际应用场景示例</h5><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment">## 替换标准库</span></span><br><span class="line">monkey.patch_all()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fetch_url</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="string">"""获取URL内容的函数</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        url: 要获取的网址</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        tuple: (url, 响应状态码, 内容长度)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f"开始请求: <span class="subst">{url}</span>"</span>)</span><br><span class="line">        start = time.time()</span><br><span class="line">        response = requests.get(url, timeout=<span class="number">5</span>)  <span class="comment"># 进行HTTP请求，IO操作会自动切换</span></span><br><span class="line">        elapsed = time.time() - start</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f"完成请求: <span class="subst">{url}</span>, 耗时: <span class="subst">{elapsed:<span class="number">.2</span>f}</span>秒"</span>)</span><br><span class="line">        <span class="keyword">return</span> url, response.status_code, <span class="built_in">len</span>(response.content)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f"请求 <span class="subst">{url}</span> 出错: <span class="subst">{e}</span>"</span>)</span><br><span class="line">        <span class="keyword">return</span> url, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 要获取的URL列表</span></span><br><span class="line">urls = [</span><br><span class="line">    <span class="string">"https://www.python.org"</span>,</span><br><span class="line">    <span class="string">"https://www.github.com"</span>,</span><br><span class="line">    <span class="string">"https://www.stackoverflow.com"</span>,</span><br><span class="line">    <span class="string">"https://www.wikipedia.org"</span>,</span><br><span class="line">    <span class="string">"https://www.reddit.com"</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">start_time = time.time()</span><br><span class="line"></span><br><span class="line"><span class="comment">## 创建协程任务</span></span><br><span class="line">tasks = [gevent.spawn(fetch_url, url) <span class="keyword">for</span> url <span class="keyword">in</span> urls]</span><br><span class="line"></span><br><span class="line"><span class="comment">## 等待所有任务完成</span></span><br><span class="line">gevent.joinall(tasks)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 获取结果</span></span><br><span class="line">results = [task.value <span class="keyword">for</span> task <span class="keyword">in</span> tasks]</span><br><span class="line"></span><br><span class="line"><span class="comment">## 打印结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\n结果汇总:"</span>)</span><br><span class="line"><span class="keyword">for</span> url, status, length <span class="keyword">in</span> results:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"URL: <span class="subst">{url}</span>, 状态码: <span class="subst">{status}</span>, 内容长度: <span class="subst">{length}</span> 字节"</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f"\n总耗时: <span class="subst">{time.time() - start_time:<span class="number">.2</span>f}</span>秒"</span>)</span><br></pre></td></tr></tbody></table></figure><h4 id="greenlet-与-gevent-的区别与选择"><a href="#greenlet-与-gevent-的区别与选择" class="headerlink" title="greenlet 与 gevent 的区别与选择"></a>greenlet 与 gevent 的区别与选择</h4><table><thead><tr><th>特性</th><th>greenlet</th><th>gevent</th><th>实际应用建议</th></tr></thead><tbody><tr><td>基本原理</td><td>轻量级上下文切换</td><td>基于 greenlet，增加事件循环</td><td>简单任务用 greenlet，复杂系统用 gevent</td></tr><tr><td>IO 处理</td><td>不提供 IO 操作支持</td><td>提供自动 IO 切换机制</td><td>网络应用选择 gevent，自定义调度选择 greenlet</td></tr><tr><td>切换方式</td><td>需要显式调用 switch()</td><td>在 IO 操作时自动切换</td><td>手动控制流程用 greenlet，自动化处理用 gevent</td></tr><tr><td>复杂度</td><td>简单，仅提供基本切换</td><td>复杂，提供完整生态系统</td><td>小型项目用 greenlet，大型项目用 gevent</td></tr><tr><td>适用场景</td><td>简单协程调度</td><td>高并发网络应用</td><td>Web 爬虫、API 服务、代理服务器首选 gevent</td></tr><tr><td>性能</td><td>轻量，开销小</td><td>比 greenlet 略重，但实用性强</td><td>极致性能用 greenlet，平衡性能和开发效率用 gevent</td></tr><tr><td>学习曲线</td><td>简单，容易理解</td><td>较复杂，概念较多</td><td>入门协程从 greenlet 开始，再过渡到 gevent</td></tr><tr><td>社区支持</td><td>基础库，更新较少</td><td>活跃，有完整生态</td><td>长期项目建议使用 gevent</td></tr></tbody></table><blockquote><p>🌟 <strong>选择建议</strong>：如果只需要轻量级的上下文切换，可以使用 greenlet；如果需要处理 IO 密集型应用，特别是网络编程，建议使用 gevent。大多数实际项目中，gevent 是更好的选择，因为它提供了更完整的功能和自动化的 IO 处理。</p></blockquote><h4 id="asyncio-协程技术"><a href="#asyncio-协程技术" class="headerlink" title="asyncio 协程技术"></a>asyncio 协程技术</h4><p>随着 Python 的发展，协程技术已经有了显著进步。从 Python 3.4 引入的 <code>asyncio</code> 库开始，Python 对协程的原生支持不断增强。到 2025 年，Python 已经拥有更成熟、更高效的协程生态系统。</p><h5 id="asyncio-与原生协程"><a href="#asyncio-与原生协程" class="headerlink" title="asyncio 与原生协程"></a>asyncio 与原生协程</h5><p>Python 3.5 引入的 <code>async/await</code> 语法使得协程编程变得更加直观和强大，这是目前最推荐的协程实现方式：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">fetch_data</span>(<span class="params">url,delay</span>):</span><br><span class="line">    <span class="string">"""模拟从网络获取数据的异步函数"""</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"开始获取数据：<span class="subst">{url}</span>，延迟<span class="subst">{delay}</span>秒"</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(delay)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"成功获取数据长度：<span class="subst">{<span class="built_in">len</span>(url)}</span>"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f"数据<span class="subst">{url}</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="string">"""异步操作的主函数"""</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"程序开始时间:<span class="subst">{time.strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>, time.localtime())}</span>"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\n===== 串行执行示例 ====="</span>)</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    <span class="comment"># 串行执行 - 请求两个API数据</span></span><br><span class="line">    result1 = <span class="keyword">await</span> fetch_data(<span class="string">"https://www.baidu.com"</span>, <span class="number">2</span>)</span><br><span class="line">    result2 = <span class="keyword">await</span> fetch_data(<span class="string">"https://www.sina.com.cn"</span>,<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"串行执行结果：<span class="subst">{result1}</span>, <span class="subst">{result2}</span>"</span>)</span><br><span class="line">    end_time = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"程序结束时间:<span class="subst">{time.strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>, time.localtime())}</span>"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"程序耗时:<span class="subst">{end_time-start_time}</span>秒"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 并行执行 - 请求两个API数据</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\n===== 并行执行示例 ====="</span>)</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    tasks = [</span><br><span class="line">        asyncio.create_task(fetch_data(<span class="string">"https://www.baidu.com"</span>, <span class="number">2</span>)),</span><br><span class="line">        asyncio.create_task(fetch_data(<span class="string">"https://www.sina.com.cn"</span>,<span class="number">3</span>)),</span><br><span class="line">    ]</span><br><span class="line">    results = <span class="keyword">await</span> asyncio.gather(*tasks) <span class="comment"># 批量等待所有任务完成</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"并行执行结果：<span class="subst">{results}</span>"</span>)</span><br><span class="line">    end_time = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"程序结束时间:<span class="subst">{time.strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>, time.localtime())}</span>"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"程序耗时:<span class="subst">{end_time-start_time}</span>秒"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 在Python 3.7+中，可以直接使用asyncio.run()运行主协程</span></span><br><span class="line">    asyncio.run(main())</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h5 id="asyncio-常用-API"><a href="#asyncio-常用-API" class="headerlink" title="asyncio 常用 API"></a>asyncio 常用 API</h5><table><thead><tr><th>方法/函数</th><th>描述</th><th>使用场景</th><th>示例</th></tr></thead><tbody><tr><td><code>asyncio.run()</code></td><td>运行协程</td><td>程序入口点</td><td><code>asyncio.run(main())</code></td></tr><tr><td><code>asyncio.create_task()</code></td><td>创建任务</td><td>并行执行协程</td><td><code>task = asyncio.create_task(coro())</code></td></tr><tr><td><code>asyncio.gather()</code></td><td>并行运行多个协程</td><td>批量并发任务</td><td><code>results = await asyncio.gather(coro1(), coro2())</code></td></tr><tr><td><code>asyncio.wait_for()</code></td><td>带超时的等待</td><td>实现超时控制</td><td><code>await asyncio.wait_for(coro(), timeout=1.0)</code></td></tr><tr><td><code>asyncio.sleep()</code></td><td>非阻塞睡眠</td><td>模拟 IO 延迟</td><td><code>await asyncio.sleep(1.0)</code></td></tr><tr><td><code>asyncio.Queue</code></td><td>协程安全的队列</td><td>协程间数据传递</td><td><code>queue = asyncio.Queue(); await queue.put(item)</code></td></tr><tr><td><code>asyncio.Future</code></td><td>低级异步原语</td><td>自定义异步操作</td><td><code>future = asyncio.Future(); future.set_result(value)</code></td></tr><tr><td><code>asyncio.shield()</code></td><td>防止取消传播</td><td>保护关键协程</td><td><code>await asyncio.shield(critical_coro())</code></td></tr><tr><td><code>asyncio.as_completed()</code></td><td>按完成顺序返回结果</td><td>处理最先完成的任务</td><td><code>for task in asyncio.as_completed([coro1(), coro2()]): result = await task</code></td></tr></tbody></table><h4 id="Task-对象"><a href="#Task-对象" class="headerlink" title="Task 对象"></a>Task 对象</h4><p><code>Task</code> 是 <code>asyncio</code> 中用于封装协程的对象，可以用于并发执行多个任务。可以通过 <code>Task</code> 对象等待协程完成。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">nested</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'进入 nested()'</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)  <span class="comment"># 模拟IO操作</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'离开 nested()'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'42'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    task = asyncio.create_task(nested())  <span class="comment"># 创建任务</span></span><br><span class="line">    result = <span class="keyword">await</span> task  <span class="comment"># 等待任务完成</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f'返回值：<span class="subst">{result}</span>'</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></tbody></table></figure><h4 id="Future-对象"><a href="#Future-对象" class="headerlink" title="Future 对象"></a>Future 对象</h4><p><code>Future</code> 是 <code>Task</code> 的基类，表示一个未完成的结果。在底层异步操作中，<code>Future</code> 常常用来表示某些未决的操作结果。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个异步函数，用于设置future的结果</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">set_future_result</span>(<span class="params">future</span>):</span><br><span class="line">    <span class="comment"># 异步等待2秒，模拟耗时操作</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 设置future的结果为"Hello, world!"</span></span><br><span class="line">    future.set_result(<span class="string">"Hello, world!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义主异步函数</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 获取当前正在运行的事件循环</span></span><br><span class="line">    loop = asyncio.get_running_loop()</span><br><span class="line">    <span class="comment"># 创建Future对象，它代表一个尚未完成的异步操作</span></span><br><span class="line">    future = loop.create_future()  <span class="comment"># 创建Future对象</span></span><br><span class="line">    <span class="comment"># 创建一个任务来执行set_future_result函数，不等待其完成立即返回</span></span><br><span class="line">    asyncio.create_task(set_future_result(future))</span><br><span class="line">    <span class="comment"># 等待future完成并获取其结果</span></span><br><span class="line">    result = <span class="keyword">await</span> future  <span class="comment"># 等待Future完成</span></span><br><span class="line">    <span class="comment"># 打印future的结果</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"Future的结果: <span class="subst">{result}</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行主异步函数</span></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></tbody></table></figure><h4 id="异步上下文管理器"><a href="#异步上下文管理器" class="headerlink" title="异步上下文管理器"></a>异步上下文管理器</h4><p>异步上下文管理器允许在进入和退出时执行异步操作，常用于异步资源管理。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AsyncResource</span>:</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">__aenter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"资源获取"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">__aexit__</span>(<span class="params">self, exc_type, exc_value, traceback</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"资源释放"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> AsyncResource():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"执行任务中"</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></tbody></table></figure><h3 id="14-6-GIL-锁与-Python-并发性能"><a href="#14-6-GIL-锁与-Python-并发性能" class="headerlink" title="14.6 GIL 锁与 Python 并发性能"></a>14.6 GIL 锁与 Python 并发性能</h3><p>GIL(Global Interpreter Lock，全局解释器锁)是 CPython 解释器的一个特性，它确保同一时刻只有一个线程可以执行 Python 字节码。这个特性对 Python 多线程编程有着深远影响，也是导致 Python 速度慢的两大原因之一，其另外一个原因是因为 Python 是 <code>解释形</code> 语言，但后续可通过 <code>pypy</code> 技术实现 Python 的预编译，但唯独这个原因 Python 没有解决，Python 在早期开发时为解决垃圾回收机制内部问题采用了 GIL 锁，所以 Python 程序无法直接利用多核 CPU 的优势</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">GIL全局解释器锁(Global Interpreter Lock)，是CPython特有的一个物件，</span></span><br><span class="line"><span class="string">作用是让一个进程中同一时刻只能有一个线程可以被CPU调用</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">如果程序想利用计算机的多核优势，让CPU同时处理一些任务，适合用多进程开发（即使资源开销大）</span></span><br><span class="line"><span class="string">如果程序不想利用计算机的多核优势，适合用多线程开发</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></tbody></table></figure><h4 id="GIL-的本质与工作原理"><a href="#GIL-的本质与工作原理" class="headerlink" title="GIL 的本质与工作原理"></a>GIL 的本质与工作原理</h4><p>GIL 本质上是一把互斥锁，用于保护 Python 解释器的内部状态，主要解决了 Python 对象的内存管理问题。</p><table><thead><tr><th>GIL 特性</th><th>描述</th></tr></thead><tbody><tr><td>实现方式</td><td>互斥锁(mutex)</td></tr><tr><td>作用对象</td><td>Python 解释器进程</td></tr><tr><td>控制范围</td><td>Python 字节码执行</td></tr><tr><td>释放时机</td><td>I/O 操作、执行固定字节码数量后</td></tr><tr><td>影响范围</td><td>仅影响 CPython，PyPy、Jython、IronPython 不受影响</td></tr></tbody></table><blockquote><p>🔍 <strong>深入理解</strong>：GIL 并非 Python 语言本身的特性，而是 CPython 实现的产物。它解决了 CPython 简单引用计数式内存管理的线程安全问题，但也限制了多线程程序利用多核性能的能力。</p></blockquote><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## GIL工作示意伪代码</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">thread_execution</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        acquire_GIL()       <span class="comment"># 获取GIL锁</span></span><br><span class="line">        execute_bytecodes() <span class="comment"># 执行一定数量的字节码</span></span><br><span class="line">        release_GIL()       <span class="comment"># 释放GIL锁以允许其他线程运行</span></span><br><span class="line">        wait_for_GIL()      <span class="comment"># 等待再次获取GIL</span></span><br><span class="line">        </span><br><span class="line"><span class="comment"># 这也就导致了每一个线程都需要在执行获取字节码时都要经历拿锁-&gt;解锁的过程</span></span><br></pre></td></tr></tbody></table></figure><h4 id="并发与并行的区别"><a href="#并发与并行的区别" class="headerlink" title="并发与并行的区别"></a>并发与并行的区别</h4><p>并发(Concurrency)和并行(Parallelism)是两个在计算机科学中经常出现的概念，虽然常被混用，但有着本质区别：</p><table><thead><tr><th>特性</th><th>并发(Concurrency)</th><th>并行(Parallelism)</th></tr></thead><tbody><tr><td>定义</td><td>多个任务在同一时间间隔内发生</td><td>多个任务在同一时刻发生</td></tr><tr><td>重点</td><td>任务切换与调度</td><td>任务的同时执行</td></tr><tr><td>资源需求</td><td>可以在单处理器上通过时间片轮转实现</td><td>需要多个处理器或核心</td></tr><tr><td>执行方式</td><td>任务交替执行，共享处理器时间</td><td>每个任务有独立的处理器同时执行</td></tr><tr><td>适用场景</td><td>I/O 密集型任务，如网络请求、文件读写</td><td>计算密集型任务，如图像处理、科学计算</td></tr><tr><td>实现难度</td><td>相对简单，关注任务调度</td><td>相对复杂，需考虑数据分割、同步和合并</td></tr><tr><td>Python 实现</td><td>多线程、协程</td><td>多进程</td></tr></tbody></table><blockquote><p>🌟 <strong>关键理解</strong>：由于 GIL 的存在，Python 的多线程实际上只能实现并发，而不能实现真正的并行。要实现并行，需要使用多进程或依赖不受 GIL 限制的扩展库（如使用 C 扩展的 NumPy）。</p></blockquote><h4 id="线程安全与并发控制"><a href="#线程安全与并发控制" class="headerlink" title="线程安全与并发控制"></a>线程安全与并发控制</h4><p>线程安全指在多线程环境下，程序能够正确地处理共享资源，不会因为多线程同时访问而导致数据不一致。尽管 Python 的 GIL 能减轻一些并发问题，但并不能完全保证线程安全。</p><h5 id="线程安全问题示例"><a href="#线程安全问题示例" class="headerlink" title="线程安全问题示例"></a>线程安全问题示例</h5><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment">### 共享的全局变量</span></span><br><span class="line">counter = <span class="number">0</span></span><br><span class="line">start_time = time.time()</span><br><span class="line">iterations_completed = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">increment_counter</span>():</span><br><span class="line">    <span class="string">"""增加计数器，但使用了非原子操作的方式"""</span></span><br><span class="line">    <span class="keyword">global</span> counter, iterations_completed</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000000</span>):</span><br><span class="line">        <span class="comment"># 模拟线程安全问题：读取-修改-写入过程中可能被中断</span></span><br><span class="line">        local_counter = counter  <span class="comment"># 读取当前值</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 模拟线程在读取后被切换的情况</span></span><br><span class="line">        <span class="comment"># 随机休眠一个很小的时间，增加线程切换的可能性</span></span><br><span class="line">        <span class="keyword">if</span> random.random() &lt; <span class="number">0.00001</span>:</span><br><span class="line">            time.sleep(<span class="number">0.00001</span>)</span><br><span class="line">            </span><br><span class="line">        local_counter += <span class="number">1</span>  <span class="comment"># 在本地修改</span></span><br><span class="line">        counter = local_counter  <span class="comment"># 写回全局变量</span></span><br><span class="line">        iterations_completed += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_concurrent_threads</span>(<span class="params">num_threads</span>):</span><br><span class="line">    <span class="string">"""运行多个线程同时增加计数器"""</span></span><br><span class="line">    <span class="keyword">global</span> counter, iterations_completed</span><br><span class="line">    counter = <span class="number">0</span></span><br><span class="line">    iterations_completed = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    threads = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_threads):</span><br><span class="line">        t = Thread(target=increment_counter)</span><br><span class="line">        threads.append(t)</span><br><span class="line">        t.start()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.join()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 理论上应该等于 num_threads * 1000000</span></span><br><span class="line">    expected = num_threads * <span class="number">1000000</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"预期结果: <span class="subst">{expected}</span>"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"实际结果: <span class="subst">{counter}</span>"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"丢失的增量: <span class="subst">{expected - counter}</span>"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"完成的迭代次数: <span class="subst">{iterations_completed}</span>"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f'开始时间为: <span class="subst">{time.strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>, time.localtime())}</span>'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 运行4个线程，每个线程增加计数器1000000次</span></span><br><span class="line">    <span class="comment"># 理论上最终结果应该是4000000，但由于线程安全问题，实际结果会小于这个值</span></span><br><span class="line">    run_concurrent_threads(<span class="number">4</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"累计用时: <span class="subst">{<span class="built_in">round</span>(time.time() - start_time, <span class="number">1</span>)}</span>秒"</span>)</span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h5 id="使用线程锁解决安全问题"><a href="#使用线程锁解决安全问题" class="headerlink" title="使用线程锁解决安全问题"></a>使用线程锁解决安全问题</h5><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Lock</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment">### 共享的全局变量</span></span><br><span class="line">counter = <span class="number">0</span></span><br><span class="line">start_time = time.time()</span><br><span class="line">iterations_completed = <span class="number">0</span></span><br><span class="line"><span class="comment"># 创建一个线程锁</span></span><br><span class="line">counter_lock = Lock()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">increment_counter</span>():</span><br><span class="line">    <span class="string">"""增加计数器，使用线程锁确保线程安全"""</span></span><br><span class="line">    <span class="keyword">global</span> counter, iterations_completed</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000000</span>):</span><br><span class="line">        <span class="comment"># 使用线程锁保护临界区</span></span><br><span class="line">        <span class="keyword">with</span> counter_lock:</span><br><span class="line">            counter += <span class="number">1</span>  <span class="comment"># 在锁的保护下直接修改全局变量</span></span><br><span class="line">            iterations_completed += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_concurrent_threads</span>(<span class="params">num_threads</span>):</span><br><span class="line">    <span class="string">"""运行多个线程同时增加计数器"""</span></span><br><span class="line">    <span class="keyword">global</span> counter, iterations_completed</span><br><span class="line">    counter = <span class="number">0</span></span><br><span class="line">    iterations_completed = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    threads = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_threads):</span><br><span class="line">        t = Thread(target=increment_counter)</span><br><span class="line">        threads.append(t)</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.join()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 理论上应该等于 num_threads * 1000000</span></span><br><span class="line">    expected = num_threads * <span class="number">1000000</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"预期结果: <span class="subst">{expected}</span>"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"实际结果: <span class="subst">{counter}</span>"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"丢失的增量: <span class="subst">{expected - counter}</span>"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"完成的迭代次数: <span class="subst">{iterations_completed}</span>"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f'开始时间为: <span class="subst">{time.strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>, time.localtime())}</span>'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 运行4个线程，每个线程增加计数器1000000次</span></span><br><span class="line">    <span class="comment"># 使用线程锁后，最终结果应该正确等于4000000</span></span><br><span class="line">    run_concurrent_threads(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"累计用时: <span class="subst">{<span class="built_in">round</span>(time.time() - start_time, <span class="number">1</span>)}</span>秒"</span>)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><blockquote><p>🔒 <strong>线程锁作用与注意事项</strong>：</p><ul><li>锁确保同一时刻只有一个线程能访问共享资源</li><li>锁会影响性能，特别是在竞争激烈的情况下</li><li>锁的粒度需要权衡：粒度太细会增加锁操作开销，太粗会降低并发度</li><li>锁可能引发死锁问题，需谨慎设计锁的获取顺序</li></ul></blockquote><h4 id="Python-中的锁机制全面解析"><a href="#Python-中的锁机制全面解析" class="headerlink" title="Python 中的锁机制全面解析"></a>Python 中的锁机制全面解析</h4><p>Python 的 <code>threading</code> 模块提供了多种锁和同步原语，用于不同并发控制场景。深入理解这些锁的特性和适用场景，对于开发可靠的并发程序至关重要。</p><h5 id="Python-锁类型及其特性"><a href="#Python-锁类型及其特性" class="headerlink" title="Python 锁类型及其特性"></a>Python 锁类型及其特性</h5><table><thead><tr><th>锁类型</th><th>描述</th><th>独占性</th><th>可重入性</th><th>公平性</th><th>注意事项</th></tr></thead><tbody><tr><td><code>threading.Lock</code></td><td>基本互斥锁</td><td>是</td><td>否</td><td>非公平</td><td>最简单的锁，同一线程不能重复获取</td></tr><tr><td><code>threading.RLock</code></td><td>可重入锁</td><td>是</td><td>是</td><td>非公平</td><td>同一线程可多次获取，必须对应释放相同次数</td></tr><tr><td><code>threading.Condition</code></td><td>条件变量</td><td>-</td><td>-</td><td>非公平</td><td>基于锁实现，提供 wait/notify 机制</td></tr><tr><td><code>threading.Semaphore</code></td><td>信号量</td><td>否</td><td>-</td><td>非公平</td><td>限制资源访问线程数量</td></tr><tr><td><code>threading.BoundedSemaphore</code></td><td>有界信号量</td><td>否</td><td>-</td><td>非公平</td><td>限制资源数量，防止过度释放</td></tr><tr><td><code>threading.Event</code></td><td>事件对象</td><td>-</td><td>-</td><td>-</td><td>用于线程间通知而非资源控制</td></tr><tr><td><code>threading.Barrier</code></td><td>栅栏对象</td><td>-</td><td>-</td><td>-</td><td>使多个线程同步到达某点再继续</td></tr><tr><td><code>queue.Queue</code></td><td>线程安全队列</td><td>-</td><td>-</td><td>先进先出</td><td>内部带锁，用于线程间数据传递</td></tr><tr><td><code>multiprocessing.Lock</code></td><td>进程锁</td><td>是</td><td>否</td><td>非公平</td><td>用于进程间同步的锁</td></tr><tr><td><code>asyncio.Lock</code></td><td>异步锁</td><td>是</td><td>否</td><td>-</td><td>用于协程间的同步</td></tr></tbody></table><h5 id="互斥锁-Lock"><a href="#互斥锁-Lock" class="headerlink" title="互斥锁(Lock)"></a>互斥锁(Lock)</h5><p>互斥锁是最基本的锁类型，它确保同一时刻只有一个线程可以访问受保护的资源。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> concurrent</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line">lock = threading.Lock()</span><br><span class="line">shared_data = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shared_resource</span>(<span class="params">thread_id: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="string">"""访问共享资源的函数</span></span><br><span class="line"><span class="string">    Args:thread_id: 线程ID，用于标识不同线程</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 尝试获取锁</span></span><br><span class="line">    <span class="keyword">if</span> lock.acquire(timeout=<span class="number">1</span>):  <span class="comment"># 添加超时参数，防止无限等待</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f"线程<span class="subst">{thread_id}</span>获取锁"</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">global</span> shared_data</span><br><span class="line">            <span class="comment"># 读取-修改-写入操作需要原子性保护</span></span><br><span class="line">            current = shared_data</span><br><span class="line">            time.sleep(<span class="number">0.1</span>)  <span class="comment"># 模拟处理延时，增加竞争概率</span></span><br><span class="line">            shared_data = current + <span class="number">1</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f"线程<span class="subst">{thread_id}</span>修改共享数据，当前值为<span class="subst">{shared_data}</span>"</span>)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="comment"># 释放锁</span></span><br><span class="line">            lock.release()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f"线程<span class="subst">{thread_id}</span>释放锁"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f"线程<span class="subst">{thread_id}</span>获取锁失败"</span>)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shared_resource2</span>(<span class="params">thread_id: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="string">"""访问共享资源的函数</span></span><br><span class="line"><span class="string">    使用with语句，自动释放锁简化代码</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">with</span> lock:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f"线程<span class="subst">{thread_id}</span>获取锁"</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">global</span> shared_data</span><br><span class="line">            <span class="comment"># 读取-修改-写入操作需要原子性保护</span></span><br><span class="line">            current = shared_data</span><br><span class="line">            time.sleep(<span class="number">0.1</span>)  <span class="comment"># 模拟处理延时，增加竞争概率</span></span><br><span class="line">            shared_data = current + <span class="number">1</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f"线程<span class="subst">{thread_id}</span>修改共享数据，当前值为<span class="subst">{shared_data}</span>"</span>)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f"线程<span class="subst">{thread_id}</span>释放锁"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 使用线程池创建多个线程</span></span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">10</span>) <span class="keyword">as</span> executor:</span><br><span class="line">        futures = [executor.submit(shared_resource, i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>)]</span><br><span class="line">        <span class="comment"># 等待所有线程完成</span></span><br><span class="line">        concurrent.futures.wait(futures)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"最终共享数据值为<span class="subst">{shared_data}</span>"</span>)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th>Lock 方法</th><th>描述</th><th>参数</th><th>返回值</th></tr></thead><tbody><tr><td><code>acquire(blocking=True, timeout=-1)</code></td><td>获取锁</td><td>blocking: 是否阻塞, timeout: 超时时间(秒)</td><td>布尔值，表示是否获取成功</td></tr><tr><td><code>release()</code></td><td>释放锁</td><td>无</td><td>无，如果当前线程未持有锁则抛出 RuntimeError</td></tr><tr><td><code>locked()</code></td><td>检查锁状态</td><td>无</td><td>布尔值，表示锁是否被某个线程持有</td></tr><tr><td><code>__enter__()</code></td><td>支持 with 语句</td><td>无</td><td>锁对象自身</td></tr><tr><td><code>__exit__()</code></td><td>with 语句退出时调用</td><td>异常信息</td><td>无，自动释放锁</td></tr></tbody></table><h5 id="可重入锁-RLock"><a href="#可重入锁-RLock" class="headerlink" title="可重入锁(RLock)"></a>可重入锁(RLock)</h5><p>可重入锁允许同一个线程多次获取该锁，而不会导致自我死锁。这在递归调用或者嵌套加锁场景中特别有用。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment">## 创建可重入锁</span></span><br><span class="line">rlock = threading.RLock()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 嵌套列表数据结构</span></span><br><span class="line">data = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_data</span>(<span class="params">item, depth: <span class="built_in">int</span> = <span class="number">0</span></span>):</span><br><span class="line">    <span class="string">"""递归处理数据</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        item: 要处理的数据项，可以是列表或单个元素</span></span><br><span class="line"><span class="string">        depth: 当前递归深度，用于缩进显示</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 获取锁</span></span><br><span class="line">    rlock.acquire()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 创建缩进效果，增强可读性</span></span><br><span class="line">        indent = <span class="string">" "</span> * depth * <span class="number">2</span>  <span class="comment"># 增加缩进量使层次更明显</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 打印当前处理的数据项和深度</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f'<span class="subst">{indent}</span>线程 <span class="subst">{threading.current_thread().name}</span> 处理: <span class="subst">{item}</span> (深度: <span class="subst">{depth}</span>)'</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 递归处理逻辑</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(item, <span class="built_in">list</span>):</span><br><span class="line">            <span class="comment"># 列表节点处理 - 继续向下递归</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f'<span class="subst">{indent}</span>├── 发现列表，开始遍历子元素...'</span>)</span><br><span class="line">            <span class="keyword">for</span> i, sub_item <span class="keyword">in</span> <span class="built_in">enumerate</span>(item):</span><br><span class="line">                <span class="comment"># 显示子项的索引，增强结构可视化</span></span><br><span class="line">                prefix = <span class="string">"└── "</span> <span class="keyword">if</span> i == <span class="built_in">len</span>(item) - <span class="number">1</span> <span class="keyword">else</span> <span class="string">"├── "</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f'<span class="subst">{indent}</span><span class="subst">{prefix}</span>处理子项 <span class="subst">{i+<span class="number">1</span>}</span>/<span class="subst">{<span class="built_in">len</span>(item)}</span>: <span class="subst">{sub_item}</span>'</span>)</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 递归调用，这里会再次获取同一个锁</span></span><br><span class="line">                process_data(sub_item, depth + <span class="number">1</span>)</span><br><span class="line">                time.sleep(<span class="number">0.1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 叶子节点处理 - 递归终止条件</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f'<span class="subst">{indent}</span>└── 发现元素，进行处理...'</span>)</span><br><span class="line">            time.sleep(<span class="number">0.5</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f'<span class="subst">{indent}</span>    处理结果: <span class="subst">{item * <span class="number">2</span>}</span>'</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="comment"># 释放锁</span></span><br><span class="line">        rlock.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment">## 创建多个线程访问嵌套数据</span></span><br><span class="line">    threads = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        <span class="comment"># 每个线程处理完整的数据结构</span></span><br><span class="line">        t = threading.Thread(name=<span class="string">f"Thread-<span class="subst">{i}</span>"</span>, target=process_data, args=(data,))</span><br><span class="line">        threads.append(t)</span><br><span class="line">        t.start()</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)  <span class="comment"># 错开线程启动时间</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">## 等待所有线程结束</span></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.join()</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"所有线程都结束了"</span>)</span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th>RLock 方法</th><th>描述</th><th>与 Lock 的区别</th></tr></thead><tbody><tr><td><code>acquire(blocking=True, timeout=-1)</code></td><td>获取锁</td><td>记录获取线程 ID 和次数</td></tr><tr><td><code>release()</code></td><td>释放锁</td><td>计数器减 1，只有为 0 时才真正释放</td></tr><tr><td><code>_is_owned()</code></td><td>检查当前线程是否持有锁</td><td>Lock 没有此方法</td></tr></tbody></table><blockquote><p>💡 <strong>使用建议</strong>：一般推荐使用 RLock 而非 Lock，因为它更安全、更灵活，即使在不需要重入功能的场景下也不会有明显性能损失。</p></blockquote><h5 id="条件变量-Condition-根据条件控制锁"><a href="#条件变量-Condition-根据条件控制锁" class="headerlink" title="条件变量(Condition) - 根据条件控制锁"></a>条件变量(Condition) - 根据条件控制锁</h5><p>条件变量是一种高级的 <code>同步原语(同步原语就是让多个线程能够"和谐相处"的机制)</code>，它允许线程等待特定条件满足后再继续执行。条件变量内部包含一个锁，用于控制对共享状态的访问。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Any</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Buffer</span>:</span><br><span class="line">    <span class="string">"""线程安全的缓冲区，使用条件变量控制生产者消费者模型"""</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, max_size: <span class="built_in">int</span> = <span class="number">5</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">"""初始化缓冲区"""</span></span><br><span class="line">        <span class="variable language_">self</span>.buffer: <span class="type">List</span>[<span class="type">Any</span>] = []  <span class="comment"># 共享数据缓冲区</span></span><br><span class="line">        <span class="variable language_">self</span>.max_size: <span class="built_in">int</span> = max_size  <span class="comment"># 最大容量</span></span><br><span class="line">        <span class="comment"># 创建条件变量，基于RLock</span></span><br><span class="line">        <span class="variable language_">self</span>.condition: threading.Condition = threading.Condition()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">produce</span>(<span class="params">self, item: <span class="type">Any</span>, producer_id: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">"""生产者方法，向缓冲区添加数据"""</span></span><br><span class="line">        <span class="comment"># 使用条件变量的with语句自动获取和释放锁</span></span><br><span class="line">        <span class="keyword">with</span> <span class="variable language_">self</span>.condition:</span><br><span class="line">            <span class="comment"># 当缓冲区已满时，等待消费者处理</span></span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.buffer) &gt;= <span class="variable language_">self</span>.max_size:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f"生产者 <span class="subst">{producer_id}</span>: 缓冲区已满，等待消费者..."</span>)</span><br><span class="line">                <span class="comment"># 等待唤醒通知，自动释放锁，让其他线程能访问缓冲区</span></span><br><span class="line">                <span class="variable language_">self</span>.condition.wait()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 添加数据到缓冲区</span></span><br><span class="line">            <span class="variable language_">self</span>.buffer.append(item)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f"生产者 <span class="subst">{producer_id}</span>: 添加 <span class="subst">{item}</span> 到缓冲区，当前大小: <span class="subst">{<span class="built_in">len</span>(self.buffer)}</span>"</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 通知所有等待的消费者有新数据可用</span></span><br><span class="line">            <span class="variable language_">self</span>.condition.notify_all()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">consume</span>(<span class="params">self, consumer_id: <span class="built_in">int</span></span>) -&gt; <span class="type">Any</span>:</span><br><span class="line">        <span class="string">"""消费者方法，从缓冲区获取数据"""</span></span><br><span class="line">        <span class="keyword">with</span> <span class="variable language_">self</span>.condition:</span><br><span class="line">            <span class="comment"># 当缓冲区为空时，等待生产者添加数据</span></span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.buffer) == <span class="number">0</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f"消费者 <span class="subst">{consumer_id}</span>: 缓冲区为空，等待生产者..."</span>)</span><br><span class="line">                <span class="variable language_">self</span>.condition.wait()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 从缓冲区取出数据</span></span><br><span class="line">            item = <span class="variable language_">self</span>.buffer.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f"消费者 <span class="subst">{consumer_id}</span>: 从缓冲区取出 <span class="subst">{item}</span>，当前大小: <span class="subst">{<span class="built_in">len</span>(self.buffer)}</span>"</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 通知所有等待的生产者缓冲区有空间</span></span><br><span class="line">            <span class="variable language_">self</span>.condition.notify_all()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">producer_task</span>(<span class="params">buffer: Buffer, producer_id: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="string">"""生产者任务"""</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):  <span class="comment"># 生产10个产品</span></span><br><span class="line">        item = <span class="string">f"产品-<span class="subst">{producer_id}</span>-<span class="subst">{i}</span>"</span></span><br><span class="line">        <span class="comment"># 模拟生产时间</span></span><br><span class="line">        time.sleep(random.uniform(<span class="number">0.1</span>, <span class="number">0.5</span>))  </span><br><span class="line">        buffer.produce(item, producer_id)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">consumer_task</span>(<span class="params">buffer: Buffer, consumer_id: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="string">"""消费者任务"""</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):  <span class="comment"># 每个消费者消费7个产品</span></span><br><span class="line">        <span class="comment"># 模拟消费时间</span></span><br><span class="line">        time.sleep(random.uniform(<span class="number">0.2</span>, <span class="number">0.7</span>))  </span><br><span class="line">        item = buffer.consume(consumer_id)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f"消费者 <span class="subst">{consumer_id}</span> 处理 <span class="subst">{item}</span>"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>() -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="string">"""主函数，创建并启动生产者和消费者线程"""</span></span><br><span class="line">    <span class="comment"># 创建共享缓冲区</span></span><br><span class="line">    shared_buffer = Buffer(max_size=<span class="number">3</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创建生产者和消费者线程</span></span><br><span class="line">    producer_threads = [</span><br><span class="line">        threading.Thread(target=producer_task, args=(shared_buffer, i), name=<span class="string">f"Producer-<span class="subst">{i}</span>"</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)  <span class="comment"># 3个生产者</span></span><br><span class="line">    ]</span><br><span class="line">    </span><br><span class="line">    consumer_threads = [</span><br><span class="line">        threading.Thread(target=consumer_task, args=(shared_buffer, i), name=<span class="string">f"Consumer-<span class="subst">{i}</span>"</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)  <span class="comment"># 3个消费者</span></span><br><span class="line">    ]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 启动所有线程</span></span><br><span class="line">    all_threads = producer_threads + consumer_threads</span><br><span class="line">    <span class="keyword">for</span> thread <span class="keyword">in</span> all_threads:</span><br><span class="line">        thread.start()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 等待所有线程完成</span></span><br><span class="line">    <span class="keyword">for</span> thread <span class="keyword">in</span> all_threads:</span><br><span class="line">        thread.join()</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"所有生产和消费任务已完成"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th>Condition 方法</th><th>描述</th><th>参数</th><th>注意事项</th></tr></thead><tbody><tr><td><code>__init__(lock=None)</code></td><td>初始化条件变量</td><td>lock: 可选的 Lock 或 RLock</td><td>不指定则创建 RLock</td></tr><tr><td><code>acquire(*args)</code></td><td>获取底层锁</td><td>同底层锁的 acquire 方法</td><td>一般通过 with 语句使用</td></tr><tr><td><code>release()</code></td><td>释放底层锁</td><td>无</td><td>一般通过 with 语句自动释放</td></tr><tr><td><code>wait(timeout=None)</code></td><td>等待条件</td><td>timeout: 超时时间(秒)</td><td>调用前必须已获得锁</td></tr><tr><td><code>wait_for(predicate, timeout=None)</code></td><td>等待直到条件为真</td><td>predicate: 条件函数, timeout: 超时时间</td><td>简化循环等待模式</td></tr><tr><td><code>notify(n=1)</code></td><td>唤醒 n 个等待的线程</td><td>n: 要唤醒的线程数</td><td>不会立即释放锁</td></tr><tr><td><code>notify_all()</code></td><td>唤醒所有等待的线程</td><td>无</td><td>适用于广播通知</td></tr></tbody></table><blockquote><p>⚠️ <strong>使用注意</strong>：</p><ol><li>调用 <code>wait()</code> 会释放锁，允许其他线程修改条件状态</li><li>使用 <code>wait_for()</code> 可以避免虚假唤醒问题</li><li>调用 <code>notify()</code> 后锁不会立即释放，需要当前线程退出 with 块</li><li>使用 <code>notify_all()</code> 而非 <code>notify()</code> 可以避免信号丢失问题</li></ol></blockquote><h5 id="信号量-Semaphore-控制并发数量"><a href="#信号量-Semaphore-控制并发数量" class="headerlink" title="信号量(Semaphore) - 控制并发数量"></a>信号量(Semaphore) - 控制并发数量</h5><p>信号量是一种计数器，用于控制同时访问特定资源的线程数量，常用于限制并发访问数。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="comment">## 创建信号量，限制最多三个线程同时访问资源</span></span><br><span class="line">pool_semaphore = threading.Semaphore(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 模拟优先的资源池</span></span><br><span class="line">resource_pool = [<span class="string">'资源A'</span>, <span class="string">'资源B'</span>, <span class="string">'资源C'</span>]</span><br><span class="line">resource_in_use = {}  <span class="comment"># 跟踪资源使用情况</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 保护资源分配的锁</span></span><br><span class="line">resource_lock = threading.RLock()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">worker</span>(<span class="params">worker_id: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="string">"""工作线程函数，模拟使用受限资源"""</span></span><br><span class="line">    <span class="comment"># 尝试获取信号量</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"工作线程 <span class="subst">{worker_id}</span> 等待获取资源..."</span>)</span><br><span class="line">    <span class="keyword">with</span> pool_semaphore:  <span class="comment"># 等同于acquire()和finally中release()</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f"工作线程 <span class="subst">{worker_id}</span> 获取资源信号量"</span>)</span><br><span class="line">        <span class="keyword">with</span> resource_lock:</span><br><span class="line">            <span class="comment"># 检查resource_pool中的每个资源，如果该资源不在resource_in_use字典的值中，则认为是可用的</span></span><br><span class="line">            available_resources = [r <span class="keyword">for</span> r <span class="keyword">in</span> resource_pool <span class="keyword">if</span> r <span class="keyword">not</span> <span class="keyword">in</span> resource_in_use.values()]</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> available_resources:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f"工作线程 <span class="subst">{worker_id}</span> 没有找到可用资源，理论上不应该发生！"</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            resource_name = available_resources[<span class="number">0</span>]</span><br><span class="line">            resource_in_use[worker_id] = resource_name  <span class="comment"># 记录资源使用情况</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f"工作线程 <span class="subst">{worker_id}</span> 分配到资源: <span class="subst">{resource_name}</span>, 当前使用情况: <span class="subst">{resource_in_use}</span>"</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 模拟使用资源</span></span><br><span class="line">            work_time = random.uniform(<span class="number">0.5</span>, <span class="number">2.0</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f"工作线程 <span class="subst">{worker_id}</span> 使用资源 <span class="subst">{resource_name}</span> 时间: <span class="subst">{work_time}</span> 秒"</span>)</span><br><span class="line">            time.sleep(work_time)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="comment"># 释放资源</span></span><br><span class="line">            <span class="keyword">with</span> resource_lock:</span><br><span class="line">                released_resource = resource_in_use.pop(worker_id)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f"工作线程 <span class="subst">{worker_id}</span> 释放资源: <span class="subst">{released_resource}</span>, 当前使用情况: <span class="subst">{resource_in_use}</span>"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 创建线程池，并启动三个线程</span></span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">3</span>) <span class="keyword">as</span> executor:</span><br><span class="line">        futures = [executor.submit(worker, i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]</span><br><span class="line">        <span class="keyword">for</span> future <span class="keyword">in</span> futures:</span><br><span class="line">            future.result()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th>Semaphore 方法</th><th>描述</th><th>参数</th><th>返回值</th></tr></thead><tbody><tr><td><code>__init__(value=1)</code></td><td>初始化信号量</td><td>value: 初始计数器值</td><td>无</td></tr><tr><td><code>acquire(blocking=True, timeout=None)</code></td><td>获取信号量</td><td>blocking: 是否阻塞, timeout: 超时时间</td><td>布尔值，表示是否获取成功</td></tr><tr><td><code>release(n=1)</code></td><td>释放信号量</td><td>n: 释放的数量</td><td>无</td></tr><tr><td><code>__enter__()</code></td><td>支持 with 语句</td><td>无</td><td>信号量对象自身</td></tr><tr><td><code>__exit__()</code></td><td>with 语句退出时调用</td><td>异常信息</td><td>无，自动释放信号量</td></tr></tbody></table><h5 id="有界信号量-BoundedSemaphore-详解"><a href="#有界信号量-BoundedSemaphore-详解" class="headerlink" title="有界信号量(BoundedSemaphore)详解"></a>有界信号量(BoundedSemaphore)详解</h5><p>有界信号量是信号量的一个变种，它会检查释放操作是否会导致计数器超过初始值，如果超过则抛出异常。这可以帮助检测程序中的信号量使用错误。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment">## 创建有界信号量，初始值为3</span></span><br><span class="line">bounded_semaphore = threading.BoundedSemaphore(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">semaphore_demo</span>():</span><br><span class="line">    <span class="string">"""演示有界信号量与普通信号量的区别"""</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"获取信号量1次"</span>)</span><br><span class="line">        bounded_semaphore.acquire()</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"获取信号量2次"</span>)</span><br><span class="line">        bounded_semaphore.acquire()</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"获取信号量3次"</span>)</span><br><span class="line">        bounded_semaphore.acquire()</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"信号量已用完，再获取将阻塞"</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 释放全部信号量</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"释放信号量1次"</span>)</span><br><span class="line">        bounded_semaphore.release()</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"释放信号量2次"</span>)</span><br><span class="line">        bounded_semaphore.release()</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"释放信号量3次"</span>)</span><br><span class="line">        bounded_semaphore.release()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 超出初始值的释放将抛出异常</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"尝试额外释放一次"</span>)</span><br><span class="line">            bounded_semaphore.release()  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"这一行不会执行"</span>)</span><br><span class="line">        <span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f"捕获预期异常: <span class="subst">{e}</span>"</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f"意外错误: <span class="subst">{e}</span>"</span>)</span><br><span class="line"></span><br><span class="line">semaphore_demo()</span><br></pre></td></tr></tbody></table></figure><blockquote><p>🔍 <strong>Semaphore vs BoundedSemaphore</strong>：</p><ul><li><code>Semaphore</code> 允许无限制地调用 <code>release()</code>，即使计数器超过初始值</li><li><code>BoundedSemaphore</code> 在计数器超过初始值时会抛出 <code>ValueError</code> 异常</li><li>生产环境推荐使用 <code>BoundedSemaphore</code>，或安全的使用 with 语句，保证程序安全</li></ul></blockquote><h5 id="事件对象-Event"><a href="#事件对象-Event" class="headerlink" title="事件对象(Event)"></a>事件对象(Event)</h5><p>事件对象是最简单的线程通信机制之一，它允许一个线程发送信号给其他线程，适合简单的 “一次性通知” 场景。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="comment">## 创建事件对象</span></span><br><span class="line">start_event = threading.Event()</span><br><span class="line">results: <span class="type">List</span>[<span class="built_in">str</span>] = []</span><br><span class="line">results_lock = threading.RLock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">worker</span>(<span class="params">worker_id:<span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="string">"""工作线程函数，等待开始信号"""</span></span><br><span class="line">    prep_time = random.uniform(<span class="number">0.5</span>, <span class="number">1.5</span>)</span><br><span class="line">    time.sleep(prep_time)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"工作线程<span class="subst">{worker_id}</span>准备完毕，等待开始信号"</span>)</span><br><span class="line">    <span class="comment"># 等待开始信号</span></span><br><span class="line">    start_event.wait()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 收到信号开始工作</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"工作线程<span class="subst">{worker_id}</span>开始工作"</span>)</span><br><span class="line">    work_time = random.uniform(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    time.sleep(work_time)</span><br><span class="line">    <span class="comment"># 记录结果</span></span><br><span class="line">    <span class="keyword">with</span> results_lock:</span><br><span class="line">        results.append(<span class="string">f"工作线程<span class="subst">{worker_id}</span>完成工作"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"工作线程<span class="subst">{worker_id}</span>完成工作，用时<span class="subst">{work_time:<span class="number">.2</span>f}</span>秒"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 创建线程池</span></span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">3</span>) <span class="keyword">as</span> executor:</span><br><span class="line">        futures = [executor.submit(worker, i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]</span><br><span class="line">        <span class="comment"># 等待所有线程准备完毕</span></span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        <span class="comment"># 发送开始信号</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"发送开始信号"</span>)</span><br><span class="line">        start_event.<span class="built_in">set</span>()</span><br><span class="line">        <span class="comment"># 等待所有线程完成工作</span></span><br><span class="line">        <span class="keyword">for</span> future <span class="keyword">in</span> futures:</span><br><span class="line">            future.result()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"所有工作线程完成"</span>)</span><br><span class="line">    <span class="built_in">print</span>(results)</span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th>Event 方法</th><th>描述</th><th>参数</th><th>返回值</th></tr></thead><tbody><tr><td><code>set()</code></td><td>设置事件，唤醒所有等待的线程</td><td>无</td><td>无</td></tr><tr><td><code>clear()</code></td><td>清除事件标志</td><td>无</td><td>无</td></tr><tr><td><code>is_set()</code></td><td>判断事件是否已设置</td><td>无</td><td>布尔值</td></tr><tr><td><code>wait(timeout=None)</code></td><td>等待事件被设置</td><td>timeout: 超时时间</td><td>如果超时返回 False，否则返回 True</td></tr></tbody></table><blockquote><p>💡 <strong>使用场景</strong>：</p><ul><li>启动信号：所有线程等待统一开始</li><li>停止信号：通知所有线程停止工作</li><li>一次性通知：当某条件满足时通知等待线程</li></ul></blockquote><h5 id="栅栏对象-Barrier"><a href="#栅栏对象-Barrier" class="headerlink" title="栅栏对象(Barrier)"></a>栅栏对象(Barrier)</h5><p>栅栏是一种同步原语，它要求固定数量的线程都到达栅栏点后，才允许所有线程继续执行。这对于分阶段任务的同步特别有用。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment">## 定义参与方数量</span></span><br><span class="line">num_parties = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 创建栅栏对象，当4个线程都到达时才继续</span></span><br><span class="line">barrier = threading.Barrier(num_parties)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">worker</span>(<span class="params">worker_id</span>):</span><br><span class="line">    <span class="string">"""工作线程函数，模拟多阶段工作</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        worker_id: 工作线程ID</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"工作线程 <span class="subst">{worker_id}</span> 开始第一阶段工作"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 模拟第一阶段工作</span></span><br><span class="line">    work_time = random.uniform(<span class="number">0.5</span>, <span class="number">2.0</span>)</span><br><span class="line">    time.sleep(work_time)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"工作线程 <span class="subst">{worker_id}</span> 完成第一阶段，用时 <span class="subst">{work_time:<span class="number">.2</span>f}</span> 秒，等待其他线程..."</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 等待所有线程完成第一阶段</span></span><br><span class="line">        barrier.wait()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f"工作线程 <span class="subst">{worker_id}</span> 通过第一个栅栏，开始第二阶段"</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 模拟第二阶段工作</span></span><br><span class="line">        work_time = random.uniform(<span class="number">0.5</span>, <span class="number">2.0</span>)</span><br><span class="line">        time.sleep(work_time)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f"工作线程 <span class="subst">{worker_id}</span> 完成第二阶段，用时 <span class="subst">{work_time:<span class="number">.2</span>f}</span> 秒，等待其他线程..."</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 等待所有线程完成第二阶段</span></span><br><span class="line">        barrier.wait()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f"工作线程 <span class="subst">{worker_id}</span> 通过第二个栅栏，工作全部完成"</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">except</span> threading.BrokenBarrierError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f"工作线程 <span class="subst">{worker_id}</span> 检测到栅栏被破坏"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 创建工作线程</span></span><br><span class="line">threads = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_parties):</span><br><span class="line">    t = threading.Thread(target=worker, args=(i,))</span><br><span class="line">    threads.append(t)</span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line"><span class="comment">## 等待所有线程完成</span></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">    t.join()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"所有工作阶段已完成"</span>)</span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th>Barrier 方法</th><th>描述</th><th>参数</th><th>返回值</th></tr></thead><tbody><tr><td><code>__init__(parties, action=None, timeout=None)</code></td><td>初始化栅栏</td><td>parties: 参与方数量, action: 所有线程到达时执行的回调, timeout: 等待超时</td><td>无</td></tr><tr><td><code>wait(timeout=None)</code></td><td>等待所有参与方到达</td><td>timeout: 覆盖默认超时时间</td><td>线程的到达序号(0 ~ n-1)</td></tr><tr><td><code>reset()</code></td><td>将栅栏重置到初始状态</td><td>无</td><td>无，正在等待的线程会抛出 BrokenBarrierError</td></tr><tr><td><code>abort()</code></td><td>将栅栏置于损坏状态</td><td>无</td><td>无，所有等待线程会抛出 BrokenBarrierError</td></tr><tr><td><code>parties</code></td><td>参与方数量(属性)</td><td>无</td><td>整数</td></tr><tr><td><code>n_waiting</code></td><td>当前等待的线程数(属性)</td><td>无</td><td>整数</td></tr><tr><td><code>broken</code></td><td>栅栏是否处于损坏状态(属性)</td><td>无</td><td>布尔值</td></tr></tbody></table><blockquote><p>⚠️ <strong>注意事项</strong>：</p><ul><li>如果等待超时，栅栏会进入损坏状态</li><li>如果等待时的线程被中断，栅栏也会损坏</li><li>可以通过 <code>reset()</code> 方法重新使用已损坏的栅栏</li></ul></blockquote><h5 id="线程安全队列-Queue"><a href="#线程安全队列-Queue" class="headerlink" title="线程安全队列(Queue)"></a>线程安全队列(Queue)</h5><p><code>queue</code> 模块提供的 <code>Queue</code> 类是一个线程安全的队列实现，通常用于线程间的数据传递和任务分发。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="comment">## 创建线程安全队列</span></span><br><span class="line">task_queue = queue.Queue(maxsize=<span class="number">10</span>)  <span class="comment"># 最多容纳10个任务</span></span><br><span class="line">result_queue = queue.Queue()  <span class="comment"># 结果队列，无大小限制</span></span><br><span class="line"><span class="comment">## 用于通知工作线程结束的标志</span></span><br><span class="line">exit_flag = threading.Event()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">producer</span>():</span><br><span class="line">    <span class="string">"""生产者线程，产生任务"""</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">        task = <span class="string">f"任务-<span class="subst">{i}</span>"</span></span><br><span class="line">        <span class="comment"># 将任务放入队列</span></span><br><span class="line">        task_queue.put(task)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f"生产者: 添加 <span class="subst">{task}</span> 到队列，当前队列大小: <span class="subst">{task_queue.qsize()}</span>"</span>)</span><br><span class="line">        time.sleep(random.uniform(<span class="number">0.1</span>, <span class="number">0.3</span>))  <span class="comment"># 随机延迟</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 添加结束标记</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"生产者: 所有任务已产生，设置退出标志"</span>)</span><br><span class="line">    exit_flag.<span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">consumer</span>(<span class="params">consumer_id</span>):</span><br><span class="line">    <span class="string">"""消费者线程，处理任务"""</span></span><br><span class="line">    <span class="comment"># 直到所有任务都处理完毕或有新任务到来</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> exit_flag.is_set() <span class="keyword">or</span> <span class="keyword">not</span> task_queue.empty():</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 从队列获取任务，最多等待1秒</span></span><br><span class="line">            task = task_queue.get(timeout=<span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 模拟处理任务</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f"消费者 <span class="subst">{consumer_id}</span>: 开始处理 <span class="subst">{task}</span>"</span>)</span><br><span class="line">            process_time = random.uniform(<span class="number">0.5</span>, <span class="number">1.5</span>)</span><br><span class="line">            time.sleep(process_time)</span><br><span class="line">            <span class="comment"># 将处理结果放入结果队列</span></span><br><span class="line">            result = <span class="string">f"结果-<span class="subst">{task}</span>-耗时<span class="subst">{process_time:<span class="number">.2</span>f}</span>秒"</span></span><br><span class="line">            result_queue.put((consumer_id, result))</span><br><span class="line">            <span class="comment"># 标记任务完成</span></span><br><span class="line">            task_queue.task_done()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f"消费者 <span class="subst">{consumer_id}</span>: 完成处理 <span class="subst">{task}</span>"</span>)</span><br><span class="line">        <span class="keyword">except</span> queue.Empty:</span><br><span class="line">            <span class="comment"># 队列为空且设置了退出标志时结束循环</span></span><br><span class="line">            <span class="keyword">if</span> exit_flag.is_set():</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f"消费者 <span class="subst">{consumer_id}</span>: 队列暂时为空，等待任务..."</span>)</span><br><span class="line">            time.sleep(<span class="number">0.5</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"消费者 <span class="subst">{consumer_id}</span>: 退出"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 创建生产者线程和消费者线程</span></span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">4</span>) <span class="keyword">as</span> executor:</span><br><span class="line">        <span class="comment"># 创建生产者线程</span></span><br><span class="line">        producers = [executor.submit(producer) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)]</span><br><span class="line">        <span class="comment"># 创建消费者线程</span></span><br><span class="line">        consumers = [executor.submit(consumer, i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 等待所有线程结束</span></span><br><span class="line">        all_futures = producers + consumers</span><br><span class="line">        <span class="keyword">for</span> future <span class="keyword">in</span> all_futures:</span><br><span class="line">            future.result()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 打印结果队列中的所有结果</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\n处理结果:"</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> result_queue.empty():</span><br><span class="line">        consumer_id, result = result_queue.get()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f"消费者 <span class="subst">{consumer_id}</span> 的结果: <span class="subst">{result}</span>"</span>)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th>Queue 方法/属性</th><th>描述</th><th>参数</th><th>返回值/特性</th></tr></thead><tbody><tr><td><code>__init__(maxsize=0)</code></td><td>初始化队列</td><td>maxsize: 队列最大大小，0 表示无限</td><td>无</td></tr><tr><td><code>put(item, block=True, timeout=None)</code></td><td>放入元素</td><td>item: 元素, block: 是否阻塞, timeout: 超时时间</td><td>无，队列满时可能阻塞或抛出 Full 异常</td></tr><tr><td><code>get(block=True, timeout=None)</code></td><td>获取元素</td><td>block: 是否阻塞, timeout: 超时时间</td><td>队列元素，队列空时可能阻塞或抛出 Empty 异常</td></tr><tr><td><code>task_done()</code></td><td>标记任务完成</td><td>无</td><td>无</td></tr><tr><td><code>join()</code></td><td>等待队列中所有任务处理完成</td><td>无</td><td>无</td></tr><tr><td><code>qsize()</code></td><td>返回队列大小</td><td>无</td><td>整数</td></tr><tr><td><code>empty()</code></td><td>检查队列是否为空</td><td>无</td><td>布尔值</td></tr><tr><td><code>full()</code></td><td>检查队列是否已满</td><td>无</td><td>布尔值</td></tr><tr><td><code>put_nowait(item)</code></td><td>非阻塞版本的 put</td><td>item: 元素</td><td>无，队列满时抛出 Full 异常</td></tr><tr><td><code>get_nowait()</code></td><td>非阻塞版本的 get</td><td>无</td><td>队列元素，队列空时抛出 Empty 异常</td></tr></tbody></table><blockquote><p>💡 <strong>Queue 变种</strong>：</p><ul><li><code>queue.LifoQueue</code>: 后进先出队列(栈)</li><li><code>queue.PriorityQueue</code>: 优先级队列，元素为(优先级, 数据)元组</li><li><code>queue.SimpleQueue</code>: 简单的无界队列，不支持 task_done 和 join</li></ul></blockquote><h5 id="死锁问题分析与解决"><a href="#死锁问题分析与解决" class="headerlink" title="死锁问题分析与解决"></a>死锁问题分析与解决</h5><p>死锁是指两个或多个线程互相等待对方释放资源，导致程序无法继续执行的情况。</p><h6 id="死锁示例"><a href="#死锁示例" class="headerlink" title="死锁示例"></a>死锁示例</h6><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment">## 创建两个锁</span></span><br><span class="line">lock_1 = threading.Lock()</span><br><span class="line">lock_2 = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task1</span>():</span><br><span class="line">    <span class="string">"""第一个任务，先获取lock_1，再获取lock_2"""</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"任务1开始尝试获取锁..."</span>)</span><br><span class="line">    lock_1.acquire()  <span class="comment"># 获取1号锁</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"任务1获取到lock_1"</span>)</span><br><span class="line">    time.sleep(<span class="number">0.5</span>)  <span class="comment"># 等待一会，让任务2有机会获取lock_2</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"任务1尝试获取lock_2"</span>)</span><br><span class="line">    lock_2.acquire()  <span class="comment"># 尝试获取2号锁，但可能永远阻塞于此</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"任务1同时获取了两把锁"</span>)</span><br><span class="line">        <span class="comment"># 使用两把锁保护的代码</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="comment"># 释放锁</span></span><br><span class="line">        lock_2.release()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"任务1释放了lock_2"</span>)</span><br><span class="line">        lock_1.release()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"任务1释放了lock_1"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task2</span>():</span><br><span class="line">    <span class="string">"""第二个任务，先获取lock_2，再获取lock_1"""</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"任务2开始尝试获取锁..."</span>)</span><br><span class="line">    lock_2.acquire()  <span class="comment"># 获取2号锁</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"任务2获取到lock_2"</span>)</span><br><span class="line">    time.sleep(<span class="number">0.5</span>)  <span class="comment"># 等待一会</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"任务2尝试获取lock_1"</span>)</span><br><span class="line">    lock_1.acquire()  <span class="comment"># 尝试获取1号锁，但可能永远阻塞于此</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"任务2同时获取了两把锁"</span>)</span><br><span class="line">        <span class="comment"># 使用两把锁保护的代码</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="comment"># 释放锁</span></span><br><span class="line">        lock_1.release()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"任务2释放了lock_1"</span>)</span><br><span class="line">        lock_2.release()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"任务2释放了lock_2"</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment">## 创建两个线程</span></span><br><span class="line">    t1 = threading.Thread(target=task1)</span><br><span class="line">    t2 = threading.Thread(target=task2)</span><br><span class="line"></span><br><span class="line">    <span class="comment">## 启动线程</span></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment">## 等待一段时间后检查是否发生死锁</span></span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">## 检查线程是否还活着</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"线程1状态: <span class="subst">{<span class="string">'活跃'</span> <span class="keyword">if</span> t1.is_alive() <span class="keyword">else</span> <span class="string">'已结束'</span>}</span>"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"线程2状态: <span class="subst">{<span class="string">'活跃'</span> <span class="keyword">if</span> t2.is_alive() <span class="keyword">else</span> <span class="string">'已结束'</span>}</span>"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> t1.is_alive() <span class="keyword">and</span> t2.is_alive():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"检测到可能的死锁情况!"</span>)</span><br></pre></td></tr></tbody></table></figure><blockquote><p>⚠️ <strong>死锁的四个必要条件</strong>：</p><ol><li><strong>互斥条件</strong>：资源不能被共享，一次只能被一个线程使用</li><li><strong>请求与保持条件</strong>：线程已获得资源，但又提出新的资源请求</li><li><strong>不剥夺条件</strong>：线程已获得的资源不能强制被剥夺</li><li><strong>循环等待条件</strong>：线程之间形成头尾相接的循环等待资源关系</li></ol></blockquote><h6 id="死锁解决方案"><a href="#死锁解决方案" class="headerlink" title="死锁解决方案"></a>死锁解决方案</h6><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment">## 创建两个锁</span></span><br><span class="line">lock_1 = threading.Lock()</span><br><span class="line">lock_2 = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">acquire_locks_safe</span>(<span class="params">lock_a, lock_b, thread_name</span>):</span><br><span class="line">    <span class="string">"""安全地获取两个锁，使用超时机制避免死锁</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        lock_a: 第一个锁</span></span><br><span class="line"><span class="string">        lock_b: 第二个锁</span></span><br><span class="line"><span class="string">        thread_name: 线程名称</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        bool: 是否成功获取两个锁</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 尝试获取第一个锁</span></span><br><span class="line">        got_lock_a = lock_a.acquire(timeout=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> got_lock_a:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f"<span class="subst">{thread_name}</span>: 获取到第一个锁"</span>)</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># 尝试获取第二个锁</span></span><br><span class="line">                got_lock_b = lock_b.acquire(timeout=<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">if</span> got_lock_b:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f"<span class="subst">{thread_name}</span>: 获取到第二个锁"</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span>  <span class="comment"># 成功获取两个锁</span></span><br><span class="line">                <span class="comment"># 获取第二个锁失败，释放第一个锁，避免死锁</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f"<span class="subst">{thread_name}</span>: 获取第二个锁失败，释放第一个锁并重试"</span>)</span><br><span class="line">            <span class="keyword">finally</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> got_lock_b:</span><br><span class="line">                    lock_a.release()</span><br><span class="line">                    <span class="comment"># 短暂休眠，减少活锁可能性</span></span><br><span class="line">                    time.sleep(<span class="number">0.1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f"<span class="subst">{thread_name}</span>: 获取第一个锁失败，重试"</span>)</span><br><span class="line">            time.sleep(<span class="number">0.1</span>)  <span class="comment"># 短暂休眠避免CPU忙等</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task1_fixed</span>():</span><br><span class="line">    <span class="string">"""修复死锁的任务1 - 使用安全获取锁函数"""</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"任务1开始执行..."</span>)</span><br><span class="line">    <span class="keyword">if</span> acquire_locks_safe(lock_1, lock_2, <span class="string">"任务1"</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"任务1: 同时持有两把锁，执行关键代码"</span>)</span><br><span class="line">            time.sleep(<span class="number">0.5</span>)  <span class="comment"># 模拟工作</span></span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="comment"># 释放锁</span></span><br><span class="line">            lock_2.release()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"任务1: 释放lock_2"</span>)</span><br><span class="line">            lock_1.release()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"任务1: 释放lock_1"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"任务1: 无法获取所需的锁，任务取消"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task2_fixed</span>():</span><br><span class="line">    <span class="string">"""修复死锁的任务2 - 使用一致的锁获取顺序"""</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"任务2开始执行..."</span>)</span><br><span class="line">    <span class="comment"># 按与任务1相同的顺序获取锁，避免死锁</span></span><br><span class="line">    <span class="keyword">if</span> acquire_locks_safe(lock_1, lock_2, <span class="string">"任务2"</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"任务2: 同时持有两把锁，执行关键代码"</span>)</span><br><span class="line">            time.sleep(<span class="number">0.5</span>)  <span class="comment"># 模拟工作</span></span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="comment"># 释放锁</span></span><br><span class="line">            lock_2.release()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"任务2: 释放lock_2"</span>)</span><br><span class="line">            lock_1.release()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"任务2: 释放lock_1"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"任务2: 无法获取所需的锁，任务取消"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 创建两个线程</span></span><br><span class="line">t1 = threading.Thread(target=task1_fixed)</span><br><span class="line">t2 = threading.Thread(target=task2_fixed)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 启动线程</span></span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line"></span><br><span class="line"><span class="comment">## 等待线程结束</span></span><br><span class="line">t1.join()</span><br><span class="line">t2.join()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"所有线程执行完毕，没有死锁"</span>)</span><br></pre></td></tr></tbody></table></figure><blockquote><p>🛠️ <strong>死锁预防方法</strong>：</p><ol><li><strong>按顺序获取锁</strong>：使所有线程按相同顺序获取锁</li><li><strong>超时机制</strong>：使用 <code>acquire(timeout=N)</code> 设置获取锁的超时时间</li><li><strong>一次性获取所有锁</strong>：创建更高级别的锁来同时获取多个锁</li><li><strong>使用显式资源分级</strong>：为资源分配层级，只允许按层级顺序获取</li><li><strong>避免嵌套锁</strong>：设计简化的锁策略，减少同时持有多个锁的情况</li><li><strong>使用 <code>with</code> 语句</strong>：确保锁在异常情况下也能被释放</li></ol></blockquote><h4 id="原子操作与锁优化"><a href="#原子操作与锁优化" class="headerlink" title="原子操作与锁优化"></a>原子操作与锁优化</h4><p>在并发编程中，原子操作是指不可被中断的操作，它们要么完全执行，要么完全不执行。Python 提供了一些原子操作工具，可以减少对锁的依赖。</p><h5 id="threading-local-对象-线程本地存储"><a href="#threading-local-对象-线程本地存储" class="headerlink" title="threading.local 对象 - 线程本地存储"></a><code>threading.local</code> 对象 - 线程本地存储</h5><p>线程本地存储提供了一种每个线程拥有自己独立数据副本的机制，避免了共享状态带来的并发问题。</p><blockquote><p>我们可以往 threading.local()上挂载对象，这样我们的每一个线程就会有属于自己的独立数据</p></blockquote><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="comment">## 创建线程本地存储对象</span></span><br><span class="line">thread_local_data = threading.local()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_request</span>(<span class="params">request_id: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="string">"""处理请求的工作函数"""</span></span><br><span class="line">    <span class="comment"># 为当前线程设置上下文信息</span></span><br><span class="line">    thread_local_data.user_id = <span class="string">f"user-<span class="subst">{random.randint(<span class="number">1000</span>, <span class="number">9999</span>)}</span>"</span></span><br><span class="line">    thread_local_data.request = request_id</span><br><span class="line">    thread_local_data.start_time = time.time()</span><br><span class="line">    <span class="comment"># 模拟处理请求的各个阶段</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"请求 <span class="subst">{request_id}</span>: 开始处理 [线程: <span class="subst">{threading.current_thread().name}</span>, 用户: <span class="subst">{thread_local_data.user_id}</span>]"</span>)</span><br><span class="line">    process_stage(<span class="string">"验证"</span>)</span><br><span class="line">    process_stage(<span class="string">"处理"</span>)</span><br><span class="line">    process_stage(<span class="string">"响应"</span>)</span><br><span class="line">    <span class="comment"># 计算总处理时间</span></span><br><span class="line">    elapsed = time.time() - thread_local_data.start_time</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"请求 <span class="subst">{request_id}</span>: 完成处理，总耗时 <span class="subst">{elapsed:<span class="number">.2</span>f}</span>秒 [线程: <span class="subst">{threading.current_thread().name}</span>]"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_stage</span>(<span class="params">stage_name: <span class="built_in">str</span></span>):</span><br><span class="line">    <span class="string">"""处理请求的某个阶段"""</span></span><br><span class="line">    <span class="comment"># 访问线程本地变量，无需传递参数</span></span><br><span class="line">    request_id = thread_local_data.request</span><br><span class="line">    user_id = thread_local_data.user_id</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 模拟阶段处理</span></span><br><span class="line">    time.sleep(random.uniform(<span class="number">0.1</span>, <span class="number">0.5</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"请求 <span class="subst">{request_id}</span>: <span class="subst">{stage_name}</span>阶段完成 [用户: <span class="subst">{user_id}</span>]"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">10</span>) <span class="keyword">as</span> executor:</span><br><span class="line">        futures = [executor.submit(process_request, i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">        <span class="keyword">for</span> future <span class="keyword">in</span> futures:</span><br><span class="line">            future.result()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"所有请求处理完成"</span>)</span><br></pre></td></tr></tbody></table></figure><h5 id="functools-lru-cache-带锁的缓存"><a href="#functools-lru-cache-带锁的缓存" class="headerlink" title="functools.lru_cache 带锁的缓存"></a><code>functools.lru_cache</code> 带锁的缓存</h5><p><code>functools.lru_cache</code> 装饰器提供了一个线程安全的缓存机制，当一个函数的计算逻辑十分复杂，我们就可以采用缓存来优化这一点</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># ========== LRU缓存演示 ==========</span></span><br><span class="line"><span class="meta">@functools.lru_cache(<span class="params">maxsize=<span class="number">128</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fibonacci</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="string">"""计算斐波那契数列的第n个数，使用LRU缓存优化性能"""</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> fibonacci(n-<span class="number">1</span>) + fibonacci(n-<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">demonstrate_lru_cache</span>():</span><br><span class="line">    <span class="string">"""演示LRU缓存的效果"""</span></span><br><span class="line">    <span class="comment"># 不使用缓存的计算时间</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fibonacci_no_cache</span>(<span class="params">n</span>):</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        <span class="keyword">return</span> fibonacci_no_cache(n-<span class="number">1</span>) + fibonacci_no_cache(n-<span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line">    n = <span class="number">35</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 测试无缓存版本</span></span><br><span class="line">    start = time.time()</span><br><span class="line">    result1 = fibonacci_no_cache(n)</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"无缓存计算fibonacci(<span class="subst">{n}</span>) = <span class="subst">{result1}</span>，耗时: <span class="subst">{end - start:<span class="number">.4</span>f}</span>秒"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 测试有缓存版本</span></span><br><span class="line">    start = time.time()</span><br><span class="line">    result2 = fibonacci(n)</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"首次使用缓存计算fibonacci(<span class="subst">{n}</span>) = <span class="subst">{result2}</span>，耗时: <span class="subst">{end - start:<span class="number">.4</span>f}</span>秒"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 再次调用，应该直接从缓存获取结果</span></span><br><span class="line">    start = time.time()</span><br><span class="line">    result3 = fibonacci(n)</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"再次使用缓存计算fibonacci(<span class="subst">{n}</span>) = <span class="subst">{result3}</span>，耗时: <span class="subst">{end - start:<span class="number">.8</span>f}</span>秒"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 显示缓存信息</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"缓存信息: <span class="subst">{fibonacci.cache_info()}</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    demonstrate_lru_cache()</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h4 id="锁的高级应用模式"><a href="#锁的高级应用模式" class="headerlink" title="锁的高级应用模式"></a>锁的高级应用模式</h4><h5 id="读写锁模式"><a href="#读写锁模式" class="headerlink" title="读写锁模式"></a>读写锁模式</h5><p>Python 中的读写锁（Read-Write Lock）主要用于在多线程环境中控制对共享资源的访问。它允许多个线程同时读取共享数据，但在写操作时，其他线程不能进行读或写操作。具体的应用场景包括：</p><ol><li><strong>数据共享与并发读取</strong>：当多个线程需要读取同一份数据时，使用读锁可以提高并发性，允许多个线程同时访问数据，而不需要每次访问都加锁。</li><li><strong>写操作的独占性</strong>：当有线程进行写操作时，需要获取写锁，这样可以确保写操作的独占性，避免数据竞争和不一致性。</li><li><strong>性能优化</strong>：在读多写少的场景下，读写锁能提高性能，因为它允许多个线程并行读取数据，而只有在写入时才会阻塞其他线程。</li></ol><p>我们先从 Python 原生实现读写锁来作为演示，掌握了原生的方式，我们可以使用 <code>readerwriterlock</code> 第三方库来帮我们快速实现读写锁</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReadWriteLock</span>:</span><br><span class="line">    <span class="string">"""读写锁实现</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    允许多个读取者同时访问，或单个写入者独占访问</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">"""初始化读写锁"""</span></span><br><span class="line">        <span class="variable language_">self</span>._read_ready = threading.Condition(threading.RLock())</span><br><span class="line">        <span class="variable language_">self</span>._readers = <span class="number">0</span>  <span class="comment"># 当前读取者数量</span></span><br><span class="line">        <span class="variable language_">self</span>._writers = <span class="number">0</span>  <span class="comment"># 当前写入者数量</span></span><br><span class="line">        <span class="variable language_">self</span>._write_waiting = <span class="number">0</span>  <span class="comment"># 等待写入的线程数</span></span><br><span class="line">        <span class="variable language_">self</span>._writer = <span class="literal">None</span>  <span class="comment"># 当前持有写锁的线程ID</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">acquire_read</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">"""获取读锁"""</span></span><br><span class="line">        <span class="keyword">with</span> <span class="variable language_">self</span>._read_ready:</span><br><span class="line">            <span class="comment"># 当有写入者或正在等待的写入者时，读取者需要等待</span></span><br><span class="line">            <span class="keyword">while</span> <span class="variable language_">self</span>._writers &gt; <span class="number">0</span> <span class="keyword">or</span> <span class="variable language_">self</span>._write_waiting &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="variable language_">self</span>._read_ready.wait()</span><br><span class="line">            <span class="variable language_">self</span>._readers += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">release_read</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">"""释放读锁"""</span></span><br><span class="line">        <span class="keyword">with</span> <span class="variable language_">self</span>._read_ready:</span><br><span class="line">            <span class="variable language_">self</span>._readers -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="variable language_">self</span>._readers == <span class="number">0</span>:  <span class="comment"># 最后一个读取者通知所有等待的线程</span></span><br><span class="line">                <span class="variable language_">self</span>._read_ready.notify_all()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">acquire_write</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">"""获取写锁"""</span></span><br><span class="line">        me = threading.get_ident()  <span class="comment"># 获取当前线程ID</span></span><br><span class="line">        <span class="keyword">with</span> <span class="variable language_">self</span>._read_ready:</span><br><span class="line">            <span class="variable language_">self</span>._write_waiting += <span class="number">1</span>  <span class="comment"># 增加等待写入计数</span></span><br><span class="line">            <span class="comment"># 等待没有读取者和写入者</span></span><br><span class="line">            <span class="keyword">while</span> <span class="variable language_">self</span>._readers &gt; <span class="number">0</span> <span class="keyword">or</span> <span class="variable language_">self</span>._writers &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="variable language_">self</span>._read_ready.wait()</span><br><span class="line">            <span class="variable language_">self</span>._write_waiting -= <span class="number">1</span>  <span class="comment"># 减少等待写入计数</span></span><br><span class="line">            <span class="variable language_">self</span>._writers += <span class="number">1</span></span><br><span class="line">            <span class="variable language_">self</span>._writer = me</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">release_write</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">"""释放写锁"""</span></span><br><span class="line">        <span class="keyword">with</span> <span class="variable language_">self</span>._read_ready:</span><br><span class="line">            <span class="keyword">if</span> <span class="variable language_">self</span>._writer != threading.get_ident():</span><br><span class="line">                <span class="keyword">raise</span> RuntimeError(<span class="string">"释放未持有的写锁"</span>)</span><br><span class="line">            <span class="variable language_">self</span>._writers -= <span class="number">1</span></span><br><span class="line">            <span class="variable language_">self</span>._writer = <span class="literal">None</span></span><br><span class="line">            <span class="variable language_">self</span>._read_ready.notify_all()  <span class="comment"># 通知所有等待的线程</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 支持with语句的上下文管理器</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">ReadLock</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, rw_lock</span>):</span><br><span class="line">            <span class="variable language_">self</span>.rw_lock = rw_lock</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="variable language_">self</span>.rw_lock.acquire_read()</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, exc_type, exc_val, exc_tb</span>):</span><br><span class="line">            <span class="variable language_">self</span>.rw_lock.release_read()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">WriteLock</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, rw_lock</span>):</span><br><span class="line">            <span class="variable language_">self</span>.rw_lock = rw_lock</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="variable language_">self</span>.rw_lock.acquire_write()</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, exc_type, exc_val, exc_tb</span>):</span><br><span class="line">            <span class="variable language_">self</span>.rw_lock.release_write()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取读锁和写锁的方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read_lock</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">"""获取读锁上下文管理器"""</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.ReadLock(<span class="variable language_">self</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">write_lock</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">"""获取写锁上下文管理器"""</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.WriteLock(<span class="variable language_">self</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 共享数据和读写锁</span></span><br><span class="line">shared_data = {<span class="string">'count'</span>: <span class="number">0</span>, <span class="string">'values'</span>: []}</span><br><span class="line">rw_lock = ReadWriteLock()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reader</span>(<span class="params">reader_id</span>):</span><br><span class="line">    <span class="string">"""读取者线程</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        reader_id: 读取者ID</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        <span class="comment"># 获取读锁</span></span><br><span class="line">        <span class="keyword">with</span> rw_lock.read_lock():</span><br><span class="line">            <span class="comment"># 读取共享数据</span></span><br><span class="line">            count = shared_data[<span class="string">'count'</span>]</span><br><span class="line">            values = shared_data[<span class="string">'values'</span>].copy()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 模拟读取操作</span></span><br><span class="line">            time.sleep(random.uniform(<span class="number">0.05</span>, <span class="number">0.1</span>))</span><br><span class="line"></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f"读取者 <span class="subst">{reader_id}</span>: 读取到 count=<span class="subst">{count}</span>, values=<span class="subst">{values}</span>"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 读取者之间的休息</span></span><br><span class="line">        time.sleep(random.uniform(<span class="number">0.1</span>, <span class="number">0.3</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">writer</span>(<span class="params">writer_id</span>):</span><br><span class="line">    <span class="string">"""写入者线程</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        writer_id: 写入者ID</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        <span class="comment"># 准备新数据</span></span><br><span class="line">        new_value = writer_id * <span class="number">100</span> + i</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 获取写锁</span></span><br><span class="line">        <span class="keyword">with</span> rw_lock.write_lock():</span><br><span class="line">            <span class="comment"># 修改共享数据</span></span><br><span class="line">            shared_data[<span class="string">'count'</span>] += <span class="number">1</span></span><br><span class="line">            shared_data[<span class="string">'values'</span>].append(new_value)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 模拟写入操作</span></span><br><span class="line">            time.sleep(random.uniform(<span class="number">0.1</span>, <span class="number">0.2</span>))</span><br><span class="line"></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f"写入者 <span class="subst">{writer_id}</span>: 更新为 count=<span class="subst">{shared_data[<span class="string">'count'</span>]}</span>, values=<span class="subst">{shared_data[<span class="string">'values'</span>]}</span>"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 写入者之间的休息</span></span><br><span class="line">        time.sleep(random.uniform(<span class="number">0.3</span>, <span class="number">0.7</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 创建读取者和写入者线程</span></span><br><span class="line">readers = [threading.Thread(target=reader, args=(i,)) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br><span class="line">writers = [threading.Thread(target=writer, args=(i,)) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment">### 启动所有线程</span></span><br><span class="line">all_threads = readers + writers</span><br><span class="line"><span class="keyword">for</span> thread <span class="keyword">in</span> all_threads:</span><br><span class="line">    thread.start()</span><br><span class="line"></span><br><span class="line"><span class="comment">### 等待所有线程完成</span></span><br><span class="line"><span class="keyword">for</span> thread <span class="keyword">in</span> all_threads:</span><br><span class="line">    thread.join()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f"最终数据: count=<span class="subst">{shared_data[<span class="string">'count'</span>]}</span>, values=<span class="subst">{shared_data[<span class="string">'values'</span>]}</span>"</span>)</span><br></pre></td></tr></tbody></table></figure><h6 id="使用-readerwriterlock-库实现读写锁"><a href="#使用-readerwriterlock-库实现读写锁" class="headerlink" title="使用 readerwriterlock 库实现读写锁"></a>使用 <code>readerwriterlock</code> 库实现读写锁</h6><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">读写锁实现示例</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">readerwriterlock库提供了三种读写锁实现：</span></span><br><span class="line"><span class="string">- RWLockRead：读者优先（第一读者-写者问题）</span></span><br><span class="line"><span class="string">- RWLockWrite：写者优先（第二读者-写者问题）</span></span><br><span class="line"><span class="string">- RWLockFair：公平优先（第三读者-写者问题）</span></span><br><span class="line"><span class="string">每种锁都有对应的可降级版本（带D后缀），允许将锁从写模式降级到读模式</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> readerwriterlock <span class="keyword">import</span> rwlock</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个公平优先的读写锁</span></span><br><span class="line">rw_lock = rwlock.RWLockFairD()</span><br><span class="line"><span class="comment"># 共享数据</span></span><br><span class="line">shared_data = {<span class="string">'count'</span>: <span class="number">0</span>, <span class="string">'values'</span>: []}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_demo</span>(<span class="params">reader_id, sleep_time=<span class="number">0.5</span></span>):</span><br><span class="line">    <span class="string">"""用于演示的读取函数"""</span></span><br><span class="line">    read_lock = rw_lock.gen_rlock()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> read_lock:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f"读取者 <span class="subst">{reader_id}</span>: 获得读锁"</span>)</span><br><span class="line">            time.sleep(sleep_time)  <span class="comment"># 模拟读取操作</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f"读取者 <span class="subst">{reader_id}</span>: 完成读取"</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f"读取者 <span class="subst">{reader_id}</span>: 释放读锁"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write_demo</span>(<span class="params">writer_id, sleep_time=<span class="number">0.5</span></span>):</span><br><span class="line">    <span class="string">"""用于演示的写入函数"""</span></span><br><span class="line">    write_lock = rw_lock.gen_wlock()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> write_lock:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f"写入者 <span class="subst">{writer_id}</span>: 获得写锁"</span>)</span><br><span class="line">            time.sleep(sleep_time)  <span class="comment"># 模拟写入操作</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f"写入者 <span class="subst">{writer_id}</span>: 完成写入"</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f"写入者 <span class="subst">{writer_id}</span>: 释放写锁"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">demonstrate_read_read_nonblocking</span>():</span><br><span class="line">    <span class="string">"""演示读读不互斥"""</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\n=== 演示：读读不互斥 ==="</span>)</span><br><span class="line">    </span><br><span class="line">    threads = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        thread = threading.Thread(target=read_demo, args=(i, <span class="number">0.5</span>))</span><br><span class="line">        threads.append(thread)</span><br><span class="line">        thread.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">        thread.join()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">demonstrate_read_write_blocking</span>():</span><br><span class="line">    <span class="string">"""演示读写互斥"""</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\n=== 演示：读写互斥 ==="</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 先启动一个长时间的读取线程</span></span><br><span class="line">    read_thread = threading.Thread(target=read_demo, args=(<span class="number">0</span>, <span class="number">2</span>))</span><br><span class="line">    read_thread.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 给读取线程一点时间获取锁</span></span><br><span class="line">    time.sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 尝试启动写入线程，应该被阻塞直到读取完成</span></span><br><span class="line">    write_thread = threading.Thread(target=write_demo, args=(<span class="number">0</span>, <span class="number">0.5</span>))</span><br><span class="line">    write_thread.start()</span><br><span class="line"></span><br><span class="line">    read_thread.join()</span><br><span class="line">    write_thread.join()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">demonstrate_write_write_blocking</span>():</span><br><span class="line">    <span class="string">"""演示写写互斥"""</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\n=== 演示：写写互斥 ==="</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 先启动一个长时间的写入线程</span></span><br><span class="line">    write_thread1 = threading.Thread(target=write_demo, args=(<span class="number">0</span>, <span class="number">2</span>))</span><br><span class="line">    write_thread1.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 给第一个写入线程一点时间获取锁</span></span><br><span class="line">    time.sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 尝试启动另一个写入线程，应该被阻塞直到第一个写入完成</span></span><br><span class="line">    write_thread2 = threading.Thread(target=write_demo, args=(<span class="number">1</span>, <span class="number">0.5</span>))</span><br><span class="line">    write_thread2.start()</span><br><span class="line"></span><br><span class="line">    write_thread1.join()</span><br><span class="line">    write_thread2.join()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">demonstrate_timeout</span>():</span><br><span class="line">    <span class="string">"""演示锁获取超时"""</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\n=== 演示：锁获取超时 ==="</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 先启动一个长时间的写入线程</span></span><br><span class="line">    write_thread = threading.Thread(target=write_demo, args=(<span class="number">0</span>, <span class="number">3</span>))</span><br><span class="line">    write_thread.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 给写入线程一点时间获取锁</span></span><br><span class="line">    time.sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 尝试获取读锁，但设置较短的超时时间</span></span><br><span class="line">    read_lock = rw_lock.gen_rlock()</span><br><span class="line">    <span class="keyword">if</span> read_lock.acquire(blocking=<span class="literal">True</span>, timeout=<span class="number">0.5</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"读取者: 成功获得读锁（不应该发生）"</span>)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            read_lock.release()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"读取者: 获取读锁超时（预期行为）"</span>)</span><br><span class="line"></span><br><span class="line">    write_thread.join()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 演示读读不互斥</span></span><br><span class="line">    demonstrate_read_read_nonblocking()</span><br><span class="line">    <span class="comment"># 演示读写互斥</span></span><br><span class="line">    demonstrate_read_write_blocking()</span><br><span class="line">    <span class="comment"># 演示写写互斥</span></span><br><span class="line">    demonstrate_write_write_blocking()</span><br><span class="line">    <span class="comment"># 演示锁获取超时</span></span><br><span class="line">    demonstrate_timeout()</span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th>读写锁特性</th><th>描述</th><th>优势</th><th>适用场景</th></tr></thead><tbody><tr><td>读共享/写独占</td><td>多个读取可并发，写入需独占</td><td>提高读多写少场景的并发性</td><td>配置数据、缓存系统、数据集</td></tr><tr><td>读写优先级</td><td>可以设置读优先或写优先</td><td>根据应用需求调整性能特性</td><td>根据读写比例调整策略</td></tr><tr><td>升级/降级</td><td>支持锁的升级(读 → 写)或降级(写 → 读)</td><td>灵活处理复杂访问模式</td><td>先检查后修改的操作</td></tr></tbody></table><blockquote><p>💡 <strong>使用建议</strong>：</p><ul><li>读多写少的场景推荐使用读写锁</li><li>注意防止 “写饥饿”，即读取者太多导致写入者长时间等待</li></ul></blockquote><h6 id="锁排序（解决死锁）"><a href="#锁排序（解决死锁）" class="headerlink" title="锁排序（解决死锁）"></a>锁排序（解决死锁）</h6><p>为避免死锁，一个常用的技术是确保所有线程按照相同的顺序获取多个锁。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span>:</span><br><span class="line">    <span class="string">"""模拟银行账户"""</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name: <span class="built_in">str</span>, balance: <span class="built_in">int</span> = <span class="number">0</span></span>):</span><br><span class="line">        <span class="string">"""初始化账户"""</span></span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="variable language_">self</span>.balance = balance</span><br><span class="line">        <span class="variable language_">self</span>.lock = threading.RLock()</span><br><span class="line">        <span class="comment"># 用于账户排序的唯一ID</span></span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">id</span> = <span class="built_in">id</span>(<span class="variable language_">self</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f"账户<span class="subst">{self.name}</span>[余额=<span class="subst">{self.balance}</span>]"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">transfer_money</span>(<span class="params">from_account: Account, to_account: Account, amount: <span class="built_in">int</span>, thread_name: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    在账户间转账，使用账户ID排序策略避免死锁</span></span><br><span class="line"><span class="string">    from_account: 转出账户</span></span><br><span class="line"><span class="string">    to_account: 转入账户</span></span><br><span class="line"><span class="string">    amount: 转账金额</span></span><br><span class="line"><span class="string">    thread_name: 线程名称</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 按照账户ID从小到大的顺序获取锁，确保所有线程获取锁的顺序一致</span></span><br><span class="line">    first, second = <span class="built_in">sorted</span>([from_account, to_account], key=<span class="keyword">lambda</span> x: x.<span class="built_in">id</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"<span class="subst">{thread_name}</span>: 尝试锁定账户 <span class="subst">{first.name}</span>"</span>)</span><br><span class="line">    <span class="keyword">with</span> first.lock:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f"<span class="subst">{thread_name}</span>: 已锁定账户 <span class="subst">{first.name}</span>"</span>)</span><br><span class="line">        <span class="comment"># 模拟网络延迟</span></span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f"<span class="subst">{thread_name}</span>: 尝试锁定账户 <span class="subst">{second.name}</span>"</span>)</span><br><span class="line">        <span class="keyword">with</span> second.lock:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f"<span class="subst">{thread_name}</span>: 已锁定账户 <span class="subst">{second.name}</span>"</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 执行转账操作</span></span><br><span class="line">            from_account.balance -= amount</span><br><span class="line">            to_account.balance += amount</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f"<span class="subst">{thread_name}</span>: 已从<span class="subst">{from_account.name}</span>转账<span class="subst">{amount}</span>元到<span class="subst">{to_account.name}</span>"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 创建两个账户</span></span><br><span class="line">    alice = Account(<span class="string">"Alice"</span>, <span class="number">1000</span>)</span><br><span class="line">    bob = Account(<span class="string">"Bob"</span>, <span class="number">1000</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"初始状态: <span class="subst">{alice}</span>, <span class="subst">{bob}</span>"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创建两个线程，同时进行相反方向的转账</span></span><br><span class="line">    t1 = threading.Thread(</span><br><span class="line">        name=<span class="string">"Thread-1"</span>,</span><br><span class="line">        target=transfer_money,</span><br><span class="line">        args=(alice, bob, <span class="number">500</span>, <span class="string">"转账线程1"</span>)</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    t2 = threading.Thread(</span><br><span class="line">        name=<span class="string">"Thread-2"</span>,</span><br><span class="line">        target=transfer_money,</span><br><span class="line">        args=(bob, alice, <span class="number">300</span>, <span class="string">"转账线程2"</span>)</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 启动线程</span></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 等待线程结束</span></span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"最终状态: <span class="subst">{alice}</span>, <span class="subst">{bob}</span>"</span>)</span><br></pre></td></tr></tbody></table></figure><h6 id="两阶段锁定"><a href="#两阶段锁定" class="headerlink" title="两阶段锁定"></a>两阶段锁定</h6><p>两阶段锁定是一种事务并发控制协议，分为获取阶段和释放阶段，可以保证事务的可串行化。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TwoPhaseLockDatabase</span>:</span><br><span class="line">    <span class="string">"""演示两阶段锁定协议的简单数据库"""</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">"""初始化数据库"""</span></span><br><span class="line">        <span class="variable language_">self</span>.data = {<span class="string">'A'</span>: <span class="number">100</span>, <span class="string">'B'</span>: <span class="number">200</span>}  <span class="comment"># 简单的数据项</span></span><br><span class="line">        <span class="variable language_">self</span>.locks = {<span class="string">'A'</span>: threading.RLock(), <span class="string">'B'</span>: threading.RLock()}  <span class="comment"># 每个数据项的锁</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">transaction</span>(<span class="params">self, items_to_read, items_to_write, operation</span>):</span><br><span class="line">        <span class="string">"""执行两阶段锁定事务</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            items_to_read: 需要读取的数据项列表</span></span><br><span class="line"><span class="string">            items_to_write: 需要写入的数据项列表</span></span><br><span class="line"><span class="string">            operation: 事务操作函数</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            bool: 事务是否成功</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 按字母顺序排序所有需要锁定的项，避免死锁</span></span><br><span class="line">        all_items = <span class="built_in">sorted</span>(<span class="built_in">set</span>(items_to_read + items_to_write))</span><br><span class="line">        acquired_locks = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 阶段1: 获取锁阶段（增长阶段）</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f"事务 <span class="subst">{threading.current_thread().name}</span>: 开始获取锁"</span>)</span><br><span class="line">            <span class="keyword">for</span> item <span class="keyword">in</span> all_items:</span><br><span class="line">                <span class="comment"># 对于读取项获取共享锁，对于写入项获取排他锁</span></span><br><span class="line">                <span class="comment"># 这里简化为都使用排他锁</span></span><br><span class="line">                <span class="keyword">if</span> <span class="variable language_">self</span>.locks[item].acquire(timeout=<span class="number">1</span>):</span><br><span class="line">                    acquired_locks.append(item)</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f"事务 <span class="subst">{threading.current_thread().name}</span>: 已锁定 <span class="subst">{item}</span>"</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">raise</span> TimeoutError(<span class="string">f"获取 <span class="subst">{item}</span> 的锁超时"</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 执行事务操作</span></span><br><span class="line">            result = operation(<span class="variable language_">self</span>.data)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f"事务 <span class="subst">{threading.current_thread().name}</span>: 操作完成"</span>)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f"事务 <span class="subst">{threading.current_thread().name}</span>: 错误 - <span class="subst">{e}</span>"</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="comment"># 阶段2: 释放锁阶段（收缩阶段）</span></span><br><span class="line">            <span class="keyword">for</span> item <span class="keyword">in</span> acquired_locks:</span><br><span class="line">                <span class="variable language_">self</span>.locks[item].release()</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f"事务 <span class="subst">{threading.current_thread().name}</span>: 已释放 <span class="subst">{item}</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">transfer_money</span>(<span class="params">db, from_account, to_account, amount</span>):</span><br><span class="line">    <span class="string">"""转账事务"""</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">operation</span>(<span class="params">data</span>):</span><br><span class="line">        <span class="keyword">if</span> data[from_account] &lt; amount:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f"账户 <span class="subst">{from_account}</span> 余额不足"</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 模拟操作耗时</span></span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 执行转账</span></span><br><span class="line">        data[from_account] -= amount</span><br><span class="line">        data[to_account] += amount</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f"已从 <span class="subst">{from_account}</span> 转账 <span class="subst">{amount}</span> 到 <span class="subst">{to_account}</span>"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> db.transaction([from_account, to_account], [from_account, to_account], operation)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_transaction</span>(<span class="params">db, thread_id, from_acc, to_acc, amount</span>):</span><br><span class="line">    <span class="string">"""执行事务的线程函数"""</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"线程 <span class="subst">{thread_id}</span>: 尝试转账 <span class="subst">{amount}</span> 从 <span class="subst">{from_acc}</span> 到 <span class="subst">{to_acc}</span>"</span>)</span><br><span class="line">    </span><br><span class="line">    start_time = time.time()</span><br><span class="line">    success = transfer_money(db, from_acc, to_acc, amount)</span><br><span class="line">    elapsed = time.time() - start_time</span><br><span class="line">    </span><br><span class="line">    status = <span class="string">"成功"</span> <span class="keyword">if</span> success <span class="keyword">else</span> <span class="string">"失败"</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"线程 <span class="subst">{thread_id}</span>: 转账<span class="subst">{status}</span>，耗时 <span class="subst">{elapsed:<span class="number">.2</span>f}</span>秒"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建数据库实例</span></span><br><span class="line">db = TwoPhaseLockDatabase()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f"初始账户状态: <span class="subst">{db.data}</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建并启动多个线程</span></span><br><span class="line">threads = []</span><br><span class="line">transactions = [</span><br><span class="line">    (<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="number">30</span>),  <span class="comment"># 从A转30到B</span></span><br><span class="line">    (<span class="string">"B"</span>, <span class="string">"A"</span>, <span class="number">50</span>),  <span class="comment"># 从B转50到A</span></span><br><span class="line">    (<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="number">20</span>)   <span class="comment"># 从A转20到B</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, (from_acc, to_acc, amount) <span class="keyword">in</span> <span class="built_in">enumerate</span>(transactions):</span><br><span class="line">    t = threading.Thread(</span><br><span class="line">        name=<span class="string">f"Transaction-<span class="subst">{i}</span>"</span>,</span><br><span class="line">        target=run_transaction,</span><br><span class="line">        args=(db, i, from_acc, to_acc, amount)</span><br><span class="line">    )</span><br><span class="line">    threads.append(t)</span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待所有线程完成</span></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">    t.join()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f"最终账户状态: <span class="subst">{db.data}</span>"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f"总金额: <span class="subst">{<span class="built_in">sum</span>(db.data.values())}</span>"</span>)  <span class="comment"># 总金额应该不变</span></span><br></pre></td></tr></tbody></table></figure><h6 id="超时重试模式"><a href="#超时重试模式" class="headerlink" title="超时重试模式"></a>超时重试模式</h6><p>在并发环境中，有时获取锁可能会失败。超时重试模式可以增加获取锁的成功概率，同时避免永久阻塞。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment">### 共享资源</span></span><br><span class="line">resource_value = <span class="number">0</span></span><br><span class="line">resource_lock = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">update_resource</span>(<span class="params">worker_id, max_retries=<span class="number">3</span></span>):</span><br><span class="line">    <span class="string">"""更新共享资源，使用超时重试模式</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        worker_id: 工作线程ID</span></span><br><span class="line"><span class="string">        max_retries: 最大重试次数</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        bool: 是否成功更新</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">global</span> resource_value</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 随机生成操作标识，用于跟踪</span></span><br><span class="line">    operation_id = random.randint(<span class="number">10000</span>, <span class="number">99999</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"工作线程 <span class="subst">{worker_id}</span> [操作:<span class="subst">{operation_id}</span>]: 尝试更新资源"</span>)</span><br><span class="line">    </span><br><span class="line">    retry_count = <span class="number">0</span></span><br><span class="line">    backoff = <span class="number">0.1</span>  <span class="comment"># 初始回退时间</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> retry_count &lt; max_retries:</span><br><span class="line">        <span class="comment"># 尝试获取锁，设置超时时间</span></span><br><span class="line">        <span class="keyword">if</span> resource_lock.acquire(timeout=<span class="number">0.5</span>):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f"工作线程 <span class="subst">{worker_id}</span> [操作:<span class="subst">{operation_id}</span>]: 获取到锁，当前值: <span class="subst">{resource_value}</span>"</span>)</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 模拟资源更新操作</span></span><br><span class="line">                local_value = resource_value</span><br><span class="line">                <span class="comment"># 随机决定操作时间，有时可能很长</span></span><br><span class="line">                work_time = random.uniform(<span class="number">0.1</span>, <span class="number">1.0</span>)</span><br><span class="line">                time.sleep(work_time)</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 更新资源</span></span><br><span class="line">                resource_value = local_value + <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f"工作线程 <span class="subst">{worker_id}</span> [操作:<span class="subst">{operation_id}</span>]: 更新成功，新值: <span class="subst">{resource_value}</span>，耗时: <span class="subst">{work_time:<span class="number">.2</span>f}</span>秒"</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                </span><br><span class="line">            <span class="keyword">finally</span>:</span><br><span class="line">                <span class="comment"># 释放锁</span></span><br><span class="line">                resource_lock.release()</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f"工作线程 <span class="subst">{worker_id}</span> [操作:<span class="subst">{operation_id}</span>]: 释放锁"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            retry_count += <span class="number">1</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f"工作线程 <span class="subst">{worker_id}</span> [操作:<span class="subst">{operation_id}</span>]: 获取锁超时，重试 <span class="subst">{retry_count}</span>/<span class="subst">{max_retries}</span>"</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> retry_count &lt; max_retries:</span><br><span class="line">                <span class="comment"># 使用指数退避策略，每次重试间隔加长</span></span><br><span class="line">                time.sleep(backoff)</span><br><span class="line">                backoff *= <span class="number">2</span>  <span class="comment"># 指数增长</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"工作线程 <span class="subst">{worker_id}</span> [操作:<span class="subst">{operation_id}</span>]: 达到最大重试次数，放弃操作"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">worker_thread</span>(<span class="params">worker_id, operations</span>):</span><br><span class="line">    <span class="string">"""工作线程函数</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        worker_id: 工作线程ID</span></span><br><span class="line"><span class="string">        operations: 要执行的操作次数</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    success_count = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(operations):</span><br><span class="line">        <span class="comment"># 尝试更新资源</span></span><br><span class="line">        <span class="keyword">if</span> update_resource(worker_id):</span><br><span class="line">            success_count += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 线程之间的间隔</span></span><br><span class="line">        time.sleep(random.uniform(<span class="number">0.1</span>, <span class="number">0.5</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"工作线程 <span class="subst">{worker_id}</span>: 完成 <span class="subst">{success_count}</span>/<span class="subst">{operations}</span> 次成功更新"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">### 创建多个工作线程</span></span><br><span class="line">threads = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    t = threading.Thread(target=worker_thread, args=(i, <span class="number">3</span>))</span><br><span class="line">    threads.append(t)</span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line"><span class="comment">### 等待所有线程完成</span></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">    t.join()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f"最终资源值: <span class="subst">{resource_value}</span>"</span>)</span><br></pre></td></tr></tbody></table></figure><h5 id="多进程与多线程结合的混合模型"><a href="#多进程与多线程结合的混合模型" class="headerlink" title="多进程与多线程结合的混合模型"></a>多进程与多线程结合的混合模型</h5><p>对于复杂应用，常常需要结合多进程和多线程的优势：多进程跨越 GIL 限制利用多核心，每个进程内使用多线程处理 I/O 任务。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> concurrent.futures</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> StringIO</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">io_task</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="string">"""模拟I/O密集型任务：发送HTTP请求并处理响应"""</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(url, timeout=<span class="number">5</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f"线程 <span class="subst">{threading.current_thread().name}</span> 完成请求 <span class="subst">{url}</span>, 状态码: <span class="subst">{response.status_code}</span>"</span>)</span><br><span class="line">        <span class="keyword">return</span> response.status_code</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f"线程 <span class="subst">{threading.current_thread().name}</span> 请求 <span class="subst">{url}</span> 失败: <span class="subst">{<span class="built_in">str</span>(e)}</span>"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cpu_task</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="string">"""模拟CPU密集型任务：处理CSV数据"""</span></span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 模拟CPU密集型计算</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000000</span>):</span><br><span class="line">        result += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 解析CSV数据</span></span><br><span class="line">    csv_data = StringIO(data)</span><br><span class="line">    reader = csv.reader(csv_data)</span><br><span class="line">    rows = <span class="built_in">list</span>(reader)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"进程 <span class="subst">{os.getpid()}</span> 处理了 <span class="subst">{<span class="built_in">len</span>(rows)}</span> 行数据"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(rows)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_worker</span>(<span class="params">process_id, urls</span>):</span><br><span class="line">    <span class="string">"""每个进程的工作函数，使用线程池处理I/O任务"""</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"进程 <span class="subst">{os.getpid()}</span> (ID: <span class="subst">{process_id}</span>) 启动"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创建线程池处理I/O任务</span></span><br><span class="line">    <span class="keyword">with</span> concurrent.futures.ThreadPoolExecutor(max_workers=<span class="number">4</span>) <span class="keyword">as</span> executor:</span><br><span class="line">        <span class="comment"># 提交所有URL请求任务到线程池</span></span><br><span class="line">        future_to_url = {executor.submit(io_task, url): url <span class="keyword">for</span> url <span class="keyword">in</span> urls}</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 收集结果</span></span><br><span class="line">        results = []</span><br><span class="line">        <span class="keyword">for</span> future <span class="keyword">in</span> concurrent.futures.as_completed(future_to_url):</span><br><span class="line">            url = future_to_url[future]</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                status_code = future.result()</span><br><span class="line">                results.append((url, status_code))</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f"处理 <span class="subst">{url}</span> 时出错: <span class="subst">{<span class="built_in">str</span>(e)}</span>"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 模拟一些CSV数据处理（CPU密集型任务）</span></span><br><span class="line">    sample_csv = <span class="string">"col1,col2,col3\n1,2,3\n4,5,6\n7,8,9"</span></span><br><span class="line">    cpu_result = cpu_task(sample_csv)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"进程 <span class="subst">{os.getpid()}</span> (ID: <span class="subst">{process_id}</span>) 完成所有任务"</span>)</span><br><span class="line">    <span class="keyword">return</span> results, cpu_result</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 测试URL列表</span></span><br><span class="line">    all_urls = [</span><br><span class="line">        <span class="string">f"https://httpbin.org/delay/<span class="subst">{i%<span class="number">3</span>}</span>"</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>)</span><br><span class="line">    ]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将URL分成4组，每个进程处理4个URL</span></span><br><span class="line">    url_chunks = [all_urls[i:i+<span class="number">4</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(all_urls), <span class="number">4</span>)]</span><br><span class="line">    </span><br><span class="line">    start_time = time.time()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创建进程池</span></span><br><span class="line">    <span class="keyword">with</span> concurrent.futures.ProcessPoolExecutor(max_workers=<span class="number">4</span>) <span class="keyword">as</span> process_executor:</span><br><span class="line">        <span class="comment"># 提交任务到进程池</span></span><br><span class="line">        futures = [process_executor.submit(process_worker, i, urls) </span><br><span class="line">                  <span class="keyword">for</span> i, urls <span class="keyword">in</span> <span class="built_in">enumerate</span>(url_chunks)]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 收集所有进程的结果</span></span><br><span class="line">        <span class="keyword">for</span> future <span class="keyword">in</span> concurrent.futures.as_completed(futures):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                io_results, cpu_result = future.result()</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f"进程返回结果: <span class="subst">{<span class="built_in">len</span>(io_results)}</span> 个URL请求, CPU任务处理了 <span class="subst">{cpu_result}</span> 行数据"</span>)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f"进程执行出错: <span class="subst">{<span class="built_in">str</span>(e)}</span>"</span>)</span><br><span class="line">    </span><br><span class="line">    elapsed_time = time.time() - start_time</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"总执行时间: <span class="subst">{elapsed_time:<span class="number">.2</span>f}</span> 秒"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>这种混合模型充分利用了 Python 的并发性能：</p><ol><li><strong>多进程并行</strong>：跨越 GIL 限制，在多个 CPU 核心上同时执行 Python 代码</li><li><strong>每进程多线程</strong>：处理进程内的 I/O 密集型任务，提高 I/O 并发性</li><li><strong>任务队列</strong>：有效分配和管理工作负载，平衡资源利用</li></ol><h5 id="细粒度锁与粗粒度锁"><a href="#细粒度锁与粗粒度锁" class="headerlink" title="细粒度锁与粗粒度锁"></a>细粒度锁与粗粒度锁</h5><p>锁的粒度指锁保护资源的范围大小。细粒度锁保护小范围资源，提高并发度；粗粒度锁保护大范围资源，简化编程但可能降低并发度。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 共享资源</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BankAccount</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, balance</span>):</span><br><span class="line">        <span class="variable language_">self</span>.balance = balance</span><br><span class="line">        <span class="comment"># 粗粒度锁 - 用于整个账户操作</span></span><br><span class="line">        <span class="variable language_">self</span>.coarse_lock = threading.Lock()</span><br><span class="line">        <span class="comment"># 细粒度锁 - 分别用于读取和写入操作</span></span><br><span class="line">        <span class="variable language_">self</span>.read_lock = threading.Lock()</span><br><span class="line">        <span class="variable language_">self</span>.write_lock = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 粗粒度锁示例 - 锁定整个账户操作</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">transfer_coarse</span>(<span class="params">account, amount</span>):</span><br><span class="line">    <span class="keyword">with</span> account.coarse_lock:</span><br><span class="line">        <span class="comment"># 模拟读取余额操作</span></span><br><span class="line">        current_balance = account.balance</span><br><span class="line">        <span class="comment"># 模拟网络延迟或处理时间</span></span><br><span class="line">        time.sleep(random.uniform(<span class="number">0.001</span>, <span class="number">0.005</span>))</span><br><span class="line">        <span class="comment"># 模拟更新余额操作</span></span><br><span class="line">        account.balance = current_balance + amount</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f"粗粒度锁: 转账 <span class="subst">{amount}</span>，当前余额 <span class="subst">{account.balance}</span>"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 细粒度锁示例 - 分别锁定读取和写入操作</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">transfer_fine</span>(<span class="params">account, amount</span>):</span><br><span class="line">    <span class="comment"># 锁定读取操作</span></span><br><span class="line">    <span class="keyword">with</span> account.read_lock:</span><br><span class="line">        current_balance = account.balance</span><br><span class="line">        <span class="comment"># 模拟处理时间</span></span><br><span class="line">        time.sleep(random.uniform(<span class="number">0.001</span>, <span class="number">0.005</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这里可以执行一些不需要锁定的计算</span></span><br><span class="line">    time.sleep(random.uniform(<span class="number">0.001</span>, <span class="number">0.002</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 锁定写入操作</span></span><br><span class="line">    <span class="keyword">with</span> account.write_lock:</span><br><span class="line">        account.balance = current_balance + amount</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f"细粒度锁: 转账 <span class="subst">{amount}</span>，当前余额 <span class="subst">{account.balance}</span>"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 创建共享账户</span></span><br><span class="line">    account = BankAccount(<span class="number">1000</span>)</span><br><span class="line">    threads = []</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"=== 测试粗粒度锁 ==="</span>)</span><br><span class="line">    start_time = time.time()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建10个使用粗粒度锁的线程</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        amount = random.randint(<span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line">        t = threading.Thread(target=transfer_coarse, args=(account, amount))</span><br><span class="line">        threads.append(t)</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待所有线程完成</span></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.join()</span><br><span class="line"></span><br><span class="line">    coarse_time = time.time() - start_time</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"粗粒度锁总耗时: <span class="subst">{coarse_time:<span class="number">.4</span>f}</span>秒"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 重置账户和线程列表</span></span><br><span class="line">    account.balance = <span class="number">1000</span></span><br><span class="line">    threads = []</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\n=== 测试细粒度锁 ==="</span>)</span><br><span class="line">    start_time = time.time()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建10个使用细粒度锁的线程</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        amount = random.randint(<span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line">        t = threading.Thread(target=transfer_fine, args=(account, amount))</span><br><span class="line">        threads.append(t)</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待所有线程完成</span></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.join()</span><br><span class="line"></span><br><span class="line">    fine_time = time.time() - start_time</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"细粒度锁总耗时: <span class="subst">{fine_time:<span class="number">.4</span>f}</span>秒"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"\n性能比较: 细粒度锁比粗粒度锁快 <span class="subst">{(coarse_time / fine_time):<span class="number">.2</span>f}</span> 倍"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th>锁粒度</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>粗粒度锁</td><td>简单、易维护、不易死锁</td><td>并发性能低、可能导致线程等待</td><td>简单应用、对性能要求不高的场景</td></tr><tr><td>细粒度锁</td><td>并发性能高、资源利用率高</td><td>实现复杂、可能造成死锁</td><td>高性能要求、资源访问模式明确的场景</td></tr></tbody></table><h3 id="14-7-消息队列与进程通信"><a href="#14-7-消息队列与进程通信" class="headerlink" title="14.7 消息队列与进程通信"></a>14.7 消息队列与进程通信</h3><p>在并发编程中，队列是一种常用的数据结构。它遵循 <strong>先进先出（FIFO）</strong> 的原则，适合用于线程或进程间的通信，而堆栈则遵循 <strong>后进先出（LIFO）</strong> 的原则。Python 中的 <code>queue</code> 和 <code>multiprocessing</code> 模块提供了多种类型的队列，每种队列适用于不同的场景。</p><h4 id="队列基础知识"><a href="#队列基础知识" class="headerlink" title="队列基础知识"></a>队列基础知识</h4><p>Python 的 <code>queue</code> 模块和 <code>multiprocessing</code> 模块提供了多种队列类型，主要包括：</p><table><thead><tr><th>队列类型</th><th>模块</th><th>特点</th><th>适用场景</th></tr></thead><tbody><tr><td>Queue</td><td>queue</td><td>线程安全的 FIFO 队列</td><td>线程间通信</td></tr><tr><td>LifoQueue</td><td>queue</td><td>线程安全的 LIFO 队列(堆栈)</td><td>需要后进先出的场景</td></tr><tr><td>PriorityQueue</td><td>queue</td><td>优先级队列</td><td>任务具有优先级的场景</td></tr><tr><td>Queue</td><td>multiprocessing</td><td>进程安全的 FIFO 队列</td><td>进程间通信</td></tr><tr><td>JoinableQueue</td><td>multiprocessing</td><td>带有任务完成通知机制的队列</td><td>生产者-消费者模型</td></tr></tbody></table><h4 id="队列使用示例"><a href="#队列使用示例" class="headerlink" title="队列使用示例"></a>队列使用示例</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生产者进程函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">producer</span>(<span class="params">q: Queue</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="string">"""生产者函数，负责生产数据并放入队列"""</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        item = <span class="string">f"小吃<span class="subst">{i}</span>"</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f"生产者生产了<span class="subst">{item}</span>"</span>)</span><br><span class="line">        q.put(item)  <span class="comment"># 放入队列</span></span><br><span class="line">        time.sleep(random.uniform(<span class="number">0.1</span>, <span class="number">0.5</span>))  <span class="comment"># 模拟耗时操作</span></span><br><span class="line">    q.put(<span class="literal">None</span>)  <span class="comment"># 生产结束信号</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"生产者结束"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 消费者进程函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">consumer</span>(<span class="params">q: Queue</span>):</span><br><span class="line">    <span class="string">"""消费者函数，负责从队列中获取数据并消费"""</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        item = q.get()  <span class="comment"># 从队列中获取项目</span></span><br><span class="line">        <span class="keyword">if</span> item <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 若获取到结束信号，则退出循环</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f"消费者消费了<span class="subst">{item}</span>"</span>)</span><br><span class="line">        time.sleep(random.uniform(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"消费者结束"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 创建一个队列对象</span></span><br><span class="line">    q = Queue()</span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">2</span>) <span class="keyword">as</span> executor:</span><br><span class="line">        <span class="comment"># 启动生产者进程</span></span><br><span class="line">        executor.submit(producer, q)</span><br><span class="line">        <span class="comment"># 启动消费者进程</span></span><br><span class="line">        executor.submit(consumer, q)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h4 id="优先级队列示例"><a href="#优先级队列示例" class="headerlink" title="优先级队列示例"></a>优先级队列示例</h4><p>优先级队列按任务的优先级顺序处理任务。数字越小优先级越高。以下是如何使用 <code>PriorityQueue</code> 的示例：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建优先级队列</span></span><br><span class="line"><span class="comment"># 优先级队列的元素是元组，第一个元素是优先级，第二个元素是任务</span></span><br><span class="line">pq = queue.PriorityQueue()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_tasks</span>():</span><br><span class="line">    <span class="string">"""按照优先级处理任务"""</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            priority,task = pq.get(timeout=<span class="number">3</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f"处理任务:[优先级<span class="subst">{priority}</span>] <span class="subst">{task}</span>"</span>)</span><br><span class="line">            pq.task_done()</span><br><span class="line">        <span class="keyword">except</span> queue.Empty:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"队列为空，任务处理完毕"</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"><span class="comment"># 添加任务到优先级队列</span></span><br><span class="line">pq.put((<span class="number">3</span>, <span class="string">"普通任务"</span>))</span><br><span class="line">pq.put((<span class="number">1</span>, <span class="string">"紧急任务"</span>))</span><br><span class="line">pq.put((<span class="number">2</span>, <span class="string">"中等优先级任务"</span>))</span><br><span class="line">pq.put((<span class="number">1</span>, <span class="string">"另一个紧急任务"</span>))</span><br><span class="line">pq.put((<span class="number">5</span>, <span class="string">"低优先级任务"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建任务处理线程</span></span><br><span class="line">worker = threading.Thread(target=process_tasks)</span><br><span class="line">worker.start()</span><br><span class="line"></span><br><span class="line">pq.join()  <span class="comment"># 等待所有任务处理完毕</span></span><br><span class="line">worker.join()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"所有任务处理完毕"</span>)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></div></article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/06/16/684f747174bc3.webp" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/06/16/684f747174bc3.webp" title="头像" alt="头像"></a><div class="post-copyright__author_name">Prorise</div><div class="post-copyright__author_desc">这聒噪的世界让沉默的人显得另类</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://prorise-cool.github.io/2025/07/01/python%E8%AF%AD%E6%B3%95%E5%89%8D%E7%AF%87%E5%8D%81%E4%BA%94%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl(&quot;https://prorise-cool.github.io/2025/07/01/python%E8%AF%AD%E6%B3%95%E5%89%8D%E7%AF%87%E5%8D%81%E4%BA%94%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/&quot;)">Python语法前篇（十五）：第十四章：深入解析并发编程</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://tc.z.wiki/autoupload/iXoPwUD80CPTvQUyITTBFOykMT9FcWW5SasRoXZEs3Wyl5f0KlZfm6UsKj-HyTuv/20250609/bYMH/418X445/ef9a3f68-d36a-441a-95fe-8179b1a25992.png" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://tc.z.wiki/autoupload/iXoPwUD80CPTvQUyITTBFOykMT9FcWW5SasRoXZEs3Wyl5f0KlZfm6UsKj-HyTuv/20250609/bYMH/418X445/ef9a3f68-d36a-441a-95fe-8179b1a25992.png" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://tc.z.wiki/autoupload/iXoPwUD80CPTvQUyITTBFOykMT9FcWW5SasRoXZEs3Wyl5f0KlZfm6UsKj-HyTuv/20250609/cYu3/347X390/zfb.png" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://tc.z.wiki/autoupload/iXoPwUD80CPTvQUyITTBFOykMT9FcWW5SasRoXZEs3Wyl5f0KlZfm6UsKj-HyTuv/20250609/cYu3/347X390/zfb.png" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display:none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://prorise-cool.github.io/2025/07/01/python%E8%AF%AD%E6%B3%95%E5%89%8D%E7%AF%87%E5%8D%81%E4%BA%94%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=Python语法前篇（十五）：第十四章：深入解析并发编程&amp;url=https://prorise-cool.github.io/2025/07/01/python%E8%AF%AD%E6%B3%95%E5%89%8D%E7%AF%87%E5%8D%81%E4%BA%94%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/&amp;pic=https://bu.dusays.com/2025/06/17/685113b7c39b1.webp" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl(){var e=window.location.href,t=document.createElement("input");t.setAttribute("value",e),document.body.appendChild(t),t.select(),t.setSelectionRange(0,99999),document.execCommand("copy"),document.body.removeChild(t)}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://Prorise-cool.github.io" target="_blank">格物致知</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/Python-%E8%AF%AD%E6%B3%95%E7%AF%87/"><span class="tags-punctuation"><i class="anzhiyufont anzhiyu-icon-tag"></i></span>Python-语法篇<span class="tagsPageCount">15</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://bu.dusays.com/2025/06/17/685113b7c39b1.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media=&quot;all&quot;"><script src="https://lib.baomitu.com/social-share.js/1.0.16/js/social-share.min.js" defer=""></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2025/06/30/python%E8%AF%AD%E6%B3%95%E5%89%8D%E7%AF%87%E5%8D%81%E5%9B%9B%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/06/17/685113b7c39b1.webp" onerror="onerror=null,src=&quot;/img/404.jpg&quot;" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Python语法前篇（十四）：第十三章： 高级数据处理</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size:1.5rem;margin-right:4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2025/06/17/python%E8%AF%AD%E6%B3%95%E5%89%8D%E7%AF%87%E4%B8%80python-%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/" title="Python语法前篇（一）：Python 语言特性"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/06/17/685113b7c39b1.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-06-17</div><div class="title">Python语法前篇（一）：Python 语言特性</div></div></a></div><div><a href="/2025/06/19/python%E8%AF%AD%E6%B3%95%E5%89%8D%E7%AF%87%E4%B8%89%E7%AC%AC%E4%BA%8C%E7%AB%A0%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6/" title="Python语法前篇（三）：第二章：转义字符"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/06/17/685113b7c39b1.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-06-19</div><div class="title">Python语法前篇（三）：第二章：转义字符</div></div></a></div><div><a href="/2025/06/18/python%E8%AF%AD%E6%B3%95%E5%89%8D%E7%AF%87%E4%BA%8C%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%89%93%E5%8D%B0%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8Epycharm%E6%A8%A1%E6%9D%BF%E5%8F%98%E9%87%8F/" title="Python语法前篇（二）：第一章：字符串打印格式化与PyCharm模板变量"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/06/17/685113b7c39b1.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-06-18</div><div class="title">Python语法前篇（二）：第一章：字符串打印格式化与PyCharm模板变量</div></div></a></div><div><a href="/2025/06/23/python%E8%AF%AD%E6%B3%95%E5%89%8D%E7%AF%87%E4%B8%83%E7%AC%AC%E5%85%AD%E7%AB%A0%E6%9D%A1%E4%BB%B6%E5%BE%AA%E7%8E%AF%E5%88%86%E6%94%AF/" title="Python语法前篇（七）：第六章：条件循环分支"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/06/17/685113b7c39b1.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-06-23</div><div class="title">Python语法前篇（七）：第六章：条件循环分支</div></div></a></div><div><a href="/2025/06/24/python%E8%AF%AD%E6%B3%95%E5%89%8D%E7%AF%87%E5%85%AB%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/" title="Python语法前篇（八）：第七章： 文件操作"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/06/17/685113b7c39b1.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-06-24</div><div class="title">Python语法前篇（八）：第七章： 文件操作</div></div></a></div><div><a href="/2025/06/21/python%E8%AF%AD%E6%B3%95%E5%89%8D%E7%AF%87%E4%BA%94%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%AF%A6%E8%A7%A3/" title="Python语法前篇（五）：第四章：类型转换详解"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/06/17/685113b7c39b1.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-06-21</div><div class="title">Python语法前篇（五）：第四章：类型转换详解</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)" rel="external nofollow noreferrer">匿名评论</a><a href="/privacy" style="margin-left:4px">隐私政策</a></div><div class="comment-switch"><span class="first-comment">Twikoo</span><span id="switch-btn"></span><span class="second-comment">Waline</span></div><div class="comment-tips" id="comment-tips"><span>✅ 你无需删除空行，直接评论以获取最佳展示效果</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div><div><div id="waline-wrap"></div></div></div></div><div class="comment-barrage"></div><script>window.postData={title:"Python语法前篇（十五）：第十四章：深入解析并发编程",date:"2025-07-01 16:13:45",updated:"2025-06-17 17:51:07",tags:["Python-语法篇"],categories:["后端技术","Python"],content:'\n## 第十四章：深入解析并发编程\n\n### 14. 并发编程基本概念\n\n并发编程是指程序设计中允许多个任务同时执行的编程模式，它的核心目标是 **提升执行效率**。通过并发编程，原本需要 20 分钟执行的代码可能只需要 1 分钟就能完成。\n\n#### 进程调度机制解析\n\nCPU 在执行程序时会涉及进程调度，主要有两种切换情况：\n\n1. **I/O 操作触发切换**：当程序遇到 I/O 操作时，操作系统会剥夺该程序对 CPU 的执行权限\n2. **时间片用尽触发切换**：当一个程序长时间占用 CPU 时，操作系统也会剥夺程序对 CPU 的执行权限\n\n所谓 I/O 操作，指的为 `阻断` 程序的操作，类似于 `input()` 函数会将程序暂停运行，达到某一个条件后才会接触阻塞状态\n\n时间片即 CPU 分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片，即该进程允许运行的时间，使各个程序从表面上看是同时进行的。如果在时间片结束时进程还在运行，则 CPU 将被剥夺并分配给另一个进程。如果进程在时间片结束前阻塞或结束，则 CPU 当即进行切换。而不会造成 CPU 资源浪费。\n\n在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。\n\n但在微观上：由于只有一个 CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。\n\n\n\n#### 进程的三大状态与生命周期\n\n进程在其生命周期中会经历三种基本状态：\n\n![image-20250426212152903](assets/image-20250426212152903.png)\n\n\n\n首先一个程序想要被运行，当用户双击图标后，此时程序就会从硬盘加载到内存，所有的程序想要被执行就必须经历就绪态，然后等待 CPU 执行，就绪态之后会进入进程调度，然后运行\n\n运行时会出现以下几种情况：\n\n>- 1.时间片运行完毕，程序也执行完毕，释放资源后退出\n>- 2.程序运行过程遇到 I/O 操作（读写、发送网络请求）它是不需要 CPU 工作的，只要运行遇到了 I/O，操作系统就会把 CPU 拿走，执行其他的时间片，程序就会进入阻塞态，当 IO 请求完成后它就会结束阻塞态，回到就绪态里排队\n\n\n\n\n\n### 14.1 同步与异步编程模型\n\n#### 同步和异步\n\n同步：任务提交之后，原地等待任务的返回结果，等待的过程中不做任何事情\n\n异步：任务提交之后，不再等待任务的返回结果，而是去做一些其他的事情\n\n这两个概念主要 **描述任务的提交方式**：\n\n> 📝 **实际应用**：在 Web 开发中，同步请求会阻塞页面渲染，而异步请求（AJAX）则可以在后台处理数据，不影响用户体验。\n\n#### 阻塞和非阻塞\n\n这两个概念主要 **描述进程的运行状态**：\n\n- **阻塞**：对应进程的阻塞态\n- **非阻塞**：对应进程的就绪态、运行态\n\n结合同步/异步和阻塞/非阻塞，可以形成四种组合：\n- 同步阻塞\n- 同步非阻塞\n- 异步阻塞\n- **异步非阻塞**（CPU 利用率最高的一种模式）\n\n> 🔍 在实际开发中，异步非阻塞模式是高并发系统的首选模式，因为它允许程序在等待 I/O 操作时继续执行其他任务。\n\n---\n\n### 14.2 多进程编程技术\n\n#### 进程基础\n\n**进程** 是程序在计算机中的一次执行过程：\n\n- **程序** 是静态的可执行文件，占用磁盘空间\n- **进程** 是动态的执行过程，占用计算机运行资源\n\n类比：一个工厂有三个车间，每个车间一个工人（共 3 人），并行处理任务，相当于一个程序创建三个进程，每个进程一个线程（共 3 人），并行处理任务。\n\n#### 进程创建方法\n\n```python\nfrom multiprocessing import Process\nProcess(target,name,args,kwargs)\n\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\n功能 ： 创建进程对象\n参数 ：  \n\t  target 绑定要执行的目标函数 \n   \t  name 进程名，默认是Process-x(整数)\n\t  args 元组，用于给target函数位置传参\n\t  kwargs 字典，给target函数键值传参\n\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\'\n```\n\n##### 方法一：使用 Process 类创建进程\n\n```python\nfrom multiprocessing import Process\nimport time\nimport os\n\n\n# 创建进程的标准方法\ndef worker_function(name, age):\n    """子进程执行过程中触发的函数"""\n    print(f"子进程ID:{os.getpid()},父进程ID{os.getppid()}")\n    print(f"子进程正在执行，参数name={name},age={age}")\n    # 模拟耗时操作\n    time.sleep(5)\n    print(f"子进程{name}执行完毕")\n\n\ndef cpu_intensive_task(number):\n    """CPU密集型任务"""\n    result = 0\n    for i in range(number):\n        result += i * i\n    print(f"进程{os.getpid()} 计算完成，结果为{result}")\n\n\nif __name__ == \'__main__\':\n    print(f"父进程ID:{os.getpid()}")\n    start_time = time.time()\n\n    # 创建多个进程，体现并行处理能力\n    processes = []\n\n    # 创建四个检测执行不同人物\n    p1 = Process(target=worker_function, args=("张三",), kwargs={"age": 20})\n    p2 = Process(target=worker_function, args=("李四",), kwargs={"age": 30})\n    p3 = Process(target=cpu_intensive_task, args=(10000,))\n    p4 = Process(target=cpu_intensive_task, args=(20000,))\n\n    processes.extend([p1, p2, p3, p4]) # 将进程添加到列表中\n\n    for p in processes:\n        p.start() # 启动进程\n\n    # 等待所有进程结束\n    for p in processes:\n        p.join()\n\n    end_time = time.time()\n    print(f"所有进程执行完毕，总耗时{end_time - start_time:.2f}秒")\n    print("如果使用单进程顺序执行，耗时会更长，因为是两个任务在执行，多进程可以充分利用多核CPU并行处理任务")\n\n```\n\n> ⚠️ **重要提示**：在 Windows 系统中，必须在 `if __name__ == \'__main__\'` 条件下创建进程，这是因为 Windows 使用 spawn 方式创建进程，会重新导入模块，可能导致递归创建进程。\n\n##### 方法二：继承 Process 类创建进程\n\n```python\nfrom multiprocessing import Process\nimport time\nimport os\n\n\n# 通过继承Process类创建进程\nclass WorkerProcess(Process):\n    """继承Process类的自定义进程"""\n    def __init__(self, name, age=None):\n        super().__init__()\n        self.name = name\n        self.age = age\n    \n    def run(self):\n        """重写run方法，进程启动后会执行该方法"""\n        print(f"子进程ID:{os.getpid()},父进程ID{os.getppid()}")\n        print(f"子进程正在执行，参数name={self.name},age={self.age}")\n        # 模拟耗时操作\n        time.sleep(5)\n        print(f"子进程{self.name}执行完毕")\n\n\nclass CPUIntensiveProcess(Process):\n    """CPU密集型任务进程"""\n    def __init__(self, number):\n        super().__init__()\n        self.number = number\n    \n    def run(self):\n        """重写run方法，执行CPU密集型计算"""\n        result = 0\n        for i in range(self.number):\n            result += i * i\n        print(f"进程{os.getpid()} 计算完成，结果为{result}")\n\n\nif __name__ == \'__main__\':\n    print(f"父进程ID:{os.getpid()}")\n    start_time = time.time()\n\n    # 创建多个进程，体现并行处理能力\n    processes = []\n\n    # 创建四个进程实例\n    p1 = WorkerProcess("张三", 20)\n    p2 = WorkerProcess("李四", 30)\n    p3 = CPUIntensiveProcess(10000)\n    p4 = CPUIntensiveProcess(20000)\n\n    processes.extend([p1, p2, p3, p4]) # 将进程添加到列表中\n\n    for p in processes:\n        p.start() # 启动进程\n\n    # 等待所有进程结束\n    for p in processes:\n        p.join()\n\n    end_time = time.time()\n    print(f"所有进程执行完毕，总耗时{end_time - start_time:.2f}秒")\n```\n\n#### 多进程常用方法表\n\n| 方法名                | 说明               | 实际应用场景           |\n| --------------------- | ------------------ | ---------------------- |\n| `Process(target=...)` | 创建进程对象       | 指定新进程要执行的函数 |\n| `start()`             | 启动进程           | 开始执行进程的任务     |\n| `join()`              | 等待进程结束       | 协调多个进程的执行顺序 |\n| `is_alive()`          | 检查进程是否存活   | 监控进程状态           |\n| `terminate()`         | 强制终止进程       | 中断异常或超时的进程   |\n| `Queue()`             | 创建进程安全的队列 | 进程间数据传递         |\n| `put(item)`           | 添加元素到队列     | 向队列中放入数据       |\n| `get()`               | 从队列获取元素     | 从队列获取数据         |\n| `Pipe()`              | 创建管道对象       | 进程间双向通信         |\n\n#### 进程号与进程信息获取\n\n在多进程编程中，获取进程信息对于调试和管理至关重要。Python 的 `multiprocessing` 模块提供了 `current_process()` 方法来获取当前进程的信息。\n\n```python\nimport multiprocessing\nimport os\n\ndef process_info():\n    """打印当前进程的信息"""\n    # 获取当前进程对象\n    process = multiprocessing.current_process()\n    \n    print(f"进程名称: {process.name}")\n    print(f"进程ID: {process.pid}")\n    print(f"父进程ID: {os.getppid()}")\n    print(f"进程授权键: {process.authkey}")\n    print(f"进程是否活跃: {process.is_alive()}")\n    \nif __name__ == \'__main__\':\n    p = multiprocessing.Process(target=process_info, name="自定义进程名")\n    p.start()\n    p.join()\n```\n\n#### 进程间通信示例\n\n```python\nfrom multiprocessing import Process,Queue\nimport time\n\n## 子进程执行的函数\ndef worker(q):\n    """子进程函数，想往父进程发送消息，就往这个队列里放"""\n    print("子进程启动")\n    # 向队列中添加数据\n    q.put("我是一个队列数据")\n    time.sleep(2) # 模拟任务执行\n    print("子进程结束")\n\nif __name__ == \'__main__\':\n    q = Queue() # 父进程创建队列\n    # 创建一个子进程对象\n    p = Process(target=worker, args=(q,))\n    # 启动子进程\n    p.start()\n    # 主进程从队列中获取数据\n    print("主进程等待子进程数据....")\n    message = q.get() # 阻塞等待数据\n    print(f"主进程收到来自于子进程的消息：{message}")\n    # 等待子进程结束\n    p.join()\n    print("主进程结束")\n```\n\n#### 复杂进程通信示例\n\n```python\nimport os\nimport time\nfrom multiprocessing import Process, Queue, Lock, Value, Array\n\n\n## 子进程执行的函数\ndef worker_with_args(q, lock, value, arr, sleep_num):\n    """带有共享资源的工作函数\n    Args:\n        q: 队列\n        lock: 锁\n        value: 值\n        arr: 数组\n        sleep_num: 休眠时间\n    """\n    # 获取进程id\n    pid = os.getpid()\n    print(f"进程{pid}开始执行")\n\n    # 使用锁来保证数据安全\n    with lock:  # 相当于lock.acquire()和lock.release()的组合\n        value.value += 1\n        for i in range(len(arr)):\n            arr[i] **= 2  # 安全的修改数组元素\n            print(f"进程{pid}修改数组元素{i}为{arr[i]}")\n    # 向队列中添加数据\n    q.put(f"这是一条来自于进程{pid}的信息")\n\n    # 休眠模拟工作\n    time.sleep(sleep_num)\n\n    print(f"进程{pid}执行完毕")\n\n\nif __name__ == "__main__":\n    """\n    解释输出逻辑:\n    1. 创建了4个进程，它们共享同一个数组arr，初始值为[1,2,3,4,5]\n    2. 每个进程获取锁后，会将数组中的每个元素进行平方操作(arr[i] **= 2)\n    3. 由于进程是按顺序启动的，但执行顺序不确定，所以:\n       - 第一个获得锁的进程将[1,2,3,4,5]平方为[1,4,9,16,25]\n       - 第二个获得锁的进程将[1,4,9,16,25]平方为[1,16,81,256,625]\n       - 第三个获得锁的进程将[1,16,81,256,625]平方为[1,256,6561,65536,390625]\n       - 第四个获得锁的进程将[1,256,6561,65536,390625]平方，但由于整数溢出，\n         导致最后两个元素变成了0和负数\n    4. 进程完成的顺序取决于sleep_num参数(1,2,3,4)，所以最先完成的是第一个进程\n    """\n    # 创建队列\n    q = Queue()\n    # 创建锁\n    lock = Lock()\n    # 创建一个共享值\n    value = Value("i", 0)  # "i"表示int类型\n\n    # 创建一个共享数组\n    arr = Array("i", [1, 2, 3, 4, 5])\n\n    # 创建多个子进程\n    processes = []\n    for i in range(4):\n        p = Process(target=worker_with_args, args=(q, lock, value, arr, i + 1))\n        p.start()\n        processes.extend([p])\n```\n\n#### 进程池详解\n\n进程池是一种管理多个进程的方式，可以简化并行计算的编程。Python 的 `multiprocessing` 模块中的 `Pool` 类和 `concurrent.futures` 模块的 `ProcessPoolExecutor` 类都提供了进程池功能。\n\n##### 进程池的主要方法\n\n| 方法                      | 描述                              | 使用场景                     |\n| ------------------------- | --------------------------------- | ---------------------------- |\n| `Pool(processes=None)`    | 创建进程池，进程数默认为 CPU 核数 | 初始化进程池                 |\n| `apply(func, args)`       | 阻塞执行任务                      | 需要顺序执行且等待结果的场景 |\n| `apply_async(func, args)` | 非阻塞执行任务                    | 需要异步执行的场景           |\n| `map(func, iterable)`     | 并行执行映射任务                  | 对列表元素并行处理           |\n| `close()`                 | 关闭进程池，不再接受新任务        | 完成任务提交后               |\n| `terminate()`             | 立即终止所有工作进程              | 需要强制停止时               |\n| `join()`                  | 等待所有工作进程退出              | 在 close()后使用             |\n\n##### ProcessPoolExecutor 示例\n\n```python\nfrom concurrent.futures import ProcessPoolExecutor\nimport os\n\ndef worker_function(name,age):\n    """进程池工作函数"""\n    pid = os.getpid()\n    print(f"进程{pid}：{name}，{age}岁")\n    return f"我的父进程是{os.getppid()} 我结束进程了"\n\nif __name__ == \'__main__\':\n    with ProcessPoolExecutor(max_workers=4) as executor:\n        for i in range(10):\n            # submit方法提交任务到进程池，返回一个Future对象\n            # submit参数: function, *args, **kwargs\n            # 这里的i作为worker_function函数的第二个参数age传入\n            future = executor.submit(worker_function, f"小明{i}", i)\n            # 等待future对象返回结果\n            result = future.result()\n            print(result)\n```\n\nPool 对象示例\n\n```python\nfrom multiprocessing import Pool\nimport os\n\ndef worker_function(args):\n    """工作进程函数"""\n    name,age = args\n    pid = os.getpid()\n    print(f"进程{pid}：{name}，{age}岁")\n    return f"我的父进程是{os.getppid()} 我结束进程了"\n\nif __name__ == \'__main__\':\n    with Pool() as pool:\n        # 准备参数列表\n        args_list = [(f"张三{i}号", i+18) for i in range(1,10)]\n        \n        # map方法将函数应用于参数列表，并返回结果列表\n        # pool.map 的工作原理:\n        # 1. 它接收两个参数：要执行的函数(worker_function)和可迭代的参数列表(args_list)\n        # 2. 它会自动将参数列表中的每个元素分配给不同的进程来执行\n        # 3. 每个进程会调用worker_function并传入args_list中的一个元素作为参数\n        # 4. 所有进程执行完毕后，map会收集所有进程的返回值，并按原始参数的顺序返回结果列表\n        # 5. 这样实现了并行处理，提高了计算效率\n        result_list = pool.map(worker_function, args_list)\n        \n        # 打印每个进程的返回结果\n        for result in result_list:\n            print(result)\n```\n\n#### 进程号与进程信息获取\n\n在多进程编程中，获取进程信息对于调试和管理至关重要。Python 的 `multiprocessing` 模块提供了 `current_process()` 方法来获取当前进程的信息。\n\n```python\nimport multiprocessing\nimport os\n\ndef process_info():\n    """打印当前进程的信息"""\n    # 获取当前进程对象\n    process = multiprocessing.current_process()\n    \n    print(f"进程名称: {process.name}")\n    print(f"进程ID: {process.pid}")\n    print(f"父进程ID: {os.getppid()}")\n    print(f"进程授权键: {process.authkey}") # 授权键用于在进程间通信时进行身份验证。\n    print(f"进程是否活跃: {process.is_alive()}")\n    \nif __name__ == \'__main__\':\n    p = multiprocessing.Process(target=process_info, name="自定义进程名")\n    p.start()\n    p.join()\n```\n\n\n\n\n\n##### 进程状态特殊情况\n\n###### 僵尸进程\n\n```python\n\'\'\'\n子进程死后还会有一些资源占用(进程号，进程的运行状态，运行时间)，等待父进程通过系统调用\n进行资源回收\n\n相当于子进程死了之后，需要父进程来给他"收尸"\n除了init进程之外，所有的进程最后都会步入僵尸进程\n在一种情况下是会带来危害的:\n子进程退出之后，父进程没有及时处理，僵尸进程就会一直占用资源\n如果产生了大量僵尸进程，资源过度使用，系统没有可用的进程号，导致系统不能产生新的进程\n\'\'\'\n```\n\n> 注意：在 Windows 中，子进程退出后会立即被系统回收，不会产生真正的僵尸进程，在 Windows 系统中，不需要显式调用 wait 来回收子进程资源\n\n###### 孤儿进程\n\n```python\n\'\'\'\n子进程处于存活状态，父进程意外死亡，操作系统就会开设一个孤儿院（init进程），用来管理\n孤儿进程，回收孤儿进程相关资源\n\'\'\'\n```\n\n> 📝 **知识点**：操作系统会自动处理孤儿进程，将它们的父进程更改为 init 进程（PID 为 1），所以孤儿进程不会造成资源泄漏问题。\n\n### 14.3 多线程编程深入解析\n\n#### 线程基础\n\n**线程** 是轻量级的进程，也是多任务编程的一种方式：\n- 一个进程中可以包含多个线程\n- 线程也是一个运行行为，消耗计算机资源\n- 一个进程中的所有线程共享这个进程的资源\n- 线程的创建和销毁消耗资源远小于进程\n\n一个工厂至少有一个车间，一个车间中至少有一个工人，工人去利用车间的设备工作；\n\n一个程序至少有一个进程，一个进程中至少有一个线程，线程去利用进程的资源工作。\n\n#### 线程创建方法\n\n##### 方法一：使用 Thread 类创建线程\n\n```python\nfrom threading import Thread\nimport time\n\ndef worker_function(name,delay):\n    print(f"线程{name}开始工作")\n    time.sleep(delay)\n    print(f"线程{name}结束工作")\n\nif __name__ == \'__main__\':\n    t1 = Thread(target=worker_function,args=("线程1",2))\n    t2 = Thread(target=worker_function,args=("线程2",4))\n    # 启动线程\n    t1.start()\n    t2.start()\n    # 等待线程结束\n    t1.join()\n    t2.join()\n    print("主线程结束")\n```\n\n##### 方法二：继承 Thread 类创建线程\n\n```python\nfrom threading import Thread\nimport time\nclass MyThread(Thread):\n    def __init__(self,name,message):\n        super().__init__()\n        self.name = name\n        self.message = message\n\n    def run(self):\n        print(f"线程{self.name}开始执行")\n        time.sleep(2)\n        print(f"线程{self.name}执行完毕，消息：{self.message}")\n\nif __name__ == \'__main__\':\n    t1 = MyThread(name="线程1",message="子进程操作完毕")\n    t2 = MyThread(name="线程2",message="子进程操作完毕")\n    t1.start()\n    t2.start()\n    t1.join()\n    t2.join()\n    print("主进程执行完毕")\n```\n\n#### 线程常用方法表\n\n| 方法名           | 说明                     | 实际应用场景                 |\n| ---------------- | ------------------------ | ---------------------------- |\n| `start()`        | 启动线程                 | 开始执行线程任务             |\n| `run()`          | 定义线程执行的任务       | 重写该方法自定义线程行为     |\n| `join()`         | 等待线程结束             | 协调线程执行顺序             |\n| `join(timeout)`  | 等待线程结束，有超时时间 | 防止无限等待                 |\n| `is_alive()`     | 检查线程是否活动         | 监控线程状态                 |\n| `getName()`      | 获取线程名称             | 调试和日志记录               |\n| `setName(name)`  | 设置线程名称             | 便于识别不同线程             |\n| `setDaemon(T/F)` | 设置为守护线程           | 随主线程结束而结束的后台任务 |\n| `isDaemon()`     | 检查是否为守护线程       | 确认线程类型                 |\n| `getId()`        | 获取线程 ID              | 唯一标识线程                 |\n| `current_thread` | 获取当前线程对象         | 在函数中获取当前执行线程     |\n\n#### 线程使用实例\n\n##### 基本线程示例\n\n```python\nfrom threading import Thread\nimport time\nimport requests\n\ndef download_file(url,session):\n    """访问网站下载文件"""\n    with session.get(url) as response:\n        print(f"读取{url} 长度为{len(response.content)}")\n\n\ndef download_all_sites(urls):\n    """单线程下载所有网站"""\n    with requests.Session() as session:\n        for url in urls:\n            download_file(url,session)\n            time.sleep(1)\n\ndef download_site_thread(url,session):\n    """多线程下载网站"""\n    download_file(url,session)\n\ndef download_all_sites_thread(urls):\n    """多线程下载所有网站"""\n    threads = []\n    with requests.Session() as session:\n        for url in urls:\n            thread = Thread(target=download_site_thread, args=(url,session))\n            threads.append(thread)\n            thread.start()\n        # 等待所有线程结束\n        for thread in threads:\n            thread.join()\nif __name__ == \'__main__\':\n    # 准备一些网站用于演示\n    sites = [\n        "https://www.baidu.com",\n        "https://www.sina.com.cn",\n        "https://www.qq.com",\n        "https://www.163.com",\n        "https://www.sohu.com",\n    ]\n    # 单线程下载\n    print("=======单线程下载开始========")\n    start_time = time.time()\n    download_all_sites(sites)\n    end_time = time.time()\n    print(f"单线程下载结束，耗时{end_time-start_time}秒")\n\n    print("\\n=======多线程下载开始========")\n    start_time = time.time()\n    download_all_sites_thread(sites)\n    end_time = time.time()\n    print(f"多线程下载结束，耗时{end_time-start_time}秒")\n    print("\\nIO密集型任务（如网络请求）适合使用多线程，可以显著提高性能")\n    print("这是因为当一个线程等待IO操作完成时，其他线程可以继续执行")\n\n```\n\n##### 守护线程示例\n\n```python\nfrom threading import Thread\nimport time\n\ndef worker_function(thread_name):\n    print(f"线程 {thread_name} 启动")\n    time.sleep(3)\n    print(f"线程 {thread_name} 结束")\n\n\nif __name__ == \'__main__\':\n    t1 = Thread(target=worker_function, args=("Thread-1",))\n    t2 = Thread(target=worker_function, args=("Thread-2",))\n    # 设置t3为守护线程，主线程结束时，t3线程也会结束\n    t3 = Thread(target=worker_function, args=("Thread-3",), daemon=True)\n    # t3.setDaemon(True) # 已经被废弃的API，现在使用daemon=True参数代替\n    # 启动普通线程\n    t1.start()\n    t2.start()\n    # 启动守护线程\n    t3.start()  # 这里需要启动t3线程，否则t3不会执行\n\n    # 等待普通线程完成\n    print(f"等待线程{t1.name} + {t2.name}完成...")\n    t1.join()\n    t2.join()\n\n    # 检测线程状态\n    print(f"线程{t1.name}是否存活：{t1.is_alive()}")\n    print(f"线程{t2.name}是否存活：{t2.is_alive()}")\n    print(f"线程{t3.name}是否存活：{t3.is_alive()}")  # True\n\n    # 主线程休眠一段时间，以便守护线程有机会执行\n    time.sleep(10)\n    print("主线程结束")\n```\n\n> 💡 **守护线程特性**：守护线程会随着主线程的结束而结束，不管它是否执行完成。适用于需要在后台运行但不要求必须完成的任务，如监控、日志记录等。\n\n```python\nfrom threading import Thread\nimport time\nimport logging\nimport psutil\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\'%(asctime)s %(levelname)s %(message)s\',\n)\n\ndef system_monitor(interval=1):\n    """\n    守护线程：系统资源监控器\n    持续监控CPU使用率和内存使用情况，并记录到日志中\n    """\n    logging.info(\'系统监控守护线程启动\')\n    try:\n        while True:\n            cpu_usage = psutil.cpu_percent(interval=interval)\n            mem_usage = psutil.virtual_memory().percent\n            logging.info(f\'CPU使用率：{cpu_usage}% 内存使用率：{mem_usage}%\')\n            time.sleep(interval)\n            if cpu_usage > 80 or mem_usage > 80:\n                logging.warning(\'系统资源占用过高，请及时处理\')\n    except Exception as e:\n        logging.error(f\'系统监控线程异常：{e}\')\n    finally:\n        logging.info(\'系统监控守护线程结束\')\nif __name__ == \'__main__\':\n    # 创建并启动系统监控守护线程\n    monitor_thread = Thread(target=system_monitor,args=(1,),daemon=True,name="MonitorThread")\n    monitor_thread.start()\n    # 主线程继续执行一段时间，守护线程在后台运行\n    logging.info("主线程运行中，监控守护线程在后台运行...")\n    time.sleep(30)  # 运行30秒后结束\n    # 主线程结束，守护线程将自动终止\n    logging.info(f"监控守护线程是否存活: {monitor_thread.is_alive()}")\n    logging.info("主线程结束，守护线程将自动终止")\n```\n\n\n\n#### 线程池详解\n\n线程池是一种管理线程资源的方式，它预先创建一定数量的线程，然后复用这些线程来执行任务，避免了频繁创建和销毁线程的开销。\n\n```python\nfrom concurrent.futures import ThreadPoolExecutor\nimport time\n\n\n# 定义一个耗时函数\ndef time_consuming_task(n):\n    time.sleep(1)\n    return n * n\n\n\nif __name__ == \'__main__\':\n    start_time = time.time()\n    with ThreadPoolExecutor(max_workers=4) as executor:\n        # 使用submit方法提交任务给线程池执行，返回Future对象列表\n        futures = [executor.submit(time_consuming_task, i) for i in range(1, 21)]\n        print("任务已提交，主线程继续执行.........")\n        # 等待所有任务完成，并获取结果\n        results = [future.result() for future in futures]\n        print(f"任务执行完毕，结果为：{results}")\n    end_time = time.time()\n    print(f"总共耗时：{end_time - start_time}秒")\n    ### 线程池在with语句结束时自动关闭\n```\n\n##### ThreadPoolExecutor 主要方法\n\n| 方法名                  | 简洁解释                       | 适用场景               |\n| ----------------------- | ------------------------------ | ---------------------- |\n| `submit(fn, *args)`     | 异步执行函数，返回 Future 对象 | 单独提交任务并获取结果 |\n| `map(func, *iterables)` | 对每个输入并行执行函数         | 批量处理类似任务       |\n| `shutdown(wait=True)`   | 关闭执行器                     | 资源释放               |\n| `result()`              | 获取任务执行结果               | 获取异步任务的返回值   |\n| `add_done_callback(fn)` | 添加任务完成回调函数           | 任务完成后的后续处理   |\n| `as_completed()`        | 返回已完成任务的迭代器         | 先处理先完成的任务     |\n| `wait()`                | 等待任务完成                   | 任务同步点             |\n\n> 🔍 **深入理解**：线程池最大的好处是控制并发数量，防止系统资源被耗尽。在实际开发中，建议将线程数设置为 CPU 核心数的 1-5 倍，具体取决于任务是 I/O 密集型还是 CPU 密集型。\n\n##### 完整示例\n\n```python\nfrom concurrent.futures import ThreadPoolExecutor,as_completed,wait\nimport time\n\ndef time_consuming_task(n):\n    """耗时任务"""\n    time.sleep(n % 3 +1) # 不同的n值，耗时不同\n    return n * n\n\ndef task_done_callback(future):\n    """任务完成后触发的回调函数"""\n    print(f"任务完成，结果为{future.result()}")\n\nif __name__ == \'__main__\':\n    print("===== 1. submit方法示例 =====")\n    start_time = time.time()\n    with ThreadPoolExecutor(max_workers=3) as executor:\n        future_list = [executor.submit(time_consuming_task, i) for i in range(10)]\n        print("提交任务完成，等待结果...")\n        # result()：获取任务执行结果，会阻塞直到所有任务完成\n        # as_completed(): 返回已完成任务的迭代器\n        for future in as_completed(future_list):\n            print(f"任务{future.result()}完成")\n    end_time = time.time()\n    print(f"总耗时：{end_time - start_time}秒")\n\n    print("\\n===== 2. map方法示例 =====")\n    start_time = time.time()\n    with ThreadPoolExecutor(max_workers=4) as executor:\n        # map()：对每一个输入并行执行函数，返回结果迭代器\n        # 与submit不同，map会自动收集结果并按输入顺序返回\n        # 不需要手动调用future.result()\n        results = executor.map(time_consuming_task, range(10))\n        print("任务提交完成，直接获取有序结果...")\n        # 转换为列表时会按照输入顺序返回结果，如果任务未完成会在这里阻塞等待\n        results_list = list(results)\n        print(f"结果：{results_list}")\n    end_time = time.time()\n    print(f"总耗时：{end_time - start_time}秒")\n\n    print("\\n===== 3. add_done_callback示例 =====")\n    # add_done_callback(fn): 添加任务完成回调函数\n    start_time = time.time()\n    with ThreadPoolExecutor(max_workers=4) as executor:\n        futures = []\n        for i in range(1, 6):\n            future = executor.submit(time_consuming_task, i)\n            # 添加回调函数，任务完成后自动调用\n            future.add_done_callback(task_done_callback)\n            futures.append(future)\n        print("已添加回调函数，主线程继续执行...")\n        # 等待所有任务完成\n        for future in futures:\n            future.result()\n    print(f"耗时：{time.time() - start_time}秒")\n    # 适用场景：任务完成后的后续处理，适合需要在任务完成时执行额外操作而不阻塞主线程\n\n    print("\\n===== 4. wait示例 =====")\n    # wait(): 等待任务完成\n    start_time = time.time()\n    with ThreadPoolExecutor(max_workers=4) as executor:\n        futures = [executor.submit(time_consuming_task, i) for i in range(1, 11)]\n        print("任务已提交，等待所有任务完成...")\n        # 等待所有任务完成\n        done, not_done = wait(futures)\n        print(f"完成的任务数: {len(done)}, 未完成的任务数: {len(not_done)}")\n        results = [future.result() for future in done]\n        print(f"所有任务执行完毕，结果为：{results}")\n    print(f"耗时：{time.time() - start_time}秒")\n    # 适用场景：任务同步点，适合需要等待一组任务全部或部分完成后再继续执行的情况\n```\n\n\n\n#### Event 事件同步机制\n\nEvent 是一种线程同步机制，用于协调多个线程的执行顺序。它本质上是一个内部的标志位，线程可以等待这个标志位被设置，也可以设置或清除这个标志位。\n\n```python\nfrom threading import Thread, Event\nimport time\n\n## 创建一个事件对象\nevent = Event()\n\n## 模拟公交车到站的函数\ndef bus_stop():\n    """模拟公交车到站过程"""\n    print(\'公交车即将到站\')\n    time.sleep(2)  # 模拟行驶时间\n    print(\'公交车已到站<====>\'*10)\n    # 设置事件，通知等待的乘客\n    event.set()  # 发射信号，让等车的人上车\n\n\ndef passenger(name):\n    """模拟乘客等车\n    \n    Args:\n        name: 乘客名称\n    """\n    # 等待公交车到站\n    print(name, \'等车中\')\n    event.wait()  # 阻塞等待信号\n    print(name, \'出发！！！！！！！！！！！！！！！！！！！！！！！！！！\')\n\n\nif __name__ == \'__main__\':\n    # 创建公交车线程\n    t1 = Thread(target=bus_stop)\n    t1.start()\n\n    # 创建多个乘客线程\n    for i in range(20):\n        t = Thread(target=passenger, args=(f\'乘客{i}\',))\n        t.start()\n        time.sleep(0.1)  # 模拟乘客陆续到站\n```\n\n##### Event 主要方法\n\n| 方法名     | 描述                 | 使用场景                     |\n| ---------- | -------------------- | ---------------------------- |\n| `set()`    | 设置事件标志为 True  | 通知等待的线程继续执行       |\n| `clear()`  | 清除事件标志为 False | 重置事件状态，使线程再次等待 |\n| `is_set()` | 检查事件状态         | 判断事件是否已被设置         |\n| `wait()`   | 等待事件被设置       | 阻塞线程直到事件被设置或超时 |\n\n> 🌟 **应用场景**：Event 适合实现一次性通知多个线程的场景，比如多个工作线程等待初始化完成、多个消费者等待数据准备就绪等。在 Web 开发中，可用于协调多个后台任务的启动时机。\n\n#### 定时器(Timer)\n\n定时器是线程的一个特殊应用，用于在指定时间后执行某个操作。Python 的 `threading` 模块提供了 `Timer` 类来实现这一功能。\n\n```python\nfrom threading import Timer\n\ndef delayed_greeting(name):\n    """延迟执行的问候函数\n    \n    Args:\n        name: 要问候的对象名称\n    """\n    print(f"{name}说: 哈哈，我是延迟1秒后才执行的!")\n\n## 创建一个定时器，1秒后执行hello函数，参数为"小明"\ntimer = Timer(1, delayed_greeting, args=("小明",))\n## 启动定时器\ntimer.start()\n\nprint("定时器已启动，但greeting函数还未执行...")\n## 主线程继续执行，不会被阻塞\n```\n\n> 💡 **实用技巧**：Timer 可用于实现超时处理、延迟重试、定时清理等场景。例如，在网络编程中，可以用 Timer 设置请求超时机制；在数据同步中，可以用 Timer 定期执行同步任务。\n\n### 14.4 多进程 VS 多线程性能分析\n\n在 Python 中，由于 GIL(全局解释器锁)的存在，多线程并不能真正实现并行计算。因此，根据任务特性选择合适的并发模型十分重要。\n\n#### 不同场景的最优选择\n\n| 任务类型   | 多进程             | 多线程                       | 推荐选择 |\n| ---------- | ------------------ | ---------------------------- | -------- |\n| 计算密集型 | 效率高，可利用多核 | 受 GIL 限制，效率相对较低    | 多进程   |\n| IO 密集型  | 资源占用大         | 资源占用小，效率与多进程相当 | 多线程   |\n\n> 📊 **实际应用建议**：现代开发中，约 90%以上的程序属于 IO 密集型，适合使用多线程；对于数据分析、图像处理等计算密集型任务，则推荐使用多进程。也可以考虑混合使用：多进程下每个进程内再使用多线程。\n\n#### 计算密集型任务测试\n\n```python\nfrom multiprocessing import Process\nfrom threading import Thread\nimport time\n\n\'\'\'\n计算密集型任务对比测试\n\'\'\'\ndef task():\n    """计算密集型任务"""\n    res = 0\n    for i in range(10000000):  # 执行大量计算\n        res += i\n\nif __name__ == \'__main__\':\n    start_time = time.time()\n    l = []\n\n    for i in range(10):\n        # 使用多进程或多线程(取消相应的注释来测试)\n        p = Process(target=task)  # 多进程：结果大概是1.65秒\n        # p = Thread(target=task)   # 多线程：结果大概是4.18秒\n        \n        p.start()\n        l.append(p)\n\n    for p in l:\n        p.join()\n\n    end = time.time()\n    print("花费时间", end - start_time)\n```\n\n#### IO 密集型任务测试\n\n```python\nfrom multiprocessing import Process\nfrom threading import Thread\nimport time\n\n\'\'\'\nIO密集型任务对比测试\n\'\'\'\ndef task():\n    """IO密集型任务，使用sleep模拟IO操作"""\n    time.sleep(1)  # 模拟IO等待\n    \nif __name__ == \'__main__\':\n    start_time = time.time()\n    l = []\n\n    for i in range(100):  # 创建100个任务\n        # 使用多进程或多线程(取消相应的注释来测试)\n        # p = Process(target=task)  # 多进程：结果约19.34秒\n        p = Thread(target=task)   # 多线程：结果约1.01秒\n        \n        p.start()\n        l.append(p)\n\n    for p in l:\n        p.join()\n\n    end = time.time()\n    print("花费时间", end - start_time)\n```\n\n> ⚠️ **性能陷阱**：多线程在 IO 密集型任务中表现出色，但过多的线程可能导致线程切换开销增大，反而降低效率。经验值是控制线程数为 CPU 核心数的 2-4 倍。\n\n\n### 14.5 协程技术详解\n\n#### 协程基础概念\n\n**协程**（Coroutine）也称为微线程，是一种用户态内的上下文切换技术，可以在单线程下实现并发效果。协程通过巧妙的编程技巧实现了程序主动让出和恢复执行的能力，使得单线程内可以 "模拟" 出并发的效果。\n\n```python\n\'\'\'\n进程：资源单位 - 系统分配资源的基本单位，拥有独立的内存空间\n线程：执行单位 - CPU调度和执行的最小单位，共享所属进程的内存空间\n协程：根本不存在，它是程序员人为创造出来的(切换+保存状态)\n当程序遇到IO的时候，通过我们的代码，让我们的程序自动完成切换\n也就是通过代码监听IO，一旦程序遇到IO，就在代码层面自动切换，给CPU的感觉就是我们的程序没有IO\n换句话说也就是我们欺骗了CPU\n\'\'\'\n```\n\n协程的核心原理是 "**切换+保存状态**"，即在多个任务之间来回切换，每次切换都保存当前任务的执行状态，下次切换回来继续执行。在 Python 中，可以通过 `yield` 关键字、`greenlet` 模块或 `asyncio` 库实现协程。\n\n> 🔍 **深入理解**：协程不是提升计算效率，而是提升 IO 效率。在 IO 密集型应用中，协程可以让 CPU 在等待 IO 的同时执行其他任务，从而提高资源利用率。协程的切换不需要操作系统参与，开销远小于线程切换。\n\n| 概念 | 资源占用                 | 切换开销           | 实现方式     | 适用场景                   |\n| ---- | ------------------------ | ------------------ | ------------ | -------------------------- |\n| 进程 | 高（独立内存空间）       | 高（涉及内存映射） | 操作系统调度 | CPU 密集型，需要隔离的任务 |\n| 线程 | 中（共享内存但有独立栈） | 中（上下文切换）   | 操作系统调度 | 混合型任务，兼顾计算与 IO  |\n| 协程 | 低（共享线程内全部资源） | 低（用户态切换）   | 程序自行控制 | IO 密集型，高并发网络应用  |\n\n#### 协程效率对比\n\n对于计算密集型任务时，使用协程反而会降低效率！\n\n##### 串行执行\n\n```python\nimport time\n\ndef f1():\n    """计算密集型函数1"""\n    n = 0\n    for i in range(10000000):\n        n += i  # 执行简单累加计算\n\ndef f2():\n    """计算密集型函数2"""\n    n = 0\n    for i in range(10000000):\n        n += i  # 执行简单累加计算\n\nstart_time = time.time()\nf1()  # 顺序执行f1\nf2()  # 然后执行f2\n## 保留两位小数\nprint("串行执行总共用时：%.2f秒" % (time.time() - start_time))  # 串行执行总共用时：0.84秒\n```\n\n##### 使用 yield 实现协程切换\n\n```python\nimport time\n\ndef f1():\n    """带yield的计算密集型函数1"""\n    n = 0\n    for i in range(10000000):\n        n += i\n        yield  # 主动让出执行权，保存当前执行状态\n\ndef f2():\n    """使用f1的生成器进行交替执行"""\n    g = f1()  # 创建生成器对象\n    n = 0\n    for i in range(10000000):\n        n += i\n        next(g)  # 切换到f1执行一步，f1会执行到下一个yield后暂停\n\nstart_time = time.time()\nf2()  # 执行f2，内部会与f1交替执行\n## 保留两位小数\nprint("yield协程用时：%.2f秒" % (time.time() - start_time))  # 约1.45秒\n```\n\n> ⚠️ **注意事项**：对于计算密集型任务，协程切换反而会增加开销，降低效率；但对于 IO 密集型任务，协程切换可以显著提高效率。这是因为在 IO 等待期间，协程可以切换到其他任务继续执行，避免了 CPU 空闲。\n\n#### greenlet 模块（了解）\n\ngreenlet 是一个轻量级的协程库，提供了基本的协程实现。它允许在不使用回调函数的情况下，在不同函数间来回切换执行，实现了所谓的 "确定性切换"。\n\n```python\nfrom greenlet import greenlet\nimport time\n\ndef func_a():\n    """协程函数a"""\n    while True:\n        print(\'函数a正在运行\')\n        time.sleep(1)  # 模拟某些操作\n        b.switch()  # 主动切换到函数b执行\n\ndef func_b():\n    """协程函数b"""\n    while True:\n        print(\'函数b正在运行\')\n        time.sleep(2)  # 模拟某些操作\n        a.switch()  # 切换回函数a执行\n\nif __name__ == \'__main__\':\n    # 创建两个greenlet对象\n    a = greenlet(func_a)  # 将函数封装为greenlet对象\n    b = greenlet(func_b)  # 将函数封装为greenlet对象\n    # 从函数a开始执行\n    a.switch()  # 启动协程a\n```\n\n##### greenlet 核心方法与属性\n\n| 方法/属性名                        | 描述                             | 使用场景             | 示例                              |\n| ---------------------------------- | -------------------------------- | -------------------- | --------------------------------- |\n| `greenlet.getcurrent()`            | 获取当前正在执行的 greenlet 对象 | 在函数内获取当前协程 | `current = greenlet.getcurrent()` |\n| `greenlet.switch(value=None)`      | 将控制权切换到另一个 greenlet    | 协程间的主动切换     | `g.switch(\'传递参数\')`            |\n| `greenlet.parent`                  | 获取当前 greenlet 的父 greenlet  | 协程层级管理         | `parent = g.parent`               |\n| `throw(type, value=None, tb=None)` | 向 greenlet 对象中抛出异常       | 协程异常处理         | `g.throw(ValueError, \'错误信息\')` |\n| `dead`                             | 判断 greenlet 是否已经执行完毕   | 协程状态检查         | `if g.dead: print(\'已执行完毕\')`  |\n| `gr_frame`                         | 获取 greenlet 当前的帧对象       | 调试和检查协程状态   | `frame = g.gr_frame`              |\n| `run`                              | 绑定到 greenlet 的可调用对象     | 查看协程的目标函数   | `func = g.run`                    |\n\n> 💡 **使用技巧**：greenlet 适合实现简单的协程切换，但不支持自动在 IO 操作时切换，因此常与事件循环结合使用，如 gevent 库。greenlet 的优势在于它的轻量和灵活性，可以构建复杂的协程调度系统。\n\n#### gevent 模块（了解）\n\ngevent 是基于 greenlet 的协程库，增加了事件循环和自动 IO 切换功能。它通过 "猴子补丁"（monkey patching）将标准库中的阻塞操作替换为非阻塞版本，使普通的同步代码能够以异步方式执行。\n\n```python\n\'\'\'\ngevent 是一个基于协程的 Python 网络库，它使用 greenlet 在 libev 或 libuv \n等事件循环之上提供高级同步 API。gevent 实现了python 标准库里面大部分的阻塞式系统调用，\n包括 socket、ssl、threading 和 select 等模块，\n可以使用 "猴子补丁" 将这些阻塞式调用变为协作式运行。\n\n猴子补丁的功能很强大，但是也带来了很多的风险，尤其是像 gevent 这种直接进行 API替换的补丁，\n整个 Python 进程所使用的模块都会被替换，可能自己的代码能 hold 住，\n但是其它第三方库，有时候问题并不好排查，即使排查出来也是很棘手，所以，\n就像松本建议的那样，如果要使用猴子补丁，那么只是做功能追加，\n尽量避免大规模的 API 覆盖。 虽然猴子补丁仍然是邪恶的(evil)，\n但在这种情况下它是 "有用的邪恶(useful evil)"。\n\'\'\'\n```\n\n##### gevent 基础操作\n\n```python\nimport gevent\nfrom gevent import monkey\n\n## 应用猴子补丁，将标准库的阻塞操作替换为非阻塞版本\n## 必须在导入其他模块前调用，确保所有IO操作都被替换\nmonkey.patch_all()  # 替换所有可能的阻塞调用\n\ndef foo():\n    """协程函数1"""\n    print(\'Running in foo\')\n    gevent.sleep(0)  # 模拟IO操作，主动让出控制权\n    print(\'Explicit context switch to foo\')\n\ndef bar():\n    """协程函数2"""\n    print(\'Running in bar\')\n    gevent.sleep(0)  # 模拟IO操作，主动让出控制权\n    print(\'Explicit context switch to bar\')\n\ndef baz():\n    """协程函数3"""\n    print(\'Running in baz\')\n    gevent.sleep(0)  # 模拟IO操作，主动让出控制权\n    print(\'Explicit context switch to baz\')\n\n## 创建三个协程\ng1 = gevent.spawn(foo)  # 创建协程但不立即执行\ng2 = gevent.spawn(bar)  # 创建协程但不立即执行\ng3 = gevent.spawn(baz)  # 创建协程但不立即执行\n\n## 等待所有协程完成\ngevent.joinall([g1, g2, g3])  # 类似于多线程中的join方法\n```\n\n##### gevent 常用 API 详解\n\n| 方法/类名                                                    | 描述                 | 使用场景                     | 实际应用示例                        |\n| ------------------------------------------------------------ | -------------------- | ---------------------------- | ----------------------------------- |\n| `gevent.spawn(function, *args, **kwargs)`                    | 创建并运行协程       | 启动异步任务                 | 启动多个 HTTP 请求并行处理          |\n| `gevent.joinall(greenlets, timeout=None, raise_error=False)` | 等待多个协程完成     | 同步点，等待所有任务完成     | 批量处理多个数据源                  |\n| `gevent.sleep(seconds=0)`                                    | 协程休眠并让出控制权 | 模拟 IO 操作，主动让出控制权 | 测试协程调度，防止 CPU 密集任务阻塞 |\n| `gevent.wait(objects=None, timeout=None, count=None)`        | 等待对象(协程)完成   | 等待部分任务完成             | 等待最快完成的结果                  |\n| `gevent.kill(greenlet, exception=GreenletExit)`              | 终止协程             | 取消不需要的任务             | 实现任务超时取消                    |\n| `gevent.monkey.patch_all(socket=True, dns=True, ...)`        | 应用猴子补丁         | 将同步库变为异步兼容         | 使用前替换标准库函数                |\n| `gevent.queue.Queue`                                         | 协程安全的队列       | 协程间通信和数据传递         | 生产者-消费者模式实现               |\n| `gevent.event.Event`                                         | 事件通知机制         | 协程间同步和通知             | 完成信号传递                        |\n| `gevent.pool.Pool`                                           | 协程池               | 限制并发数量                 | 控制网络请求并发数                  |\n| `gevent.select.select()`                                     | IO 多路复用          | 监控多个文件描述符           | 自定义事件循环                      |\n\n> ⚠️ **使用 gevent 注意事项**：\n> 1. 所有协程运行在同一线程中，不能跨线程同步数据\n> 2. gevent.queue.Queue 是协程安全的，可以用于协程间通信\n> 3. 不能有长时间阻塞的 CPU 密集型操作，会阻塞整个事件循环\n> 4. 最好使用 gevent 自身的非阻塞库或已打补丁的标准库\n> 5. 猴子补丁会修改全局状态，可能影响第三方库的行为，应在所有导入前应用\n> 6. 调试协程比调试线程更困难，错误追踪可能会更复杂\n\n##### 实际应用场景示例\n\n```python\nimport gevent\nfrom gevent import monkey\nimport requests\nimport time\n\n## 替换标准库\nmonkey.patch_all()\n\ndef fetch_url(url):\n    """获取URL内容的函数\n    \n    Args:\n        url: 要获取的网址\n        \n    Returns:\n        tuple: (url, 响应状态码, 内容长度)\n    """\n    try:\n        print(f"开始请求: {url}")\n        start = time.time()\n        response = requests.get(url, timeout=5)  # 进行HTTP请求，IO操作会自动切换\n        elapsed = time.time() - start\n        print(f"完成请求: {url}, 耗时: {elapsed:.2f}秒")\n        return url, response.status_code, len(response.content)\n    except Exception as e:\n        print(f"请求 {url} 出错: {e}")\n        return url, 0, 0\n\n## 要获取的URL列表\nurls = [\n    "https://www.python.org",\n    "https://www.github.com",\n    "https://www.stackoverflow.com",\n    "https://www.wikipedia.org",\n    "https://www.reddit.com"\n]\n\nstart_time = time.time()\n\n## 创建协程任务\ntasks = [gevent.spawn(fetch_url, url) for url in urls]\n\n## 等待所有任务完成\ngevent.joinall(tasks)\n\n## 获取结果\nresults = [task.value for task in tasks]\n\n## 打印结果\nprint("\\n结果汇总:")\nfor url, status, length in results:\n    print(f"URL: {url}, 状态码: {status}, 内容长度: {length} 字节")\n\nprint(f"\\n总耗时: {time.time() - start_time:.2f}秒")\n```\n\n#### greenlet 与 gevent 的区别与选择\n\n| 特性     | greenlet              | gevent                       | 实际应用建议                                     |\n| -------- | --------------------- | ---------------------------- | ------------------------------------------------ |\n| 基本原理 | 轻量级上下文切换      | 基于 greenlet，增加事件循环  | 简单任务用 greenlet，复杂系统用 gevent           |\n| IO 处理  | 不提供 IO 操作支持    | 提供自动 IO 切换机制         | 网络应用选择 gevent，自定义调度选择 greenlet     |\n| 切换方式 | 需要显式调用 switch() | 在 IO 操作时自动切换         | 手动控制流程用 greenlet，自动化处理用 gevent     |\n| 复杂度   | 简单，仅提供基本切换  | 复杂，提供完整生态系统       | 小型项目用 greenlet，大型项目用 gevent           |\n| 适用场景 | 简单协程调度          | 高并发网络应用               | Web 爬虫、API 服务、代理服务器首选 gevent        |\n| 性能     | 轻量，开销小          | 比 greenlet 略重，但实用性强 | 极致性能用 greenlet，平衡性能和开发效率用 gevent |\n| 学习曲线 | 简单，容易理解        | 较复杂，概念较多             | 入门协程从 greenlet 开始，再过渡到 gevent        |\n| 社区支持 | 基础库，更新较少      | 活跃，有完整生态             | 长期项目建议使用 gevent                          |\n\n> 🌟 **选择建议**：如果只需要轻量级的上下文切换，可以使用 greenlet；如果需要处理 IO 密集型应用，特别是网络编程，建议使用 gevent。大多数实际项目中，gevent 是更好的选择，因为它提供了更完整的功能和自动化的 IO 处理。\n\n#### asyncio 协程技术\n\n随着 Python 的发展，协程技术已经有了显著进步。从 Python 3.4 引入的 `asyncio` 库开始，Python 对协程的原生支持不断增强。到 2025 年，Python 已经拥有更成熟、更高效的协程生态系统。\n\n##### asyncio 与原生协程\n\nPython 3.5 引入的 `async/await` 语法使得协程编程变得更加直观和强大，这是目前最推荐的协程实现方式：\n\n```python\nimport asyncio\nimport time\n\nasync def fetch_data(url,delay):\n    """模拟从网络获取数据的异步函数"""\n    print(f"开始获取数据：{url}，延迟{delay}秒")\n    await asyncio.sleep(delay)\n    print(f"成功获取数据长度：{len(url)}")\n    return f"数据{url}"\n\nasync def main():\n    """异步操作的主函数"""\n    print(f"程序开始时间:{time.strftime(\'%Y-%m-%d %H:%M:%S\', time.localtime())}")\n\n    print("\\n===== 串行执行示例 =====")\n    start_time = time.time()\n    # 串行执行 - 请求两个API数据\n    result1 = await fetch_data("https://www.baidu.com", 2)\n    result2 = await fetch_data("https://www.sina.com.cn",3)\n    print(f"串行执行结果：{result1}, {result2}")\n    end_time = time.time()\n    print(f"程序结束时间:{time.strftime(\'%Y-%m-%d %H:%M:%S\', time.localtime())}")\n    print(f"程序耗时:{end_time-start_time}秒")\n\n    # 并行执行 - 请求两个API数据\n    print("\\n===== 并行执行示例 =====")\n    start_time = time.time()\n    tasks = [\n        asyncio.create_task(fetch_data("https://www.baidu.com", 2)),\n        asyncio.create_task(fetch_data("https://www.sina.com.cn",3)),\n    ]\n    results = await asyncio.gather(*tasks) # 批量等待所有任务完成\n    print(f"并行执行结果：{results}")\n    end_time = time.time()\n    print(f"程序结束时间:{time.strftime(\'%Y-%m-%d %H:%M:%S\', time.localtime())}")\n    print(f"程序耗时:{end_time-start_time}秒")\n\nif __name__ == \'__main__\':\n    # 在Python 3.7+中，可以直接使用asyncio.run()运行主协程\n    asyncio.run(main())\n\n```\n\n##### asyncio 常用 API\n\n| 方法/函数                | 描述               | 使用场景           | 示例                                                         |\n| ------------------------ | ------------------ | ------------------ | ------------------------------------------------------------ |\n| `asyncio.run()`          | 运行协程           | 程序入口点         | `asyncio.run(main())`                                        |\n| `asyncio.create_task()`  | 创建任务           | 并行执行协程       | `task = asyncio.create_task(coro())`                         |\n| `asyncio.gather()`       | 并行运行多个协程   | 批量并发任务       | `results = await asyncio.gather(coro1(), coro2())`           |\n| `asyncio.wait_for()`     | 带超时的等待       | 实现超时控制       | `await asyncio.wait_for(coro(), timeout=1.0)`                |\n| `asyncio.sleep()`        | 非阻塞睡眠         | 模拟 IO 延迟       | `await asyncio.sleep(1.0)`                                   |\n| `asyncio.Queue`          | 协程安全的队列     | 协程间数据传递     | `queue = asyncio.Queue(); await queue.put(item)`             |\n| `asyncio.Future`         | 低级异步原语       | 自定义异步操作     | `future = asyncio.Future(); future.set_result(value)`        |\n| `asyncio.shield()`       | 防止取消传播       | 保护关键协程       | `await asyncio.shield(critical_coro())`                      |\n| `asyncio.as_completed()` | 按完成顺序返回结果 | 处理最先完成的任务 | `for task in asyncio.as_completed([coro1(), coro2()]): result = await task` |\n\n\n\n#### Task 对象\n\n`Task` 是 `asyncio` 中用于封装协程的对象，可以用于并发执行多个任务。可以通过 `Task` 对象等待协程完成。\n\n```python\nimport asyncio\n\nasync def nested():\n    print(\'进入 nested()\')\n    await asyncio.sleep(1)  # 模拟IO操作\n    print(\'离开 nested()\')\n    return \'42\'\n\nasync def main():\n    task = asyncio.create_task(nested())  # 创建任务\n    result = await task  # 等待任务完成\n    print(f\'返回值：{result}\')\n\nasyncio.run(main())\n```\n\n#### Future 对象\n\n`Future` 是 `Task` 的基类，表示一个未完成的结果。在底层异步操作中，`Future` 常常用来表示某些未决的操作结果。\n\n```python\nimport asyncio\n\n# 定义一个异步函数，用于设置future的结果\nasync def set_future_result(future):\n    # 异步等待2秒，模拟耗时操作\n    await asyncio.sleep(2)\n    # 设置future的结果为"Hello, world!"\n    future.set_result("Hello, world!")\n\n# 定义主异步函数\nasync def main():\n    # 获取当前正在运行的事件循环\n    loop = asyncio.get_running_loop()\n    # 创建Future对象，它代表一个尚未完成的异步操作\n    future = loop.create_future()  # 创建Future对象\n    # 创建一个任务来执行set_future_result函数，不等待其完成立即返回\n    asyncio.create_task(set_future_result(future))\n    # 等待future完成并获取其结果\n    result = await future  # 等待Future完成\n    # 打印future的结果\n    print(f"Future的结果: {result}")\n\n# 运行主异步函数\nasyncio.run(main())\n```\n\n#### 异步上下文管理器\n\n异步上下文管理器允许在进入和退出时执行异步操作，常用于异步资源管理。\n\n```python\nimport asyncio\n\nclass AsyncResource:\n    async def __aenter__(self):\n        print("资源获取")\n        return self\n\n    async def __aexit__(self, exc_type, exc_value, traceback):\n        print("资源释放")\n\nasync def main():\n    async with AsyncResource():\n        print("执行任务中")\n\nasyncio.run(main())\n```\n\n### 14.6 GIL 锁与 Python 并发性能\n\n\n\nGIL(Global Interpreter Lock，全局解释器锁)是 CPython 解释器的一个特性，它确保同一时刻只有一个线程可以执行 Python 字节码。这个特性对 Python 多线程编程有着深远影响，也是导致 Python 速度慢的两大原因之一，其另外一个原因是因为 Python 是 `解释形` 语言，但后续可通过 `pypy` 技术实现 Python 的预编译，但唯独这个原因 Python 没有解决，Python 在早期开发时为解决垃圾回收机制内部问题采用了 GIL 锁，所以 Python 程序无法直接利用多核 CPU 的优势\n\n```python\n\'\'\'\nGIL全局解释器锁(Global Interpreter Lock)，是CPython特有的一个物件，\n作用是让一个进程中同一时刻只能有一个线程可以被CPU调用\n\n如果程序想利用计算机的多核优势，让CPU同时处理一些任务，适合用多进程开发（即使资源开销大）\n如果程序不想利用计算机的多核优势，适合用多线程开发\n\'\'\'\n```\n\n#### GIL 的本质与工作原理\n\nGIL 本质上是一把互斥锁，用于保护 Python 解释器的内部状态，主要解决了 Python 对象的内存管理问题。\n\n| GIL 特性 | 描述                                              |\n| -------- | ------------------------------------------------- |\n| 实现方式 | 互斥锁(mutex)                                     |\n| 作用对象 | Python 解释器进程                                 |\n| 控制范围 | Python 字节码执行                                 |\n| 释放时机 | I/O 操作、执行固定字节码数量后                    |\n| 影响范围 | 仅影响 CPython，PyPy、Jython、IronPython 不受影响 |\n\n> 🔍 **深入理解**：GIL 并非 Python 语言本身的特性，而是 CPython 实现的产物。它解决了 CPython 简单引用计数式内存管理的线程安全问题，但也限制了多线程程序利用多核性能的能力。\n\n```python\n## GIL工作示意伪代码\ndef thread_execution():\n    while True:\n        acquire_GIL()       # 获取GIL锁\n        execute_bytecodes() # 执行一定数量的字节码\n        release_GIL()       # 释放GIL锁以允许其他线程运行\n        wait_for_GIL()      # 等待再次获取GIL\n        \n# 这也就导致了每一个线程都需要在执行获取字节码时都要经历拿锁->解锁的过程\n```\n\n#### 并发与并行的区别\n\n并发(Concurrency)和并行(Parallelism)是两个在计算机科学中经常出现的概念，虽然常被混用，但有着本质区别：\n\n| 特性        | 并发(Concurrency)                    | 并行(Parallelism)                    |\n| ----------- | ------------------------------------ | ------------------------------------ |\n| 定义        | 多个任务在同一时间间隔内发生         | 多个任务在同一时刻发生               |\n| 重点        | 任务切换与调度                       | 任务的同时执行                       |\n| 资源需求    | 可以在单处理器上通过时间片轮转实现   | 需要多个处理器或核心                 |\n| 执行方式    | 任务交替执行，共享处理器时间         | 每个任务有独立的处理器同时执行       |\n| 适用场景    | I/O 密集型任务，如网络请求、文件读写 | 计算密集型任务，如图像处理、科学计算 |\n| 实现难度    | 相对简单，关注任务调度               | 相对复杂，需考虑数据分割、同步和合并 |\n| Python 实现 | 多线程、协程                         | 多进程                               |\n\n> 🌟 **关键理解**：由于 GIL 的存在，Python 的多线程实际上只能实现并发，而不能实现真正的并行。要实现并行，需要使用多进程或依赖不受 GIL 限制的扩展库（如使用 C 扩展的 NumPy）。\n\n#### 线程安全与并发控制\n\n线程安全指在多线程环境下，程序能够正确地处理共享资源，不会因为多线程同时访问而导致数据不一致。尽管 Python 的 GIL 能减轻一些并发问题，但并不能完全保证线程安全。\n\n##### 线程安全问题示例\n\n```python\nfrom threading import Thread\nimport time\nimport random\n\n### 共享的全局变量\ncounter = 0\nstart_time = time.time()\niterations_completed = 0\n\ndef increment_counter():\n    """增加计数器，但使用了非原子操作的方式"""\n    global counter, iterations_completed\n    for _ in range(1000000):\n        # 模拟线程安全问题：读取-修改-写入过程中可能被中断\n        local_counter = counter  # 读取当前值\n        \n        # 模拟线程在读取后被切换的情况\n        # 随机休眠一个很小的时间，增加线程切换的可能性\n        if random.random() < 0.00001:\n            time.sleep(0.00001)\n            \n        local_counter += 1  # 在本地修改\n        counter = local_counter  # 写回全局变量\n        iterations_completed += 1\n\n\ndef run_concurrent_threads(num_threads):\n    """运行多个线程同时增加计数器"""\n    global counter, iterations_completed\n    counter = 0\n    iterations_completed = 0\n    \n    threads = []\n    for _ in range(num_threads):\n        t = Thread(target=increment_counter)\n        threads.append(t)\n        t.start()\n    \n    for t in threads:\n        t.join()\n    \n    # 理论上应该等于 num_threads * 1000000\n    expected = num_threads * 1000000\n    print(f"预期结果: {expected}")\n    print(f"实际结果: {counter}")\n    print(f"丢失的增量: {expected - counter}")\n    print(f"完成的迭代次数: {iterations_completed}")\n\n\nif __name__ == \'__main__\':\n    print(f\'开始时间为: {time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())}\')\n    \n    # 运行4个线程，每个线程增加计数器1000000次\n    # 理论上最终结果应该是4000000，但由于线程安全问题，实际结果会小于这个值\n    run_concurrent_threads(4)\n    \n    print(f"累计用时: {round(time.time() - start_time, 1)}秒")\n    \n\n```\n\n##### 使用线程锁解决安全问题\n\n```python\nfrom threading import Thread, Lock\nimport time\nimport random\n\n### 共享的全局变量\ncounter = 0\nstart_time = time.time()\niterations_completed = 0\n# 创建一个线程锁\ncounter_lock = Lock()\n\n\ndef increment_counter():\n    """增加计数器，使用线程锁确保线程安全"""\n    global counter, iterations_completed\n    for _ in range(1000000):\n        # 使用线程锁保护临界区\n        with counter_lock:\n            counter += 1  # 在锁的保护下直接修改全局变量\n            iterations_completed += 1\n\n\ndef run_concurrent_threads(num_threads):\n    """运行多个线程同时增加计数器"""\n    global counter, iterations_completed\n    counter = 0\n    iterations_completed = 0\n\n    threads = []\n    for _ in range(num_threads):\n        t = Thread(target=increment_counter)\n        threads.append(t)\n        t.start()\n\n    for t in threads:\n        t.join()\n\n    # 理论上应该等于 num_threads * 1000000\n    expected = num_threads * 1000000\n    print(f"预期结果: {expected}")\n    print(f"实际结果: {counter}")\n    print(f"丢失的增量: {expected - counter}")\n    print(f"完成的迭代次数: {iterations_completed}")\n\n\nif __name__ == \'__main__\':\n    print(f\'开始时间为: {time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())}\')\n\n    # 运行4个线程，每个线程增加计数器1000000次\n    # 使用线程锁后，最终结果应该正确等于4000000\n    run_concurrent_threads(4)\n\n    print(f"累计用时: {round(time.time() - start_time, 1)}秒")\n\n```\n\n> 🔒 **线程锁作用与注意事项**：\n> - 锁确保同一时刻只有一个线程能访问共享资源\n> - 锁会影响性能，特别是在竞争激烈的情况下\n> - 锁的粒度需要权衡：粒度太细会增加锁操作开销，太粗会降低并发度\n> - 锁可能引发死锁问题，需谨慎设计锁的获取顺序\n\n#### Python 中的锁机制全面解析\n\nPython 的 `threading` 模块提供了多种锁和同步原语，用于不同并发控制场景。深入理解这些锁的特性和适用场景，对于开发可靠的并发程序至关重要。\n\n##### Python 锁类型及其特性\n\n| 锁类型                       | 描述         | 独占性 | 可重入性 | 公平性   | 注意事项                                 |\n| ---------------------------- | ------------ | ------ | -------- | -------- | ---------------------------------------- |\n| `threading.Lock`             | 基本互斥锁   | 是     | 否       | 非公平   | 最简单的锁，同一线程不能重复获取         |\n| `threading.RLock`            | 可重入锁     | 是     | 是       | 非公平   | 同一线程可多次获取，必须对应释放相同次数 |\n| `threading.Condition`        | 条件变量     | -      | -        | 非公平   | 基于锁实现，提供 wait/notify 机制        |\n| `threading.Semaphore`        | 信号量       | 否     | -        | 非公平   | 限制资源访问线程数量                     |\n| `threading.BoundedSemaphore` | 有界信号量   | 否     | -        | 非公平   | 限制资源数量，防止过度释放               |\n| `threading.Event`            | 事件对象     | -      | -        | -        | 用于线程间通知而非资源控制               |\n| `threading.Barrier`          | 栅栏对象     | -      | -        | -        | 使多个线程同步到达某点再继续             |\n| `queue.Queue`                | 线程安全队列 | -      | -        | 先进先出 | 内部带锁，用于线程间数据传递             |\n| `multiprocessing.Lock`       | 进程锁       | 是     | 否       | 非公平   | 用于进程间同步的锁                       |\n| `asyncio.Lock`               | 异步锁       | 是     | 否       | -        | 用于协程间的同步                         |\n\n##### 互斥锁(Lock)\n\n互斥锁是最基本的锁类型，它确保同一时刻只有一个线程可以访问受保护的资源。\n\n```python\nimport concurrent\nimport threading\nimport time\nfrom concurrent.futures import ThreadPoolExecutor\n\nlock = threading.Lock()\nshared_data = 0\n\n\ndef shared_resource(thread_id: int):\n    """访问共享资源的函数\n    Args:thread_id: 线程ID，用于标识不同线程\n    """\n    # 尝试获取锁\n    if lock.acquire(timeout=1):  # 添加超时参数，防止无限等待\n        print(f"线程{thread_id}获取锁")\n        try:\n            global shared_data\n            # 读取-修改-写入操作需要原子性保护\n            current = shared_data\n            time.sleep(0.1)  # 模拟处理延时，增加竞争概率\n            shared_data = current + 1\n            print(f"线程{thread_id}修改共享数据，当前值为{shared_data}")\n        finally:\n            # 释放锁\n            lock.release()\n            print(f"线程{thread_id}释放锁")\n    else:\n        print(f"线程{thread_id}获取锁失败")\n        \n\ndef shared_resource2(thread_id: int):\n    """访问共享资源的函数\n    使用with语句，自动释放锁简化代码\n    """\n    with lock:\n        print(f"线程{thread_id}获取锁")\n        try:\n            global shared_data\n            # 读取-修改-写入操作需要原子性保护\n            current = shared_data\n            time.sleep(0.1)  # 模拟处理延时，增加竞争概率\n            shared_data = current + 1\n            print(f"线程{thread_id}修改共享数据，当前值为{shared_data}")\n        finally:\n            print(f"线程{thread_id}释放锁")\n\n\nif __name__ == \'__main__\':\n    # 使用线程池创建多个线程\n    with ThreadPoolExecutor(max_workers=10) as executor:\n        futures = [executor.submit(shared_resource, i) for i in range(1, 11)]\n        # 等待所有线程完成\n        concurrent.futures.wait(futures)\n    print(f"最终共享数据值为{shared_data}")\n\n```\n\n| Lock 方法                            | 描述                | 参数                                      | 返回值                                      |\n| ------------------------------------ | ------------------- | ----------------------------------------- | ------------------------------------------- |\n| `acquire(blocking=True, timeout=-1)` | 获取锁              | blocking: 是否阻塞, timeout: 超时时间(秒) | 布尔值，表示是否获取成功                    |\n| `release()`                          | 释放锁              | 无                                        | 无，如果当前线程未持有锁则抛出 RuntimeError |\n| `locked()`                           | 检查锁状态          | 无                                        | 布尔值，表示锁是否被某个线程持有            |\n| `__enter__()`                        | 支持 with 语句      | 无                                        | 锁对象自身                                  |\n| `__exit__()`                         | with 语句退出时调用 | 异常信息                                  | 无，自动释放锁                              |\n\n##### 可重入锁(RLock)\n\n可重入锁允许同一个线程多次获取该锁，而不会导致自我死锁。这在递归调用或者嵌套加锁场景中特别有用。\n\n```python\nimport threading\nimport time\n\n## 创建可重入锁\nrlock = threading.RLock()\n\n# 嵌套列表数据结构\ndata = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\n\ndef process_data(item, depth: int = 0):\n    """递归处理数据\n    \n    Args:\n        item: 要处理的数据项，可以是列表或单个元素\n        depth: 当前递归深度，用于缩进显示\n    """\n    # 获取锁\n    rlock.acquire()\n    try:\n        # 创建缩进效果，增强可读性\n        indent = " " * depth * 2  # 增加缩进量使层次更明显\n        \n        # 打印当前处理的数据项和深度\n        print(f\'{indent}线程 {threading.current_thread().name} 处理: {item} (深度: {depth})\')\n        \n        # 递归处理逻辑\n        if isinstance(item, list):\n            # 列表节点处理 - 继续向下递归\n            print(f\'{indent}├── 发现列表，开始遍历子元素...\')\n            for i, sub_item in enumerate(item):\n                # 显示子项的索引，增强结构可视化\n                prefix = "└── " if i == len(item) - 1 else "├── "\n                print(f\'{indent}{prefix}处理子项 {i+1}/{len(item)}: {sub_item}\')\n                \n                # 递归调用，这里会再次获取同一个锁\n                process_data(sub_item, depth + 1)\n                time.sleep(0.1)\n        else:\n            # 叶子节点处理 - 递归终止条件\n            print(f\'{indent}└── 发现元素，进行处理...\')\n            time.sleep(0.5)\n            print(f\'{indent}    处理结果: {item * 2}\')\n    finally:\n        # 释放锁\n        rlock.release()\n\n\nif __name__ == \'__main__\':\n    ## 创建多个线程访问嵌套数据\n    threads = []\n    for i in range(3):\n        # 每个线程处理完整的数据结构\n        t = threading.Thread(name=f"Thread-{i}", target=process_data, args=(data,))\n        threads.append(t)\n        t.start()\n        time.sleep(0.5)  # 错开线程启动时间\n    \n    ## 等待所有线程结束\n    for t in threads:\n        t.join()\n    \n    print("所有线程都结束了")\n```\n\n| RLock 方法                           | 描述                   | 与 Lock 的区别                    |\n| ------------------------------------ | ---------------------- | --------------------------------- |\n| `acquire(blocking=True, timeout=-1)` | 获取锁                 | 记录获取线程 ID 和次数            |\n| `release()`                          | 释放锁                 | 计数器减 1，只有为 0 时才真正释放 |\n| `_is_owned()`                        | 检查当前线程是否持有锁 | Lock 没有此方法                   |\n\n> 💡 **使用建议**：一般推荐使用 RLock 而非 Lock，因为它更安全、更灵活，即使在不需要重入功能的场景下也不会有明显性能损失。\n\n##### 条件变量(Condition) - 根据条件控制锁\n\n条件变量是一种高级的 `同步原语(同步原语就是让多个线程能够"和谐相处"的机制)`，它允许线程等待特定条件满足后再继续执行。条件变量内部包含一个锁，用于控制对共享状态的访问。\n\n```python\nimport threading\nimport time\nimport random\nfrom typing import List, Any\n\n\nclass Buffer:\n    """线程安全的缓冲区，使用条件变量控制生产者消费者模型"""\n\n    def __init__(self, max_size: int = 5) -> None:\n        """初始化缓冲区"""\n        self.buffer: List[Any] = []  # 共享数据缓冲区\n        self.max_size: int = max_size  # 最大容量\n        # 创建条件变量，基于RLock\n        self.condition: threading.Condition = threading.Condition()\n\n    def produce(self, item: Any, producer_id: int) -> None:\n        """生产者方法，向缓冲区添加数据"""\n        # 使用条件变量的with语句自动获取和释放锁\n        with self.condition:\n            # 当缓冲区已满时，等待消费者处理\n            while len(self.buffer) >= self.max_size:\n                print(f"生产者 {producer_id}: 缓冲区已满，等待消费者...")\n                # 等待唤醒通知，自动释放锁，让其他线程能访问缓冲区\n                self.condition.wait()\n\n            # 添加数据到缓冲区\n            self.buffer.append(item)\n            print(f"生产者 {producer_id}: 添加 {item} 到缓冲区，当前大小: {len(self.buffer)}")\n\n            # 通知所有等待的消费者有新数据可用\n            self.condition.notify_all()\n\n    def consume(self, consumer_id: int) -> Any:\n        """消费者方法，从缓冲区获取数据"""\n        with self.condition:\n            # 当缓冲区为空时，等待生产者添加数据\n            while len(self.buffer) == 0:\n                print(f"消费者 {consumer_id}: 缓冲区为空，等待生产者...")\n                self.condition.wait()\n\n            # 从缓冲区取出数据\n            item = self.buffer.pop(0)\n            print(f"消费者 {consumer_id}: 从缓冲区取出 {item}，当前大小: {len(self.buffer)}")\n\n            # 通知所有等待的生产者缓冲区有空间\n            self.condition.notify_all()\n\n            return item\n\n\ndef producer_task(buffer: Buffer, producer_id: int) -> None:\n    """生产者任务"""\n    for i in range(10):  # 生产10个产品\n        item = f"产品-{producer_id}-{i}"\n        # 模拟生产时间\n        time.sleep(random.uniform(0.1, 0.5))  \n        buffer.produce(item, producer_id)\n\n\ndef consumer_task(buffer: Buffer, consumer_id: int) -> None:\n    """消费者任务"""\n    for _ in range(7):  # 每个消费者消费7个产品\n        # 模拟消费时间\n        time.sleep(random.uniform(0.2, 0.7))  \n        item = buffer.consume(consumer_id)\n        print(f"消费者 {consumer_id} 处理 {item}")\n\n\ndef main() -> None:\n    """主函数，创建并启动生产者和消费者线程"""\n    # 创建共享缓冲区\n    shared_buffer = Buffer(max_size=3)\n    \n    # 创建生产者和消费者线程\n    producer_threads = [\n        threading.Thread(target=producer_task, args=(shared_buffer, i), name=f"Producer-{i}")\n        for i in range(3)  # 3个生产者\n    ]\n    \n    consumer_threads = [\n        threading.Thread(target=consumer_task, args=(shared_buffer, i), name=f"Consumer-{i}")\n        for i in range(3)  # 3个消费者\n    ]\n    \n    # 启动所有线程\n    all_threads = producer_threads + consumer_threads\n    for thread in all_threads:\n        thread.start()\n    \n    # 等待所有线程完成\n    for thread in all_threads:\n        thread.join()\n    \n    print("所有生产和消费任务已完成")\n\n\nif __name__ == "__main__":\n    main()\n```\n\n| Condition 方法                      | 描述                | 参数                                   | 注意事项                   |\n| ----------------------------------- | ------------------- | -------------------------------------- | -------------------------- |\n| `__init__(lock=None)`               | 初始化条件变量      | lock: 可选的 Lock 或 RLock             | 不指定则创建 RLock         |\n| `acquire(*args)`                    | 获取底层锁          | 同底层锁的 acquire 方法                | 一般通过 with 语句使用     |\n| `release()`                         | 释放底层锁          | 无                                     | 一般通过 with 语句自动释放 |\n| `wait(timeout=None)`                | 等待条件            | timeout: 超时时间(秒)                  | 调用前必须已获得锁         |\n| `wait_for(predicate, timeout=None)` | 等待直到条件为真    | predicate: 条件函数, timeout: 超时时间 | 简化循环等待模式           |\n| `notify(n=1)`                       | 唤醒 n 个等待的线程 | n: 要唤醒的线程数                      | 不会立即释放锁             |\n| `notify_all()`                      | 唤醒所有等待的线程  | 无                                     | 适用于广播通知             |\n\n> ⚠️ **使用注意**：\n> 1. 调用 `wait()` 会释放锁，允许其他线程修改条件状态\n> 2. 使用 `wait_for()` 可以避免虚假唤醒问题\n> 3. 调用 `notify()` 后锁不会立即释放，需要当前线程退出 with 块\n> 4. 使用 `notify_all()` 而非 `notify()` 可以避免信号丢失问题\n\n##### 信号量(Semaphore) - 控制并发数量\n\n信号量是一种计数器，用于控制同时访问特定资源的线程数量，常用于限制并发访问数。\n\n```python\nimport threading\nimport time\nimport random\nfrom concurrent.futures import ThreadPoolExecutor\n\n## 创建信号量，限制最多三个线程同时访问资源\npool_semaphore = threading.Semaphore(3)\n\n## 模拟优先的资源池\nresource_pool = [\'资源A\', \'资源B\', \'资源C\']\nresource_in_use = {}  # 跟踪资源使用情况\n\n## 保护资源分配的锁\nresource_lock = threading.RLock()\n\n\ndef worker(worker_id: int):\n    """工作线程函数，模拟使用受限资源"""\n    # 尝试获取信号量\n    print(f"工作线程 {worker_id} 等待获取资源...")\n    with pool_semaphore:  # 等同于acquire()和finally中release()\n        print(f"工作线程 {worker_id} 获取资源信号量")\n        with resource_lock:\n            # 检查resource_pool中的每个资源，如果该资源不在resource_in_use字典的值中，则认为是可用的\n            available_resources = [r for r in resource_pool if r not in resource_in_use.values()]\n            if not available_resources:\n                print(f"工作线程 {worker_id} 没有找到可用资源，理论上不应该发生！")\n                return\n\n            resource_name = available_resources[0]\n            resource_in_use[worker_id] = resource_name  # 记录资源使用情况\n            print(f"工作线程 {worker_id} 分配到资源: {resource_name}, 当前使用情况: {resource_in_use}")\n        try:\n            # 模拟使用资源\n            work_time = random.uniform(0.5, 2.0)\n            print(f"工作线程 {worker_id} 使用资源 {resource_name} 时间: {work_time} 秒")\n            time.sleep(work_time)\n        finally:\n            # 释放资源\n            with resource_lock:\n                released_resource = resource_in_use.pop(worker_id)\n                print(f"工作线程 {worker_id} 释放资源: {released_resource}, 当前使用情况: {resource_in_use}")\n\n\nif __name__ == \'__main__\':\n    # 创建线程池，并启动三个线程\n    with ThreadPoolExecutor(max_workers=3) as executor:\n        futures = [executor.submit(worker, i) for i in range(3)]\n        for future in futures:\n            future.result()\n\n\n```\n\n| Semaphore 方法                         | 描述                | 参数                                  | 返回值                   |\n| -------------------------------------- | ------------------- | ------------------------------------- | ------------------------ |\n| `__init__(value=1)`                    | 初始化信号量        | value: 初始计数器值                   | 无                       |\n| `acquire(blocking=True, timeout=None)` | 获取信号量          | blocking: 是否阻塞, timeout: 超时时间 | 布尔值，表示是否获取成功 |\n| `release(n=1)`                         | 释放信号量          | n: 释放的数量                         | 无                       |\n| `__enter__()`                          | 支持 with 语句      | 无                                    | 信号量对象自身           |\n| `__exit__()`                           | with 语句退出时调用 | 异常信息                              | 无，自动释放信号量       |\n\n##### 有界信号量(BoundedSemaphore)详解\n\n有界信号量是信号量的一个变种，它会检查释放操作是否会导致计数器超过初始值，如果超过则抛出异常。这可以帮助检测程序中的信号量使用错误。\n\n```python\nimport threading\nimport time\n\n## 创建有界信号量，初始值为3\nbounded_semaphore = threading.BoundedSemaphore(3)\n\ndef semaphore_demo():\n    """演示有界信号量与普通信号量的区别"""\n    try:\n        print("获取信号量1次")\n        bounded_semaphore.acquire()\n        \n        print("获取信号量2次")\n        bounded_semaphore.acquire()\n        \n        print("获取信号量3次")\n        bounded_semaphore.acquire()\n        \n        print("信号量已用完，再获取将阻塞")\n        \n        # 释放全部信号量\n        print("释放信号量1次")\n        bounded_semaphore.release()\n        \n        print("释放信号量2次")\n        bounded_semaphore.release()\n        \n        print("释放信号量3次")\n        bounded_semaphore.release()\n        \n        try:\n            # 超出初始值的释放将抛出异常\n            print("尝试额外释放一次")\n            bounded_semaphore.release()  \n            print("这一行不会执行")\n        except ValueError as e:\n            print(f"捕获预期异常: {e}")\n    except Exception as e:\n        print(f"意外错误: {e}")\n\nsemaphore_demo()\n```\n\n> 🔍 **Semaphore vs BoundedSemaphore**：\n> - `Semaphore` 允许无限制地调用 `release()`，即使计数器超过初始值\n> - `BoundedSemaphore` 在计数器超过初始值时会抛出 `ValueError` 异常\n> - 生产环境推荐使用 `BoundedSemaphore`，或安全的使用 with 语句，保证程序安全\n\n##### 事件对象(Event)\n\n事件对象是最简单的线程通信机制之一，它允许一个线程发送信号给其他线程，适合简单的 "一次性通知" 场景。\n\n```python\nimport threading\nimport time\nimport random\nfrom typing import List\nfrom concurrent.futures import ThreadPoolExecutor\n\n## 创建事件对象\nstart_event = threading.Event()\nresults: List[str] = []\nresults_lock = threading.RLock()\n\ndef worker(worker_id:int) -> None:\n    """工作线程函数，等待开始信号"""\n    prep_time = random.uniform(0.5, 1.5)\n    time.sleep(prep_time)\n    print(f"工作线程{worker_id}准备完毕，等待开始信号")\n    # 等待开始信号\n    start_event.wait()\n\n    # 收到信号开始工作\n    print(f"工作线程{worker_id}开始工作")\n    work_time = random.uniform(1, 2)\n    time.sleep(work_time)\n    # 记录结果\n    with results_lock:\n        results.append(f"工作线程{worker_id}完成工作")\n\n    print(f"工作线程{worker_id}完成工作，用时{work_time:.2f}秒")\n\nif __name__ == \'__main__\':\n    # 创建线程池\n    with ThreadPoolExecutor(max_workers=3) as executor:\n        futures = [executor.submit(worker, i) for i in range(3)]\n        # 等待所有线程准备完毕\n        time.sleep(2)\n        # 发送开始信号\n        print("发送开始信号")\n        start_event.set()\n        # 等待所有线程完成工作\n        for future in futures:\n            future.result()\n\n    print("所有工作线程完成")\n    print(results)\n```\n\n| Event 方法           | 描述                         | 参数              | 返回值                            |\n| -------------------- | ---------------------------- | ----------------- | --------------------------------- |\n| `set()`              | 设置事件，唤醒所有等待的线程 | 无                | 无                                |\n| `clear()`            | 清除事件标志                 | 无                | 无                                |\n| `is_set()`           | 判断事件是否已设置           | 无                | 布尔值                            |\n| `wait(timeout=None)` | 等待事件被设置               | timeout: 超时时间 | 如果超时返回 False，否则返回 True |\n\n> 💡 **使用场景**：\n> - 启动信号：所有线程等待统一开始\n> - 停止信号：通知所有线程停止工作\n> - 一次性通知：当某条件满足时通知等待线程\n\n##### 栅栏对象(Barrier)\n\n栅栏是一种同步原语，它要求固定数量的线程都到达栅栏点后，才允许所有线程继续执行。这对于分阶段任务的同步特别有用。\n\n```python\nimport threading\nimport time\nimport random\n\n## 定义参与方数量\nnum_parties = 4\n\n## 创建栅栏对象，当4个线程都到达时才继续\nbarrier = threading.Barrier(num_parties)\n\ndef worker(worker_id):\n    """工作线程函数，模拟多阶段工作\n    \n    Args:\n        worker_id: 工作线程ID\n    """\n    print(f"工作线程 {worker_id} 开始第一阶段工作")\n    \n    # 模拟第一阶段工作\n    work_time = random.uniform(0.5, 2.0)\n    time.sleep(work_time)\n    print(f"工作线程 {worker_id} 完成第一阶段，用时 {work_time:.2f} 秒，等待其他线程...")\n    \n    try:\n        # 等待所有线程完成第一阶段\n        barrier.wait()\n        print(f"工作线程 {worker_id} 通过第一个栅栏，开始第二阶段")\n        \n        # 模拟第二阶段工作\n        work_time = random.uniform(0.5, 2.0)\n        time.sleep(work_time)\n        print(f"工作线程 {worker_id} 完成第二阶段，用时 {work_time:.2f} 秒，等待其他线程...")\n        \n        # 等待所有线程完成第二阶段\n        barrier.wait()\n        print(f"工作线程 {worker_id} 通过第二个栅栏，工作全部完成")\n        \n    except threading.BrokenBarrierError:\n        print(f"工作线程 {worker_id} 检测到栅栏被破坏")\n\n## 创建工作线程\nthreads = []\nfor i in range(num_parties):\n    t = threading.Thread(target=worker, args=(i,))\n    threads.append(t)\n    t.start()\n\n## 等待所有线程完成\nfor t in threads:\n    t.join()\n\nprint("所有工作阶段已完成")\n```\n\n| Barrier 方法                                   | 描述                       | 参数                                                         | 返回值                                      |\n| ---------------------------------------------- | -------------------------- | ------------------------------------------------------------ | ------------------------------------------- |\n| `__init__(parties, action=None, timeout=None)` | 初始化栅栏                 | parties: 参与方数量, action: 所有线程到达时执行的回调, timeout: 等待超时 | 无                                          |\n| `wait(timeout=None)`                           | 等待所有参与方到达         | timeout: 覆盖默认超时时间                                    | 线程的到达序号(0 ~ n-1)                     |\n| `reset()`                                      | 将栅栏重置到初始状态       | 无                                                           | 无，正在等待的线程会抛出 BrokenBarrierError |\n| `abort()`                                      | 将栅栏置于损坏状态         | 无                                                           | 无，所有等待线程会抛出 BrokenBarrierError   |\n| `parties`                                      | 参与方数量(属性)           | 无                                                           | 整数                                        |\n| `n_waiting`                                    | 当前等待的线程数(属性)     | 无                                                           | 整数                                        |\n| `broken`                                       | 栅栏是否处于损坏状态(属性) | 无                                                           | 布尔值                                      |\n\n> ⚠️ **注意事项**：\n> - 如果等待超时，栅栏会进入损坏状态\n> - 如果等待时的线程被中断，栅栏也会损坏\n> - 可以通过 `reset()` 方法重新使用已损坏的栅栏\n\n##### 线程安全队列(Queue)\n\n`queue` 模块提供的 `Queue` 类是一个线程安全的队列实现，通常用于线程间的数据传递和任务分发。\n\n```python\nimport threading\nimport queue\nimport time\nimport random\nfrom concurrent.futures import ThreadPoolExecutor\n\n## 创建线程安全队列\ntask_queue = queue.Queue(maxsize=10)  # 最多容纳10个任务\nresult_queue = queue.Queue()  # 结果队列，无大小限制\n## 用于通知工作线程结束的标志\nexit_flag = threading.Event()\n\ndef producer():\n    """生产者线程，产生任务"""\n    for i in range(20):\n        task = f"任务-{i}"\n        # 将任务放入队列\n        task_queue.put(task)\n        print(f"生产者: 添加 {task} 到队列，当前队列大小: {task_queue.qsize()}")\n        time.sleep(random.uniform(0.1, 0.3))  # 随机延迟\n\n    # 添加结束标记\n    print("生产者: 所有任务已产生，设置退出标志")\n    exit_flag.set()\n\ndef consumer(consumer_id):\n    """消费者线程，处理任务"""\n    # 直到所有任务都处理完毕或有新任务到来\n    while not exit_flag.is_set() or not task_queue.empty():\n        try:\n            # 从队列获取任务，最多等待1秒\n            task = task_queue.get(timeout=1)\n            # 模拟处理任务\n            print(f"消费者 {consumer_id}: 开始处理 {task}")\n            process_time = random.uniform(0.5, 1.5)\n            time.sleep(process_time)\n            # 将处理结果放入结果队列\n            result = f"结果-{task}-耗时{process_time:.2f}秒"\n            result_queue.put((consumer_id, result))\n            # 标记任务完成\n            task_queue.task_done()\n            print(f"消费者 {consumer_id}: 完成处理 {task}")\n        except queue.Empty:\n            # 队列为空且设置了退出标志时结束循环\n            if exit_flag.is_set():\n                break\n            print(f"消费者 {consumer_id}: 队列暂时为空，等待任务...")\n            time.sleep(0.5)\n    print(f"消费者 {consumer_id}: 退出")\n\nif __name__ == \'__main__\':\n    # 创建生产者线程和消费者线程\n    with ThreadPoolExecutor(max_workers=4) as executor:\n        # 创建生产者线程\n        producers = [executor.submit(producer) for _ in range(2)]\n        # 创建消费者线程\n        consumers = [executor.submit(consumer, i) for i in range(2)]\n        \n        # 等待所有线程结束\n        all_futures = producers + consumers\n        for future in all_futures:\n            future.result()\n    \n    # 打印结果队列中的所有结果\n    print("\\n处理结果:")\n    while not result_queue.empty():\n        consumer_id, result = result_queue.get()\n        print(f"消费者 {consumer_id} 的结果: {result}")\n\n```\n\n| Queue 方法/属性                       | 描述                       | 参数                                           | 返回值/特性                                 |\n| ------------------------------------- | -------------------------- | ---------------------------------------------- | ------------------------------------------- |\n| `__init__(maxsize=0)`                 | 初始化队列                 | maxsize: 队列最大大小，0 表示无限              | 无                                          |\n| `put(item, block=True, timeout=None)` | 放入元素                   | item: 元素, block: 是否阻塞, timeout: 超时时间 | 无，队列满时可能阻塞或抛出 Full 异常        |\n| `get(block=True, timeout=None)`       | 获取元素                   | block: 是否阻塞, timeout: 超时时间             | 队列元素，队列空时可能阻塞或抛出 Empty 异常 |\n| `task_done()`                         | 标记任务完成               | 无                                             | 无                                          |\n| `join()`                              | 等待队列中所有任务处理完成 | 无                                             | 无                                          |\n| `qsize()`                             | 返回队列大小               | 无                                             | 整数                                        |\n| `empty()`                             | 检查队列是否为空           | 无                                             | 布尔值                                      |\n| `full()`                              | 检查队列是否已满           | 无                                             | 布尔值                                      |\n| `put_nowait(item)`                    | 非阻塞版本的 put           | item: 元素                                     | 无，队列满时抛出 Full 异常                  |\n| `get_nowait()`                        | 非阻塞版本的 get           | 无                                             | 队列元素，队列空时抛出 Empty 异常           |\n\n> 💡 **Queue 变种**：\n> - `queue.LifoQueue`: 后进先出队列(栈)\n> - `queue.PriorityQueue`: 优先级队列，元素为(优先级, 数据)元组\n> - `queue.SimpleQueue`: 简单的无界队列，不支持 task_done 和 join\n\n\n\n##### 死锁问题分析与解决\n\n死锁是指两个或多个线程互相等待对方释放资源，导致程序无法继续执行的情况。\n\n###### 死锁示例\n\n```python\nimport threading\nimport time\n\n## 创建两个锁\nlock_1 = threading.Lock()\nlock_2 = threading.Lock()\n\ndef task1():\n    """第一个任务，先获取lock_1，再获取lock_2"""\n    print("任务1开始尝试获取锁...")\n    lock_1.acquire()  # 获取1号锁\n    print("任务1获取到lock_1")\n    time.sleep(0.5)  # 等待一会，让任务2有机会获取lock_2\n    print("任务1尝试获取lock_2")\n    lock_2.acquire()  # 尝试获取2号锁，但可能永远阻塞于此\n\n    try:\n        print("任务1同时获取了两把锁")\n        # 使用两把锁保护的代码\n    finally:\n        # 释放锁\n        lock_2.release()\n        print("任务1释放了lock_2")\n        lock_1.release()\n        print("任务1释放了lock_1")\n\n\ndef task2():\n    """第二个任务，先获取lock_2，再获取lock_1"""\n    print("任务2开始尝试获取锁...")\n    lock_2.acquire()  # 获取2号锁\n    print("任务2获取到lock_2")\n    time.sleep(0.5)  # 等待一会\n    print("任务2尝试获取lock_1")\n    lock_1.acquire()  # 尝试获取1号锁，但可能永远阻塞于此\n    try:\n        print("任务2同时获取了两把锁")\n        # 使用两把锁保护的代码\n    finally:\n        # 释放锁\n        lock_1.release()\n        print("任务2释放了lock_1")\n        lock_2.release()\n        print("任务2释放了lock_2")\nif __name__ == \'__main__\':\n    ## 创建两个线程\n    t1 = threading.Thread(target=task1)\n    t2 = threading.Thread(target=task2)\n\n    ## 启动线程\n    t1.start()\n    t2.start()\n\n    ## 等待一段时间后检查是否发生死锁\n    time.sleep(5)\n\n    ## 检查线程是否还活着\n    print(f"线程1状态: {\'活跃\' if t1.is_alive() else \'已结束\'}")\n    print(f"线程2状态: {\'活跃\' if t2.is_alive() else \'已结束\'}")\n\n    if t1.is_alive() and t2.is_alive():\n        print("检测到可能的死锁情况!")\n```\n\n> ⚠️ **死锁的四个必要条件**：\n> 1. **互斥条件**：资源不能被共享，一次只能被一个线程使用\n> 2. **请求与保持条件**：线程已获得资源，但又提出新的资源请求\n> 3. **不剥夺条件**：线程已获得的资源不能强制被剥夺\n> 4. **循环等待条件**：线程之间形成头尾相接的循环等待资源关系\n\n###### 死锁解决方案\n\n```python\nimport threading\nimport time\n\n## 创建两个锁\nlock_1 = threading.Lock()\nlock_2 = threading.Lock()\n\ndef acquire_locks_safe(lock_a, lock_b, thread_name):\n    """安全地获取两个锁，使用超时机制避免死锁\n    \n    Args:\n        lock_a: 第一个锁\n        lock_b: 第二个锁\n        thread_name: 线程名称\n        \n    Returns:\n        bool: 是否成功获取两个锁\n    """\n    while True:\n        # 尝试获取第一个锁\n        got_lock_a = lock_a.acquire(timeout=1)\n        if got_lock_a:\n            print(f"{thread_name}: 获取到第一个锁")\n            try:\n                # 尝试获取第二个锁\n                got_lock_b = lock_b.acquire(timeout=1)\n                if got_lock_b:\n                    print(f"{thread_name}: 获取到第二个锁")\n                    return True  # 成功获取两个锁\n                # 获取第二个锁失败，释放第一个锁，避免死锁\n                print(f"{thread_name}: 获取第二个锁失败，释放第一个锁并重试")\n            finally:\n                if not got_lock_b:\n                    lock_a.release()\n                    # 短暂休眠，减少活锁可能性\n                    time.sleep(0.1)\n        else:\n            print(f"{thread_name}: 获取第一个锁失败，重试")\n            time.sleep(0.1)  # 短暂休眠避免CPU忙等\n\ndef task1_fixed():\n    """修复死锁的任务1 - 使用安全获取锁函数"""\n    print("任务1开始执行...")\n    if acquire_locks_safe(lock_1, lock_2, "任务1"):\n        try:\n            print("任务1: 同时持有两把锁，执行关键代码")\n            time.sleep(0.5)  # 模拟工作\n        finally:\n            # 释放锁\n            lock_2.release()\n            print("任务1: 释放lock_2")\n            lock_1.release()\n            print("任务1: 释放lock_1")\n    else:\n        print("任务1: 无法获取所需的锁，任务取消")\n\ndef task2_fixed():\n    """修复死锁的任务2 - 使用一致的锁获取顺序"""\n    print("任务2开始执行...")\n    # 按与任务1相同的顺序获取锁，避免死锁\n    if acquire_locks_safe(lock_1, lock_2, "任务2"):\n        try:\n            print("任务2: 同时持有两把锁，执行关键代码")\n            time.sleep(0.5)  # 模拟工作\n        finally:\n            # 释放锁\n            lock_2.release()\n            print("任务2: 释放lock_2")\n            lock_1.release()\n            print("任务2: 释放lock_1")\n    else:\n        print("任务2: 无法获取所需的锁，任务取消")\n\n## 创建两个线程\nt1 = threading.Thread(target=task1_fixed)\nt2 = threading.Thread(target=task2_fixed)\n\n## 启动线程\nt1.start()\nt2.start()\n\n## 等待线程结束\nt1.join()\nt2.join()\n\nprint("所有线程执行完毕，没有死锁")\n```\n\n> 🛠️ **死锁预防方法**：\n> 1. **按顺序获取锁**：使所有线程按相同顺序获取锁\n> 2. **超时机制**：使用 `acquire(timeout=N)` 设置获取锁的超时时间\n> 3. **一次性获取所有锁**：创建更高级别的锁来同时获取多个锁\n> 4. **使用显式资源分级**：为资源分配层级，只允许按层级顺序获取\n> 5. **避免嵌套锁**：设计简化的锁策略，减少同时持有多个锁的情况\n> 6. **使用 `with` 语句**：确保锁在异常情况下也能被释放\n\n\n\n#### 原子操作与锁优化\n\n在并发编程中，原子操作是指不可被中断的操作，它们要么完全执行，要么完全不执行。Python 提供了一些原子操作工具，可以减少对锁的依赖。\n\n##### `threading.local` 对象 - 线程本地存储\n\n线程本地存储提供了一种每个线程拥有自己独立数据副本的机制，避免了共享状态带来的并发问题。\n\n> 我们可以往 threading.local()上挂载对象，这样我们的每一个线程就会有属于自己的独立数据\n\n```python\nimport threading\nimport time\nimport random\nfrom concurrent.futures import ThreadPoolExecutor\n\n## 创建线程本地存储对象\nthread_local_data = threading.local()\n\ndef process_request(request_id: int) -> None:\n    """处理请求的工作函数"""\n    # 为当前线程设置上下文信息\n    thread_local_data.user_id = f"user-{random.randint(1000, 9999)}"\n    thread_local_data.request = request_id\n    thread_local_data.start_time = time.time()\n    # 模拟处理请求的各个阶段\n    print(f"请求 {request_id}: 开始处理 [线程: {threading.current_thread().name}, 用户: {thread_local_data.user_id}]")\n    process_stage("验证")\n    process_stage("处理")\n    process_stage("响应")\n    # 计算总处理时间\n    elapsed = time.time() - thread_local_data.start_time\n    print(f"请求 {request_id}: 完成处理，总耗时 {elapsed:.2f}秒 [线程: {threading.current_thread().name}]")\n\n\ndef process_stage(stage_name: str):\n    """处理请求的某个阶段"""\n    # 访问线程本地变量，无需传递参数\n    request_id = thread_local_data.request\n    user_id = thread_local_data.user_id\n\n    # 模拟阶段处理\n    time.sleep(random.uniform(0.1, 0.5))\n    print(f"请求 {request_id}: {stage_name}阶段完成 [用户: {user_id}]")\n\nif __name__ == \'__main__\':\n    with ThreadPoolExecutor(max_workers=10) as executor:\n        futures = [executor.submit(process_request, i) for i in range(10)]\n        for future in futures:\n            future.result()\n        print("所有请求处理完成")\n```\n\n##### `functools.lru_cache` 带锁的缓存\n\n`functools.lru_cache` 装饰器提供了一个线程安全的缓存机制，当一个函数的计算逻辑十分复杂，我们就可以采用缓存来优化这一点\n\n```python\nimport functools\nimport time\n\n# ========== LRU缓存演示 ==========\n@functools.lru_cache(maxsize=128)\ndef fibonacci(n):\n    """计算斐波那契数列的第n个数，使用LRU缓存优化性能"""\n    if n <= 1:\n        return n\n    return fibonacci(n-1) + fibonacci(n-2)\n\ndef demonstrate_lru_cache():\n    """演示LRU缓存的效果"""\n    # 不使用缓存的计算时间\n    def fibonacci_no_cache(n):\n        if n <= 1:\n            return n\n        return fibonacci_no_cache(n-1) + fibonacci_no_cache(n-2)\n    \n    n = 35\n    \n    # 测试无缓存版本\n    start = time.time()\n    result1 = fibonacci_no_cache(n)\n    end = time.time()\n    print(f"无缓存计算fibonacci({n}) = {result1}，耗时: {end - start:.4f}秒")\n    \n    # 测试有缓存版本\n    start = time.time()\n    result2 = fibonacci(n)\n    end = time.time()\n    print(f"首次使用缓存计算fibonacci({n}) = {result2}，耗时: {end - start:.4f}秒")\n    \n    # 再次调用，应该直接从缓存获取结果\n    start = time.time()\n    result3 = fibonacci(n)\n    end = time.time()\n    print(f"再次使用缓存计算fibonacci({n}) = {result3}，耗时: {end - start:.8f}秒")\n    \n    # 显示缓存信息\n    print(f"缓存信息: {fibonacci.cache_info()}")\n\nif __name__ == "__main__":\n    demonstrate_lru_cache()\n\n```\n\n#### 锁的高级应用模式\n\n##### 读写锁模式\n\nPython 中的读写锁（Read-Write Lock）主要用于在多线程环境中控制对共享资源的访问。它允许多个线程同时读取共享数据，但在写操作时，其他线程不能进行读或写操作。具体的应用场景包括：\n\n1. **数据共享与并发读取**：当多个线程需要读取同一份数据时，使用读锁可以提高并发性，允许多个线程同时访问数据，而不需要每次访问都加锁。\n2. **写操作的独占性**：当有线程进行写操作时，需要获取写锁，这样可以确保写操作的独占性，避免数据竞争和不一致性。\n3. **性能优化**：在读多写少的场景下，读写锁能提高性能，因为它允许多个线程并行读取数据，而只有在写入时才会阻塞其他线程。\n\n我们先从 Python 原生实现读写锁来作为演示，掌握了原生的方式，我们可以使用 `readerwriterlock` 第三方库来帮我们快速实现读写锁\n\n```python\nimport threading\nimport time\nimport random\n\n\nclass ReadWriteLock:\n    """读写锁实现\n\n    允许多个读取者同时访问，或单个写入者独占访问\n    """\n\n    def __init__(self):\n        """初始化读写锁"""\n        self._read_ready = threading.Condition(threading.RLock())\n        self._readers = 0  # 当前读取者数量\n        self._writers = 0  # 当前写入者数量\n        self._write_waiting = 0  # 等待写入的线程数\n        self._writer = None  # 当前持有写锁的线程ID\n\n    def acquire_read(self):\n        """获取读锁"""\n        with self._read_ready:\n            # 当有写入者或正在等待的写入者时，读取者需要等待\n            while self._writers > 0 or self._write_waiting > 0:\n                self._read_ready.wait()\n            self._readers += 1\n\n    def release_read(self):\n        """释放读锁"""\n        with self._read_ready:\n            self._readers -= 1\n            if self._readers == 0:  # 最后一个读取者通知所有等待的线程\n                self._read_ready.notify_all()\n\n    def acquire_write(self):\n        """获取写锁"""\n        me = threading.get_ident()  # 获取当前线程ID\n        with self._read_ready:\n            self._write_waiting += 1  # 增加等待写入计数\n            # 等待没有读取者和写入者\n            while self._readers > 0 or self._writers > 0:\n                self._read_ready.wait()\n            self._write_waiting -= 1  # 减少等待写入计数\n            self._writers += 1\n            self._writer = me\n\n    def release_write(self):\n        """释放写锁"""\n        with self._read_ready:\n            if self._writer != threading.get_ident():\n                raise RuntimeError("释放未持有的写锁")\n            self._writers -= 1\n            self._writer = None\n            self._read_ready.notify_all()  # 通知所有等待的线程\n\n    # 支持with语句的上下文管理器\n    class ReadLock:\n        def __init__(self, rw_lock):\n            self.rw_lock = rw_lock\n\n        def __enter__(self):\n            self.rw_lock.acquire_read()\n            return self\n\n        def __exit__(self, exc_type, exc_val, exc_tb):\n            self.rw_lock.release_read()\n\n    class WriteLock:\n        def __init__(self, rw_lock):\n            self.rw_lock = rw_lock\n\n        def __enter__(self):\n            self.rw_lock.acquire_write()\n            return self\n\n        def __exit__(self, exc_type, exc_val, exc_tb):\n            self.rw_lock.release_write()\n\n    # 获取读锁和写锁的方法\n    def read_lock(self):\n        """获取读锁上下文管理器"""\n        return self.ReadLock(self)\n\n    def write_lock(self):\n        """获取写锁上下文管理器"""\n        return self.WriteLock(self)\n\n\n### 共享数据和读写锁\nshared_data = {\'count\': 0, \'values\': []}\nrw_lock = ReadWriteLock()\n\n\ndef reader(reader_id):\n    """读取者线程\n\n    Args:\n        reader_id: 读取者ID\n    """\n    for _ in range(5):\n        # 获取读锁\n        with rw_lock.read_lock():\n            # 读取共享数据\n            count = shared_data[\'count\']\n            values = shared_data[\'values\'].copy()\n\n            # 模拟读取操作\n            time.sleep(random.uniform(0.05, 0.1))\n\n            print(f"读取者 {reader_id}: 读取到 count={count}, values={values}")\n\n        # 读取者之间的休息\n        time.sleep(random.uniform(0.1, 0.3))\n\n\ndef writer(writer_id):\n    """写入者线程\n\n    Args:\n        writer_id: 写入者ID\n    """\n    for i in range(3):\n        # 准备新数据\n        new_value = writer_id * 100 + i\n\n        # 获取写锁\n        with rw_lock.write_lock():\n            # 修改共享数据\n            shared_data[\'count\'] += 1\n            shared_data[\'values\'].append(new_value)\n\n            # 模拟写入操作\n            time.sleep(random.uniform(0.1, 0.2))\n\n            print(f"写入者 {writer_id}: 更新为 count={shared_data[\'count\']}, values={shared_data[\'values\']}")\n\n        # 写入者之间的休息\n        time.sleep(random.uniform(0.3, 0.7))\n\n\n### 创建读取者和写入者线程\nreaders = [threading.Thread(target=reader, args=(i,)) for i in range(5)]\nwriters = [threading.Thread(target=writer, args=(i,)) for i in range(3)]\n\n### 启动所有线程\nall_threads = readers + writers\nfor thread in all_threads:\n    thread.start()\n\n### 等待所有线程完成\nfor thread in all_threads:\n    thread.join()\n\nprint(f"最终数据: count={shared_data[\'count\']}, values={shared_data[\'values\']}")\n```\n\n###### 使用 `readerwriterlock` 库实现读写锁\n\n```python\n"""\n读写锁实现示例\n\nreaderwriterlock库提供了三种读写锁实现：\n- RWLockRead：读者优先（第一读者-写者问题）\n- RWLockWrite：写者优先（第二读者-写者问题）\n- RWLockFair：公平优先（第三读者-写者问题）\n每种锁都有对应的可降级版本（带D后缀），允许将锁从写模式降级到读模式\n"""\n\nimport threading\nimport time\nfrom readerwriterlock import rwlock\n\n# 创建一个公平优先的读写锁\nrw_lock = rwlock.RWLockFairD()\n# 共享数据\nshared_data = {\'count\': 0, \'values\': []}\n\n\ndef read_demo(reader_id, sleep_time=0.5):\n    """用于演示的读取函数"""\n    read_lock = rw_lock.gen_rlock()\n    \n    try:\n        with read_lock:\n            print(f"读取者 {reader_id}: 获得读锁")\n            time.sleep(sleep_time)  # 模拟读取操作\n            print(f"读取者 {reader_id}: 完成读取")\n    finally:\n        print(f"读取者 {reader_id}: 释放读锁")\n\n\ndef write_demo(writer_id, sleep_time=0.5):\n    """用于演示的写入函数"""\n    write_lock = rw_lock.gen_wlock()\n    \n    try:\n        with write_lock:\n            print(f"写入者 {writer_id}: 获得写锁")\n            time.sleep(sleep_time)  # 模拟写入操作\n            print(f"写入者 {writer_id}: 完成写入")\n    finally:\n        print(f"写入者 {writer_id}: 释放写锁")\n\n\ndef demonstrate_read_read_nonblocking():\n    """演示读读不互斥"""\n    print("\\n=== 演示：读读不互斥 ===")\n    \n    threads = []\n    for i in range(5):\n        thread = threading.Thread(target=read_demo, args=(i, 0.5))\n        threads.append(thread)\n        thread.start()\n\n    for thread in threads:\n        thread.join()\n\n\ndef demonstrate_read_write_blocking():\n    """演示读写互斥"""\n    print("\\n=== 演示：读写互斥 ===")\n    \n    # 先启动一个长时间的读取线程\n    read_thread = threading.Thread(target=read_demo, args=(0, 2))\n    read_thread.start()\n\n    # 给读取线程一点时间获取锁\n    time.sleep(0.1)\n\n    # 尝试启动写入线程，应该被阻塞直到读取完成\n    write_thread = threading.Thread(target=write_demo, args=(0, 0.5))\n    write_thread.start()\n\n    read_thread.join()\n    write_thread.join()\n\n\ndef demonstrate_write_write_blocking():\n    """演示写写互斥"""\n    print("\\n=== 演示：写写互斥 ===")\n    \n    # 先启动一个长时间的写入线程\n    write_thread1 = threading.Thread(target=write_demo, args=(0, 2))\n    write_thread1.start()\n\n    # 给第一个写入线程一点时间获取锁\n    time.sleep(0.1)\n\n    # 尝试启动另一个写入线程，应该被阻塞直到第一个写入完成\n    write_thread2 = threading.Thread(target=write_demo, args=(1, 0.5))\n    write_thread2.start()\n\n    write_thread1.join()\n    write_thread2.join()\n\n\ndef demonstrate_timeout():\n    """演示锁获取超时"""\n    print("\\n=== 演示：锁获取超时 ===")\n    \n    # 先启动一个长时间的写入线程\n    write_thread = threading.Thread(target=write_demo, args=(0, 3))\n    write_thread.start()\n\n    # 给写入线程一点时间获取锁\n    time.sleep(0.1)\n\n    # 尝试获取读锁，但设置较短的超时时间\n    read_lock = rw_lock.gen_rlock()\n    if read_lock.acquire(blocking=True, timeout=0.5):\n        try:\n            print("读取者: 成功获得读锁（不应该发生）")\n        finally:\n            read_lock.release()\n    else:\n        print("读取者: 获取读锁超时（预期行为）")\n\n    write_thread.join()\n\n\nif __name__ == \'__main__\':\n    # 演示读读不互斥\n    demonstrate_read_read_nonblocking()\n    # 演示读写互斥\n    demonstrate_read_write_blocking()\n    # 演示写写互斥\n    demonstrate_write_write_blocking()\n    # 演示锁获取超时\n    demonstrate_timeout()\n```\n\n| 读写锁特性    | 描述                                 | 优势                     | 适用场景                   |\n| ------------- | ------------------------------------ | ------------------------ | -------------------------- |\n| 读共享/写独占 | 多个读取可并发，写入需独占           | 提高读多写少场景的并发性 | 配置数据、缓存系统、数据集 |\n| 读写优先级    | 可以设置读优先或写优先               | 根据应用需求调整性能特性 | 根据读写比例调整策略       |\n| 升级/降级     | 支持锁的升级(读 → 写)或降级(写 → 读) | 灵活处理复杂访问模式     | 先检查后修改的操作         |\n\n> 💡 **使用建议**：\n> - 读多写少的场景推荐使用读写锁\n> - 注意防止 "写饥饿"，即读取者太多导致写入者长时间等待\n\n\n\n###### 锁排序（解决死锁）\n\n为避免死锁，一个常用的技术是确保所有线程按照相同的顺序获取多个锁。\n\n```python\nimport threading\nimport time\n\n\nclass Account:\n    """模拟银行账户"""\n\n    def __init__(self, name: str, balance: int = 0):\n        """初始化账户"""\n        self.name = name\n        self.balance = balance\n        self.lock = threading.RLock()\n        # 用于账户排序的唯一ID\n        self.id = id(self)\n\n    def __str__(self):\n        return f"账户{self.name}[余额={self.balance}]"\n\n\ndef transfer_money(from_account: Account, to_account: Account, amount: int, thread_name: str) -> None:\n    """\n    在账户间转账，使用账户ID排序策略避免死锁\n    from_account: 转出账户\n    to_account: 转入账户\n    amount: 转账金额\n    thread_name: 线程名称\n    """\n    # 按照账户ID从小到大的顺序获取锁，确保所有线程获取锁的顺序一致\n    first, second = sorted([from_account, to_account], key=lambda x: x.id)\n    \n    print(f"{thread_name}: 尝试锁定账户 {first.name}")\n    with first.lock:\n        print(f"{thread_name}: 已锁定账户 {first.name}")\n        # 模拟网络延迟\n        time.sleep(0.1)\n        \n        print(f"{thread_name}: 尝试锁定账户 {second.name}")\n        with second.lock:\n            print(f"{thread_name}: 已锁定账户 {second.name}")\n            \n            # 执行转账操作\n            from_account.balance -= amount\n            to_account.balance += amount\n            \n            print(f"{thread_name}: 已从{from_account.name}转账{amount}元到{to_account.name}")\n\n\nif __name__ == \'__main__\':\n    # 创建两个账户\n    alice = Account("Alice", 1000)\n    bob = Account("Bob", 1000)\n    \n    print(f"初始状态: {alice}, {bob}")\n    \n    # 创建两个线程，同时进行相反方向的转账\n    t1 = threading.Thread(\n        name="Thread-1",\n        target=transfer_money,\n        args=(alice, bob, 500, "转账线程1")\n    )\n    \n    t2 = threading.Thread(\n        name="Thread-2",\n        target=transfer_money,\n        args=(bob, alice, 300, "转账线程2")\n    )\n    \n    # 启动线程\n    t1.start()\n    t2.start()\n    \n    # 等待线程结束\n    t1.join()\n    t2.join()\n    \n    print(f"最终状态: {alice}, {bob}")\n```\n\n###### 两阶段锁定\n\n两阶段锁定是一种事务并发控制协议，分为获取阶段和释放阶段，可以保证事务的可串行化。\n\n```python\nimport threading\nimport time\n\nclass TwoPhaseLockDatabase:\n    """演示两阶段锁定协议的简单数据库"""\n\n    def __init__(self):\n        """初始化数据库"""\n        self.data = {\'A\': 100, \'B\': 200}  # 简单的数据项\n        self.locks = {\'A\': threading.RLock(), \'B\': threading.RLock()}  # 每个数据项的锁\n\n    def transaction(self, items_to_read, items_to_write, operation):\n        """执行两阶段锁定事务\n        \n        Args:\n            items_to_read: 需要读取的数据项列表\n            items_to_write: 需要写入的数据项列表\n            operation: 事务操作函数\n        \n        Returns:\n            bool: 事务是否成功\n        """\n        # 按字母顺序排序所有需要锁定的项，避免死锁\n        all_items = sorted(set(items_to_read + items_to_write))\n        acquired_locks = []\n        \n        try:\n            # 阶段1: 获取锁阶段（增长阶段）\n            print(f"事务 {threading.current_thread().name}: 开始获取锁")\n            for item in all_items:\n                # 对于读取项获取共享锁，对于写入项获取排他锁\n                # 这里简化为都使用排他锁\n                if self.locks[item].acquire(timeout=1):\n                    acquired_locks.append(item)\n                    print(f"事务 {threading.current_thread().name}: 已锁定 {item}")\n                else:\n                    raise TimeoutError(f"获取 {item} 的锁超时")\n            \n            # 执行事务操作\n            result = operation(self.data)\n            print(f"事务 {threading.current_thread().name}: 操作完成")\n            return result\n            \n        except Exception as e:\n            print(f"事务 {threading.current_thread().name}: 错误 - {e}")\n            return False\n            \n        finally:\n            # 阶段2: 释放锁阶段（收缩阶段）\n            for item in acquired_locks:\n                self.locks[item].release()\n                print(f"事务 {threading.current_thread().name}: 已释放 {item}")\n\ndef transfer_money(db, from_account, to_account, amount):\n    """转账事务"""\n    def operation(data):\n        if data[from_account] < amount:\n            print(f"账户 {from_account} 余额不足")\n            return False\n        \n        # 模拟操作耗时\n        time.sleep(0.1)\n        \n        # 执行转账\n        data[from_account] -= amount\n        data[to_account] += amount\n        print(f"已从 {from_account} 转账 {amount} 到 {to_account}")\n        return True\n    \n    return db.transaction([from_account, to_account], [from_account, to_account], operation)\n\ndef run_transaction(db, thread_id, from_acc, to_acc, amount):\n    """执行事务的线程函数"""\n    print(f"线程 {thread_id}: 尝试转账 {amount} 从 {from_acc} 到 {to_acc}")\n    \n    start_time = time.time()\n    success = transfer_money(db, from_acc, to_acc, amount)\n    elapsed = time.time() - start_time\n    \n    status = "成功" if success else "失败"\n    print(f"线程 {thread_id}: 转账{status}，耗时 {elapsed:.2f}秒")\n\n# 创建数据库实例\ndb = TwoPhaseLockDatabase()\nprint(f"初始账户状态: {db.data}")\n\n# 创建并启动多个线程\nthreads = []\ntransactions = [\n    ("A", "B", 30),  # 从A转30到B\n    ("B", "A", 50),  # 从B转50到A\n    ("A", "B", 20)   # 从A转20到B\n]\n\nfor i, (from_acc, to_acc, amount) in enumerate(transactions):\n    t = threading.Thread(\n        name=f"Transaction-{i}",\n        target=run_transaction,\n        args=(db, i, from_acc, to_acc, amount)\n    )\n    threads.append(t)\n    t.start()\n\n# 等待所有线程完成\nfor t in threads:\n    t.join()\n\nprint(f"最终账户状态: {db.data}")\nprint(f"总金额: {sum(db.data.values())}")  # 总金额应该不变\n```\n\n###### 超时重试模式\n\n在并发环境中，有时获取锁可能会失败。超时重试模式可以增加获取锁的成功概率，同时避免永久阻塞。\n\n```python\nimport threading\nimport time\nimport random\n\n### 共享资源\nresource_value = 0\nresource_lock = threading.Lock()\n\ndef update_resource(worker_id, max_retries=3):\n    """更新共享资源，使用超时重试模式\n    \n    Args:\n        worker_id: 工作线程ID\n        max_retries: 最大重试次数\n    \n    Returns:\n        bool: 是否成功更新\n    """\n    global resource_value\n    \n    # 随机生成操作标识，用于跟踪\n    operation_id = random.randint(10000, 99999)\n    print(f"工作线程 {worker_id} [操作:{operation_id}]: 尝试更新资源")\n    \n    retry_count = 0\n    backoff = 0.1  # 初始回退时间\n    \n    while retry_count < max_retries:\n        # 尝试获取锁，设置超时时间\n        if resource_lock.acquire(timeout=0.5):\n            try:\n                print(f"工作线程 {worker_id} [操作:{operation_id}]: 获取到锁，当前值: {resource_value}")\n                \n                # 模拟资源更新操作\n                local_value = resource_value\n                # 随机决定操作时间，有时可能很长\n                work_time = random.uniform(0.1, 1.0)\n                time.sleep(work_time)\n                \n                # 更新资源\n                resource_value = local_value + 1\n                \n                print(f"工作线程 {worker_id} [操作:{operation_id}]: 更新成功，新值: {resource_value}，耗时: {work_time:.2f}秒")\n                return True\n                \n            finally:\n                # 释放锁\n                resource_lock.release()\n                print(f"工作线程 {worker_id} [操作:{operation_id}]: 释放锁")\n        else:\n            retry_count += 1\n            print(f"工作线程 {worker_id} [操作:{operation_id}]: 获取锁超时，重试 {retry_count}/{max_retries}")\n            \n            if retry_count < max_retries:\n                # 使用指数退避策略，每次重试间隔加长\n                time.sleep(backoff)\n                backoff *= 2  # 指数增长\n    \n    print(f"工作线程 {worker_id} [操作:{operation_id}]: 达到最大重试次数，放弃操作")\n    return False\n\ndef worker_thread(worker_id, operations):\n    """工作线程函数\n    \n    Args:\n        worker_id: 工作线程ID\n        operations: 要执行的操作次数\n    """\n    success_count = 0\n    \n    for i in range(operations):\n        # 尝试更新资源\n        if update_resource(worker_id):\n            success_count += 1\n        \n        # 线程之间的间隔\n        time.sleep(random.uniform(0.1, 0.5))\n    \n    print(f"工作线程 {worker_id}: 完成 {success_count}/{operations} 次成功更新")\n\n### 创建多个工作线程\nthreads = []\nfor i in range(5):\n    t = threading.Thread(target=worker_thread, args=(i, 3))\n    threads.append(t)\n    t.start()\n\n### 等待所有线程完成\nfor t in threads:\n    t.join()\n\nprint(f"最终资源值: {resource_value}")\n```\n\n##### 多进程与多线程结合的混合模型\n\n对于复杂应用，常常需要结合多进程和多线程的优势：多进程跨越 GIL 限制利用多核心，每个进程内使用多线程处理 I/O 任务。\n\n```python\nimport os\nimport time\nimport multiprocessing\nimport threading\nimport concurrent.futures\nimport requests\nfrom io import StringIO\nimport csv\n\ndef io_task(url):\n    """模拟I/O密集型任务：发送HTTP请求并处理响应"""\n    try:\n        response = requests.get(url, timeout=5)\n        print(f"线程 {threading.current_thread().name} 完成请求 {url}, 状态码: {response.status_code}")\n        return response.status_code\n    except Exception as e:\n        print(f"线程 {threading.current_thread().name} 请求 {url} 失败: {str(e)}")\n        return None\n\ndef cpu_task(data):\n    """模拟CPU密集型任务：处理CSV数据"""\n    result = 0\n    # 模拟CPU密集型计算\n    for _ in range(1000000):\n        result += 1\n    \n    # 解析CSV数据\n    csv_data = StringIO(data)\n    reader = csv.reader(csv_data)\n    rows = list(reader)\n    \n    print(f"进程 {os.getpid()} 处理了 {len(rows)} 行数据")\n    return len(rows)\n\ndef process_worker(process_id, urls):\n    """每个进程的工作函数，使用线程池处理I/O任务"""\n    print(f"进程 {os.getpid()} (ID: {process_id}) 启动")\n    \n    # 创建线程池处理I/O任务\n    with concurrent.futures.ThreadPoolExecutor(max_workers=4) as executor:\n        # 提交所有URL请求任务到线程池\n        future_to_url = {executor.submit(io_task, url): url for url in urls}\n        \n        # 收集结果\n        results = []\n        for future in concurrent.futures.as_completed(future_to_url):\n            url = future_to_url[future]\n            try:\n                status_code = future.result()\n                results.append((url, status_code))\n            except Exception as e:\n                print(f"处理 {url} 时出错: {str(e)}")\n    \n    # 模拟一些CSV数据处理（CPU密集型任务）\n    sample_csv = "col1,col2,col3\\n1,2,3\\n4,5,6\\n7,8,9"\n    cpu_result = cpu_task(sample_csv)\n    \n    print(f"进程 {os.getpid()} (ID: {process_id}) 完成所有任务")\n    return results, cpu_result\n\ndef main():\n    # 测试URL列表\n    all_urls = [\n        f"https://httpbin.org/delay/{i%3}" for i in range(16)\n    ]\n    \n    # 将URL分成4组，每个进程处理4个URL\n    url_chunks = [all_urls[i:i+4] for i in range(0, len(all_urls), 4)]\n    \n    start_time = time.time()\n    \n    # 创建进程池\n    with concurrent.futures.ProcessPoolExecutor(max_workers=4) as process_executor:\n        # 提交任务到进程池\n        futures = [process_executor.submit(process_worker, i, urls) \n                  for i, urls in enumerate(url_chunks)]\n        \n        # 收集所有进程的结果\n        for future in concurrent.futures.as_completed(futures):\n            try:\n                io_results, cpu_result = future.result()\n                print(f"进程返回结果: {len(io_results)} 个URL请求, CPU任务处理了 {cpu_result} 行数据")\n            except Exception as e:\n                print(f"进程执行出错: {str(e)}")\n    \n    elapsed_time = time.time() - start_time\n    print(f"总执行时间: {elapsed_time:.2f} 秒")\n\nif __name__ == "__main__":\n    main()\n\n```\n\n\n\n\n\n这种混合模型充分利用了 Python 的并发性能：\n\n1. **多进程并行**：跨越 GIL 限制，在多个 CPU 核心上同时执行 Python 代码\n2. **每进程多线程**：处理进程内的 I/O 密集型任务，提高 I/O 并发性\n3. **任务队列**：有效分配和管理工作负载，平衡资源利用\n\n\n\n##### 细粒度锁与粗粒度锁\n\n锁的粒度指锁保护资源的范围大小。细粒度锁保护小范围资源，提高并发度；粗粒度锁保护大范围资源，简化编程但可能降低并发度。\n\n```python\nimport threading\nimport time\nimport random\n\n\n# 共享资源\nclass BankAccount:\n    def __init__(self, balance):\n        self.balance = balance\n        # 粗粒度锁 - 用于整个账户操作\n        self.coarse_lock = threading.Lock()\n        # 细粒度锁 - 分别用于读取和写入操作\n        self.read_lock = threading.Lock()\n        self.write_lock = threading.Lock()\n\n# 粗粒度锁示例 - 锁定整个账户操作\ndef transfer_coarse(account, amount):\n    with account.coarse_lock:\n        # 模拟读取余额操作\n        current_balance = account.balance\n        # 模拟网络延迟或处理时间\n        time.sleep(random.uniform(0.001, 0.005))\n        # 模拟更新余额操作\n        account.balance = current_balance + amount\n        print(f"粗粒度锁: 转账 {amount}，当前余额 {account.balance}")\n\n\n# 细粒度锁示例 - 分别锁定读取和写入操作\ndef transfer_fine(account, amount):\n    # 锁定读取操作\n    with account.read_lock:\n        current_balance = account.balance\n        # 模拟处理时间\n        time.sleep(random.uniform(0.001, 0.005))\n\n    # 这里可以执行一些不需要锁定的计算\n    time.sleep(random.uniform(0.001, 0.002))\n\n    # 锁定写入操作\n    with account.write_lock:\n        account.balance = current_balance + amount\n        print(f"细粒度锁: 转账 {amount}，当前余额 {account.balance}")\n\n\n# 测试函数\ndef main():\n    # 创建共享账户\n    account = BankAccount(1000)\n    threads = []\n\n    print("=== 测试粗粒度锁 ===")\n    start_time = time.time()\n\n    # 创建10个使用粗粒度锁的线程\n    for i in range(10):\n        amount = random.randint(1, 100)\n        t = threading.Thread(target=transfer_coarse, args=(account, amount))\n        threads.append(t)\n        t.start()\n\n    # 等待所有线程完成\n    for t in threads:\n        t.join()\n\n    coarse_time = time.time() - start_time\n    print(f"粗粒度锁总耗时: {coarse_time:.4f}秒")\n\n    # 重置账户和线程列表\n    account.balance = 1000\n    threads = []\n\n    print("\\n=== 测试细粒度锁 ===")\n    start_time = time.time()\n\n    # 创建10个使用细粒度锁的线程\n    for i in range(10):\n        amount = random.randint(1, 100)\n        t = threading.Thread(target=transfer_fine, args=(account, amount))\n        threads.append(t)\n        t.start()\n\n    # 等待所有线程完成\n    for t in threads:\n        t.join()\n\n    fine_time = time.time() - start_time\n    print(f"细粒度锁总耗时: {fine_time:.4f}秒")\n    print(f"\\n性能比较: 细粒度锁比粗粒度锁快 {(coarse_time / fine_time):.2f} 倍")\n\nif __name__ == \'__main__\':\n    main()\n\n```\n\n| 锁粒度   | 优点                     | 缺点                         | 适用场景                           |\n| -------- | ------------------------ | ---------------------------- | ---------------------------------- |\n| 粗粒度锁 | 简单、易维护、不易死锁   | 并发性能低、可能导致线程等待 | 简单应用、对性能要求不高的场景     |\n| 细粒度锁 | 并发性能高、资源利用率高 | 实现复杂、可能造成死锁       | 高性能要求、资源访问模式明确的场景 |\n\n\n\n### 14.7 消息队列与进程通信\n\n在并发编程中，队列是一种常用的数据结构。它遵循 **先进先出（FIFO）** 的原则，适合用于线程或进程间的通信，而堆栈则遵循 **后进先出（LIFO）** 的原则。Python 中的 `queue` 和 `multiprocessing` 模块提供了多种类型的队列，每种队列适用于不同的场景。\n\n#### 队列基础知识\n\nPython 的 `queue` 模块和 `multiprocessing` 模块提供了多种队列类型，主要包括：\n\n| 队列类型      | 模块            | 特点                       | 适用场景             |\n| ------------- | --------------- | -------------------------- | -------------------- |\n| Queue         | queue           | 线程安全的 FIFO 队列       | 线程间通信           |\n| LifoQueue     | queue           | 线程安全的 LIFO 队列(堆栈) | 需要后进先出的场景   |\n| PriorityQueue | queue           | 优先级队列                 | 任务具有优先级的场景 |\n| Queue         | multiprocessing | 进程安全的 FIFO 队列       | 进程间通信           |\n| JoinableQueue | multiprocessing | 带有任务完成通知机制的队列 | 生产者-消费者模型    |\n\n#### 队列使用示例\n\n```python\nimport random\nfrom multiprocessing import Queue\nfrom concurrent.futures import ThreadPoolExecutor\nimport time\n\n\n\n# 生产者进程函数\ndef producer(q: Queue) -> None:\n    """生产者函数，负责生产数据并放入队列"""\n    for i in range(10):\n        item = f"小吃{i}"\n        print(f"生产者生产了{item}")\n        q.put(item)  # 放入队列\n        time.sleep(random.uniform(0.1, 0.5))  # 模拟耗时操作\n    q.put(None)  # 生产结束信号\n    print("生产者结束")\n\n\n# 消费者进程函数\ndef consumer(q: Queue):\n    """消费者函数，负责从队列中获取数据并消费"""\n    while True:\n        item = q.get()  # 从队列中获取项目\n        if item is None:  # 若获取到结束信号，则退出循环\n            break\n        print(f"消费者消费了{item}")\n        time.sleep(random.uniform(1, 2))\n    print("消费者结束")\n\n\nif __name__ == \'__main__\':\n    # 创建一个队列对象\n    q = Queue()\n    with ThreadPoolExecutor(max_workers=2) as executor:\n        # 启动生产者进程\n        executor.submit(producer, q)\n        # 启动消费者进程\n        executor.submit(consumer, q)\n\n```\n\n#### 优先级队列示例\n\n优先级队列按任务的优先级顺序处理任务。数字越小优先级越高。以下是如何使用 `PriorityQueue` 的示例：\n\n```python\nimport queue\nimport threading\nimport time\n\n# 创建优先级队列\n# 优先级队列的元素是元组，第一个元素是优先级，第二个元素是任务\npq = queue.PriorityQueue()\n\ndef process_tasks():\n    """按照优先级处理任务"""\n    while True:\n        try:\n            priority,task = pq.get(timeout=3)\n            print(f"处理任务:[优先级{priority}] {task}")\n            pq.task_done()\n        except queue.Empty:\n            print("队列为空，任务处理完毕")\n            break\n# 添加任务到优先级队列\npq.put((3, "普通任务"))\npq.put((1, "紧急任务"))\npq.put((2, "中等优先级任务"))\npq.put((1, "另一个紧急任务"))\npq.put((5, "低优先级任务"))\n\n# 创建任务处理线程\nworker = threading.Thread(target=process_tasks)\nworker.start()\n\npq.join()  # 等待所有任务处理完毕\nworker.join()\n\nprint("所有任务处理完毕")\n\n```'}</script></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/06/16/684f747174bc3.webp" onerror="this.onerror=null,this.src=&quot;/img/friend_404.gif&quot;" alt="avatar"><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/user/status.png" alt="status"></div></div><div class="author-info__description"><div style="line-height:1.4;color:rgba(255,255,255,.9);text-align:center">🚀 全栈开发者，专注于构建优雅高效的数字解决方案<br><span style="color:#fff;font-weight:700">前端 · 后端 · 架构 · 优化</span><br>📚 分享实战经验，一起探索技术边界</div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">Prorise</h1><div class="author-info__desc">这聒噪的世界让沉默的人显得另类</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/361040115?spm_id_from=333.1387.0.0" rel="external nofollow noreferrer" target="_blank" title="BiliBili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a></div></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background:url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center/100% no-repeat"></div><div class="back face" style="background:url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center/100% no-repeat"></div></div></div></div><div class="card-widget card-latest-comments"><div class="item-headline"><i class="fas fa-comments"></i><span>最新评论</span></div><div class="item-content"><a href="/messages/" class="headline-right" title="查看更多"><i class="fas fa-angle-right"></i></a><div class="aside-list" id="latest-comments"></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0%EF%BC%9A%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">第十四章：深入解析并发编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">14. 并发编程基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90"><span class="toc-number">1.1.1.</span> <span class="toc-text">进程调度机制解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%89%E5%A4%A7%E7%8A%B6%E6%80%81%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.1.2.</span> <span class="toc-text">进程的三大状态与生命周期</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-1-%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.</span> <span class="toc-text">14.1 同步与异步编程模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5"><span class="toc-number">1.2.1.</span> <span class="toc-text">同步和异步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="toc-number">1.2.2.</span> <span class="toc-text">阻塞和非阻塞</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-2-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF"><span class="toc-number">1.3.</span> <span class="toc-text">14.2 多进程编程技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="toc-number">1.3.1.</span> <span class="toc-text">进程基础</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.2.</span> <span class="toc-text">进程创建方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E4%BD%BF%E7%94%A8-Process-%E7%B1%BB%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">方法一：使用 Process 类创建进程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E7%BB%A7%E6%89%BF-Process-%E7%B1%BB%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">方法二：继承 Process 类创建进程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E8%A1%A8"><span class="toc-number">1.3.3.</span> <span class="toc-text">多进程常用方法表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%8F%B7%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96"><span class="toc-number">1.3.4.</span> <span class="toc-text">进程号与进程信息获取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.3.5.</span> <span class="toc-text">进程间通信示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.3.6.</span> <span class="toc-text">复杂进程通信示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%B1%A0%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.3.7.</span> <span class="toc-text">进程池详解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.7.1.</span> <span class="toc-text">进程池的主要方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ProcessPoolExecutor-%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.3.7.2.</span> <span class="toc-text">ProcessPoolExecutor 示例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%8F%B7%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96-1"><span class="toc-number">1.3.8.</span> <span class="toc-text">进程号与进程信息获取</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5"><span class="toc-number">1.3.8.1.</span> <span class="toc-text">进程状态特殊情况</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.3.8.1.1.</span> <span class="toc-text">僵尸进程</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.3.8.1.2.</span> <span class="toc-text">孤儿进程</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-3-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90"><span class="toc-number">1.4.</span> <span class="toc-text">14.3 多线程编程深入解析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="toc-number">1.4.1.</span> <span class="toc-text">线程基础</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.2.</span> <span class="toc-text">线程创建方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E4%BD%BF%E7%94%A8-Thread-%E7%B1%BB%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">方法一：使用 Thread 类创建线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E7%BB%A7%E6%89%BF-Thread-%E7%B1%BB%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">方法二：继承 Thread 类创建线程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E8%A1%A8"><span class="toc-number">1.4.3.</span> <span class="toc-text">线程常用方法表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.4.4.</span> <span class="toc-text">线程使用实例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%BA%BF%E7%A8%8B%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">基本线程示例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.4.4.2.</span> <span class="toc-text">守护线程示例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.4.5.</span> <span class="toc-text">线程池详解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ThreadPoolExecutor-%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.5.1.</span> <span class="toc-text">ThreadPoolExecutor 主要方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.4.5.2.</span> <span class="toc-text">完整示例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Event-%E4%BA%8B%E4%BB%B6%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">1.4.6.</span> <span class="toc-text">Event 事件同步机制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Event-%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.6.1.</span> <span class="toc-text">Event 主要方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8-Timer"><span class="toc-number">1.4.7.</span> <span class="toc-text">定时器(Timer)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-%E5%A4%9A%E8%BF%9B%E7%A8%8B-VS-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">1.5.</span> <span class="toc-text">14.4 多进程 VS 多线程性能分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E5%9C%BA%E6%99%AF%E7%9A%84%E6%9C%80%E4%BC%98%E9%80%89%E6%8B%A9"><span class="toc-number">1.5.1.</span> <span class="toc-text">不同场景的最优选择</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E5%AF%86%E9%9B%86%E5%9E%8B%E4%BB%BB%E5%8A%A1%E6%B5%8B%E8%AF%95"><span class="toc-number">1.5.2.</span> <span class="toc-text">计算密集型任务测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IO-%E5%AF%86%E9%9B%86%E5%9E%8B%E4%BB%BB%E5%8A%A1%E6%B5%8B%E8%AF%95"><span class="toc-number">1.5.3.</span> <span class="toc-text">IO 密集型任务测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-5-%E5%8D%8F%E7%A8%8B%E6%8A%80%E6%9C%AF%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.6.</span> <span class="toc-text">14.5 协程技术详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="toc-number">1.6.1.</span> <span class="toc-text">协程基础概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E6%95%88%E7%8E%87%E5%AF%B9%E6%AF%94"><span class="toc-number">1.6.2.</span> <span class="toc-text">协程效率对比</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%B2%E8%A1%8C%E6%89%A7%E8%A1%8C"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">串行执行</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-yield-%E5%AE%9E%E7%8E%B0%E5%8D%8F%E7%A8%8B%E5%88%87%E6%8D%A2"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">使用 yield 实现协程切换</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#greenlet-%E6%A8%A1%E5%9D%97%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-number">1.6.3.</span> <span class="toc-text">greenlet 模块（了解）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#greenlet-%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%E4%B8%8E%E5%B1%9E%E6%80%A7"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">greenlet 核心方法与属性</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gevent-%E6%A8%A1%E5%9D%97%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-number">1.6.4.</span> <span class="toc-text">gevent 模块（了解）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#gevent-%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C"><span class="toc-number">1.6.4.1.</span> <span class="toc-text">gevent 基础操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#gevent-%E5%B8%B8%E7%94%A8-API-%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.6.4.2.</span> <span class="toc-text">gevent 常用 API 详解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.6.4.3.</span> <span class="toc-text">实际应用场景示例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#greenlet-%E4%B8%8E-gevent-%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E9%80%89%E6%8B%A9"><span class="toc-number">1.6.5.</span> <span class="toc-text">greenlet 与 gevent 的区别与选择</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#asyncio-%E5%8D%8F%E7%A8%8B%E6%8A%80%E6%9C%AF"><span class="toc-number">1.6.6.</span> <span class="toc-text">asyncio 协程技术</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#asyncio-%E4%B8%8E%E5%8E%9F%E7%94%9F%E5%8D%8F%E7%A8%8B"><span class="toc-number">1.6.6.1.</span> <span class="toc-text">asyncio 与原生协程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#asyncio-%E5%B8%B8%E7%94%A8-API"><span class="toc-number">1.6.6.2.</span> <span class="toc-text">asyncio 常用 API</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Task-%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.6.7.</span> <span class="toc-text">Task 对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Future-%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.6.8.</span> <span class="toc-text">Future 对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">1.6.9.</span> <span class="toc-text">异步上下文管理器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-6-GIL-%E9%94%81%E4%B8%8E-Python-%E5%B9%B6%E5%8F%91%E6%80%A7%E8%83%BD"><span class="toc-number">1.7.</span> <span class="toc-text">14.6 GIL 锁与 Python 并发性能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#GIL-%E7%9A%84%E6%9C%AC%E8%B4%A8%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.7.1.</span> <span class="toc-text">GIL 的本质与工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.7.2.</span> <span class="toc-text">并发与并行的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="toc-number">1.7.3.</span> <span class="toc-text">线程安全与并发控制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.7.3.1.</span> <span class="toc-text">线程安全问题示例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E9%94%81%E8%A7%A3%E5%86%B3%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">1.7.3.2.</span> <span class="toc-text">使用线程锁解决安全问题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Python-%E4%B8%AD%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90"><span class="toc-number">1.7.4.</span> <span class="toc-text">Python 中的锁机制全面解析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Python-%E9%94%81%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%85%B6%E7%89%B9%E6%80%A7"><span class="toc-number">1.7.4.1.</span> <span class="toc-text">Python 锁类型及其特性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81-Lock"><span class="toc-number">1.7.4.2.</span> <span class="toc-text">互斥锁(Lock)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81-RLock"><span class="toc-number">1.7.4.3.</span> <span class="toc-text">可重入锁(RLock)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F-Condition-%E6%A0%B9%E6%8D%AE%E6%9D%A1%E4%BB%B6%E6%8E%A7%E5%88%B6%E9%94%81"><span class="toc-number">1.7.4.4.</span> <span class="toc-text">条件变量(Condition) - 根据条件控制锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F-Semaphore-%E6%8E%A7%E5%88%B6%E5%B9%B6%E5%8F%91%E6%95%B0%E9%87%8F"><span class="toc-number">1.7.4.5.</span> <span class="toc-text">信号量(Semaphore) - 控制并发数量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%89%E7%95%8C%E4%BF%A1%E5%8F%B7%E9%87%8F-BoundedSemaphore-%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.7.4.6.</span> <span class="toc-text">有界信号量(BoundedSemaphore)详解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1-Event"><span class="toc-number">1.7.4.7.</span> <span class="toc-text">事件对象(Event)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%85%E6%A0%8F%E5%AF%B9%E8%B1%A1-Barrier"><span class="toc-number">1.7.4.8.</span> <span class="toc-text">栅栏对象(Barrier)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%98%9F%E5%88%97-Queue"><span class="toc-number">1.7.4.9.</span> <span class="toc-text">线程安全队列(Queue)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E4%B8%8E%E8%A7%A3%E5%86%B3"><span class="toc-number">1.7.4.10.</span> <span class="toc-text">死锁问题分析与解决</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.7.4.10.1.</span> <span class="toc-text">死锁示例</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">1.7.4.10.2.</span> <span class="toc-text">死锁解决方案</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96"><span class="toc-number">1.7.5.</span> <span class="toc-text">原子操作与锁优化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#threading-local-%E5%AF%B9%E8%B1%A1-%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8"><span class="toc-number">1.7.5.1.</span> <span class="toc-text">threading.local 对象 - 线程本地存储</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#functools-lru-cache-%E5%B8%A6%E9%94%81%E7%9A%84%E7%BC%93%E5%AD%98"><span class="toc-number">1.7.5.2.</span> <span class="toc-text">functools.lru_cache 带锁的缓存</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.7.6.</span> <span class="toc-text">锁的高级应用模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.7.6.1.</span> <span class="toc-text">读写锁模式</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-readerwriterlock-%E5%BA%93%E5%AE%9E%E7%8E%B0%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-number">1.7.6.1.1.</span> <span class="toc-text">使用 readerwriterlock 库实现读写锁</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%94%81%E6%8E%92%E5%BA%8F%EF%BC%88%E8%A7%A3%E5%86%B3%E6%AD%BB%E9%94%81%EF%BC%89"><span class="toc-number">1.7.6.1.2.</span> <span class="toc-text">锁排序（解决死锁）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E9%94%81%E5%AE%9A"><span class="toc-number">1.7.6.1.3.</span> <span class="toc-text">两阶段锁定</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%B6%85%E6%97%B6%E9%87%8D%E8%AF%95%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.7.6.1.4.</span> <span class="toc-text">超时重试模式</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BB%93%E5%90%88%E7%9A%84%E6%B7%B7%E5%90%88%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.7.6.2.</span> <span class="toc-text">多进程与多线程结合的混合模型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%86%E7%B2%92%E5%BA%A6%E9%94%81%E4%B8%8E%E7%B2%97%E7%B2%92%E5%BA%A6%E9%94%81"><span class="toc-number">1.7.6.3.</span> <span class="toc-text">细粒度锁与粗粒度锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-7-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B8%8E%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-number">1.8.</span> <span class="toc-text">14.7 消息队列与进程通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.8.1.</span> <span class="toc-text">队列基础知识</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.8.2.</span> <span class="toc-text">队列使用示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.8.3.</span> <span class="toc-text">优先级队列示例</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/07/01/python%E8%AF%AD%E6%B3%95%E5%89%8D%E7%AF%87%E5%8D%81%E4%BA%94%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" title="Python语法前篇（十五）：第十四章：深入解析并发编程"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/06/17/685113b7c39b1.webp" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" alt="Python语法前篇（十五）：第十四章：深入解析并发编程"></a><div class="content"><a class="title" href="/2025/07/01/python%E8%AF%AD%E6%B3%95%E5%89%8D%E7%AF%87%E5%8D%81%E4%BA%94%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" title="Python语法前篇（十五）：第十四章：深入解析并发编程">Python语法前篇（十五）：第十四章：深入解析并发编程</a><time datetime="2025-07-01T08:13:45.000Z" title="发表于 2025-07-01 16:13:45">2025-07-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/30/python%E8%AF%AD%E6%B3%95%E5%89%8D%E7%AF%87%E5%8D%81%E5%9B%9B%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/" title="Python语法前篇（十四）：第十三章： 高级数据处理"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/06/17/685113b7c39b1.webp" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" alt="Python语法前篇（十四）：第十三章： 高级数据处理"></a><div class="content"><a class="title" href="/2025/06/30/python%E8%AF%AD%E6%B3%95%E5%89%8D%E7%AF%87%E5%8D%81%E5%9B%9B%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/" title="Python语法前篇（十四）：第十三章： 高级数据处理">Python语法前篇（十四）：第十三章： 高级数据处理</a><time datetime="2025-06-30T08:13:45.000Z" title="发表于 2025-06-30 16:13:45">2025-06-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/29/python%E8%AF%AD%E6%B3%95%E5%89%8D%E7%AF%87%E5%8D%81%E4%B8%89%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/" title="Python语法前篇（十三）：第十二章： 异常处理"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/06/17/685113b7c39b1.webp" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" alt="Python语法前篇（十三）：第十二章： 异常处理"></a><div class="content"><a class="title" href="/2025/06/29/python%E8%AF%AD%E6%B3%95%E5%89%8D%E7%AF%87%E5%8D%81%E4%B8%89%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/" title="Python语法前篇（十三）：第十二章： 异常处理">Python语法前篇（十三）：第十二章： 异常处理</a><time datetime="2025-06-29T08:13:45.000Z" title="发表于 2025-06-29 16:13:45">2025-06-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/28/python%E8%AF%AD%E6%B3%95%E5%89%8D%E7%AF%87%E5%8D%81%E4%BA%8C%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/" title="Python语法前篇（十二）：第十一章：面向对象编程"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/06/17/685113b7c39b1.webp" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" alt="Python语法前篇（十二）：第十一章：面向对象编程"></a><div class="content"><a class="title" href="/2025/06/28/python%E8%AF%AD%E6%B3%95%E5%89%8D%E7%AF%87%E5%8D%81%E4%BA%8C%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/" title="Python语法前篇（十二）：第十一章：面向对象编程">Python语法前篇（十二）：第十一章：面向对象编程</a><time datetime="2025-06-28T08:13:45.000Z" title="发表于 2025-06-28 16:13:45">2025-06-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/27/python%E8%AF%AD%E6%B3%95%E5%89%8D%E7%AF%87%E5%8D%81%E4%B8%80%E7%AC%AC%E5%8D%81%E7%AB%A0-%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85/" title="Python语法前篇（十一）：第十章： 模块与包"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/06/17/685113b7c39b1.webp" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" alt="Python语法前篇（十一）：第十章： 模块与包"></a><div class="content"><a class="title" href="/2025/06/27/python%E8%AF%AD%E6%B3%95%E5%89%8D%E7%AF%87%E5%8D%81%E4%B8%80%E7%AC%AC%E5%8D%81%E7%AB%A0-%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85/" title="Python语法前篇（十一）：第十章： 模块与包">Python语法前篇（十一）：第十章： 模块与包</a><time datetime="2025-06-27T08:13:45.000Z" title="发表于 2025-06-27 16:13:45">2025-06-27</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="footer_deal"><a class="deal_link" href="mailto:3381292732@qq.com" rel="external nofollow noreferrer" title="email"><i class="anzhiyufont anzhiyu-icon-envelope"></i></a><a class="deal_link" target="_blank" rel="noopener external nofollow noreferrer" href="https://weibo.com/u/7484736298?tabtype=home" title="微博"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a><a class="deal_link" href="/atom.xml" title="RSS"><i class="anzhiyufont anzhiyu-icon-rss"></i></a><img class="footer_mini_logo" title="返回顶部" alt="返回顶部" onclick="anzhiyu.scrollToDest(0,500)" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/06/16/684f745b722d7.webp" size="50px"><a class="deal_link" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/Prorise-cool" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="deal_link" target="_blank" rel="noopener external nofollow noreferrer" href="https://space.bilibili.com/361040115?spm_id_from=333.788.0.0" title="Bilibili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a><a class="deal_link" href="/copyright" title="CC"><i class="anzhiyufont anzhiyu-icon-copyright-line"></i></a></div><div id="workboard"><div id="runtimeTextTip"></div></div><div class="footer_custom_text">这是我的个人博客，分享技术与生活点滴。</div><div id="anzhiyu-footer"><div class="footer-group"><div class="footer-title">服务</div><div class="footer-links"><a class="footer-item" title="51la统计" target="_blank" rel="noopener external nofollow noreferrer" href="https://v6.51.la/">51la统计</a><a class="footer-item" title="十年之约" target="_blank" rel="noopener external nofollow noreferrer" href="https://www.foreverblog.cn/">十年之约</a></div></div><div class="footer-group"><div class="footer-title">主题</div><div class="footer-links"><a class="footer-item" title="文档" href="/docs/">文档</a><a class="footer-item" title="源码" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu">源码</a></div></div><div class="footer-group"><div class="footer-title">导航</div><div class="footer-links"><a class="footer-item" title="即刻短文" href="/essay/">即刻短文</a><a class="footer-item" title="留言板" href="/comments/">留言板</a></div></div><div class="footer-group"><div class="footer-title">协议</div><div class="footer-links"><a class="footer-item" title="隐私协议" href="/privacy/">隐私协议</a><a class="footer-item" title="版权协议" href="/copyright/">版权协议</a></div></div><div class="footer-group"><div class="footer-title-group"><div class="footer-title">友链</div><a class="random-friends-btn" id="footer-random-friends-btn" href="javascript:addFriendLinksInFooter();" rel="external nofollow noreferrer" title="换一批友情链接"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right"></i></a></div><div class="footer-links" id="friend-links-in-footer"></div></div></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" rel="external nofollow noreferrer" style="margin-inline:5px" data-title="博客框架为Hexo7.0" title="博客框架为Hexo7.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Frame-Hexo.svg" alt="博客框架为Hexo7.0"></a><a class="github-badge" target="_blank" href="https://www.dogecloud.com/" rel="external nofollow noreferrer" style="margin-inline:5px" data-title="本站使用多吉云为静态资源提供CDN加速" title="本站使用多吉云为静态资源提供CDN加速"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.2.0/img/badge/CDN-多吉云-3693F3.svg" alt="本站使用多吉云为静态资源提供CDN加速"></a><a class="github-badge" target="_blank" href="https://github.com/" rel="external nofollow noreferrer" style="margin-inline:5px" data-title="本站项目由Github托管" title="本站项目由Github托管"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Source-Github.svg" alt="本站项目由Github托管"></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" style="margin-inline:5px" data-title="本站采用CC BY-NC-SA 4.0协议" title="本站采用CC BY-NC-SA 4.0协议"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.2.0/img/badge/Copyright-BY-NC-SA.svg" alt="本站采用CC BY-NC-SA 4.0协议"></a></p></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">©2025 By <a class="footer-bar-link" href="/about/" title="Prorise" target="_blank">Prorise</a></div></div><div id="footer-type-tips"></div><div class="js-pjax"><script>function subtitleType () {
  fetch('https://v1.hitokoto.cn')
    .then(response => response.json())
    .then(data => {
      if (true) {
        const from = '出自 ' + data.from
        const sub = ["生活明朗, 万物可爱, 人间值得, 未来可期.","愿你眼里的星星，永远亮晶晶。","愿我们每个人都能被世界温柔以待。"]
        sub.unshift(data.hitokoto, from)
        window.typed = new Typed('#footer-type-tips', {
          strings: sub,
          startDelay: 300,
          typeSpeed: 150,
          loop: true,
          backSpeed: 50,
        })
      } else {
        document.getElementById('footer-type-tips').innerHTML = data.hitokoto
      }
    })
}

if (true) {
  if (typeof Typed === 'function') {
    subtitleType()
  } else {
    getScript('https://lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/typed.js/2.0.12/typed.min.js').then(subtitleType)
  }
} else {
  subtitleType()
}</script></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/Prorise-cool?tab=repositories" title="网站源码">网站源码</a><a class="footer-bar-link" target="_blank" rel="noopener external nofollow noreferrer" href="https://beian.miit.gov.cn/" title="湘ICP备23041-302号">湘ICP备23041-302号</a><a class="footer-bar-link cc" href="/copyright" title="cc协议"><i class="anzhiyufont anzhiyu-icon-copyright-line"></i><i class="anzhiyufont anzhiyu-icon-creative-commons-by-line"></i><i class="anzhiyufont anzhiyu-icon-creative-commons-nc-line"></i><i class="anzhiyufont anzhiyu-icon-creative-commons-nd-line"></i></a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">2</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" rel="external nofollow noreferrer" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" href="/" title="后续项目..."><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="后续项目..."><span class="back-menu-item-text">后续项目...</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><span>文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size:.9em"></i><span> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size:.9em"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size:.9em"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><span>个人</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size:.9em"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size:.9em"></i><span> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/todolist/"><i class="fas fa-check-double faa-tada"></i><span> 代办清单</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><span>预览</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?server=netease&amp;id=3117791189"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size:.9em"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size:.9em"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/messages/"><i class="fas fa-comments faa-tada"></i><span> 评论总览</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><span>关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size:.9em"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size:.9em"></i><span> 即刻短文</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size:.9em"></i><span> 随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Python-%E8%AF%AD%E6%B3%95%E7%AF%87/" style="font-size:.88rem">Python-语法篇<sup>15</sup></a></div></div><hr></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="go-down" type="button" title="直达底部" onclick="anzhiyu.scrollToDest(document.body.scrollHeight,500)"><i class="anzhiyufont anzhiyu-icon-arrow-down"></i></button><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="chat-btn" type="button" title="聊天"><i class="anzhiyufont anzhiyu-icon-comment-sms"></i></button><button id="to_comment" type="button" title="直达评论" onclick="FixedCommentBtn()"><i class="anzhiyufont anzhiyu-icon-comments"></i></button><a id="switch-commentBarrage" href="javascript:anzhiyu.switchCommentBarrage();" rel="external nofollow noreferrer" title="开关弹幕"><i class="anzhiyufont anzhiyu-icon-danmu"></i></a><button id="download-md-btn" type="button" title="下载文章源文件"><i class="anzhiyufont anzhiyu-icon-download"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="3117791189" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size:1rem"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://music.163.com/#/playlist?id=3117791189&quot;, &quot;_blank&quot;);" style="display:none"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/instant.page/5.1.0/instantpage.min.js" type="module"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/vanilla-lazyload/17.3.1/lazyload.iife.min.js"></script><script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/node-snackbar/0.1.16/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/pangu/4.0.7/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><canvas id="universe"></canvas><script async="" src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>//- 从这里开始的所有JS代码，都必须有缩进（例如2个空格）
// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("06/10/2025 00:00:00"); // 此处读取您配置中的建站时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  
  // --- 已将您的专属LOGO和个人信息集成到这里 ---
  const ascll = [
    `欢迎访问 Prorise 的数字空间!`,
    `代码构建世界，思想驱动未来`,
    // 这里的反引号和所有ASCII art行，都必须有正确的缩进
    `
     ____                      _             
    |  _ \\  _ __   ___   _ __  (_) ___   ___  
    | |_) || '__| / _ \\ | '__| | |/ __| / _ \\ 
    |  __/ | |   | (_) || |    | |\\__ \\|  __/ 
    |_|    |_|    \\___/ |_|    |_||___/ \\___| 
                                             
    `,
    "已稳定运行",
    dnum,
    "天",
    `©2025 By Prorise 1.0.0`,
  ];
  
  const ascll2 = [`SYS-INFO`, `前置摄像头拍照成功`, `您的帅气脸庞为：`, `😎`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c${ascll[2]} \n%c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF; font-family:monospace;",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );

  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，朋友.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Created by Prorise %c 你正在访问 Prorise 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 注意，你的所有操作已被记录.", "color:white; background-color:#d9534f", "")
  );
});</script><script async="" src="/anzhiyu/random.js"></script><script async="">(function () {
  var grt = new Date("06/10/2025 00:00:00"); //设置网站上线时间
  var now = new Date();
  var dnum;
  var hnum;
  var mnum;
  var snum;
  var nowHour;

  // 计算并更新天数、小时数、分钟数和秒数
  function updateTime() {
    now = new Date(); // 更新 now 的值
    nowHour = now.getHours(); // 更新 nowHour 的值
    var days = (now - grt) / 1000 / 60 / 60 / 24;
    dnum = Math.floor(days);
    var hours = (now - grt) / 1000 / 60 / 60 - 24 * dnum;
    hnum = Math.floor(hours);
    if (String(hnum).length == 1) {
      hnum = "0" + hnum;
    }
    var minutes = (now - grt) / 1000 / 60 - 24 * 60 * dnum - 60 * hnum;
    mnum = Math.floor(minutes);
    if (String(mnum).length == 1) {
      mnum = "0" + mnum;
    }
    var seconds = (now - grt) / 1000 - 24 * 60 * 60 * dnum - 60 * 60 * hnum - 60 * mnum;
    snum = Math.round(seconds);
    if (String(snum).length == 1) {
      snum = "0" + snum;
    }
  }

  // 更新网页中显示的网站运行时间
  function updateHtml() {
    const footer = document.getElementById("footer");
    if (!footer) return
    let currentTimeHtml = "";
    if (nowHour < 18 && nowHour >= 9) {
      // 如果是上班时间，默认就是"安知鱼-上班摸鱼中.svg"图片，不需要更改
      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    } else {
      // 如果是下班时间，插入"安知鱼-下班啦.svg"图片
      let img = document.querySelector("#workboard .workSituationImg");
      if (img != null) {
        img.src = "";
        img.title = "下班了就该开开心心的玩耍，嘿嘿~";
        img.alt = "下班了就该开开心心的玩耍，嘿嘿~";
      }

      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    }

    if (document.getElementById("runtimeTextTip")) {
      document.getElementById("runtimeTextTip").innerHTML = currentTimeHtml;
    }
  }

  setInterval(() => {
    updateTime();
    updateHtml();
  }, 1000);
})();</script><script src="https://cdn.cbd.int/algoliasearch@4.18.0/dist/algoliasearch-lite.umd.js"></script><script src="https://cdn.cbd.int/instantsearch.js@4.60.0/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script><div class="js-pjax"><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.cbd.int/mermaid@10.2.4/dist/mermaid.min.js').then(runMermaid)
  }

  anzhiyu.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.prorise666.site/',
      region: 'ap-shanghai',
      onCommentLoaded: () => {
        anzhiyu.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(runFn,0)
    else getScript('https://cdn.cbd.int/twikoo@1.6.39/dist/twikoo.all.min.js').then(runFn)
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.prorise666.site/',
      region: 'ap-shanghai',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const runFn = () => {
    init();
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) anzhiyu.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else {
      loadTwikoo()
    }
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script><script>(() => {
  let initFn = window.walineFn || null

  const initWaline = (Fn) => {
    const waline = Fn(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://waline.prorise666.site',
      pageview: true,
      dark: 'html[data-theme="dark"]',
      path: window.location.pathname,
      comment: true,
      imageUploader: true,
    }, null))

    const destroyWaline = () => {
      waline.destroy()
    }

    anzhiyu.addGlobalFn('pjax', destroyWaline, 'destroyWaline')
  }

  const loadWaline = async () => {
    if (initFn) initWaline(initFn)
    else {
      await getCSS('https://cdn.cbd.int/@waline/client@3.1.3/dist/waline.css')
      if (true) await getCSS('https://cdn.cbd.int/@waline/client@3.1.3/dist/waline-meta.css')
      const { init } = await import('https://cdn.cbd.int/@waline/client@3.1.3/dist/waline.js')
      initFn = init || Waline.init
      initWaline(initFn)
      window.walineFn = initFn
    }
  }

  if ('Twikoo' === 'Waline' || !false) {
    if (false) anzhiyu.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"><script async="" src="/js/anzhiyu/comment_barrage.js"></script></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'https://twikoo.prorise666.site/',
        region: 'ap-shanghai',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://cdn.cbd.int/twikoo@1.6.39/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'><div class='name'><span>${array[i].nick} </span></div></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script async="" data-pjax="" src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail=""</script><script async="" data-pjax="" src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><script src="/js/load-on-demand.js"></script><script src="/custom/js/markdown-download.js"></script><script defer="" id="fluttering_ribbon" mobile="false" src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="" color="0,0,255" opacity="0.7" zindex="-1" count="99" mobile="false" src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!1,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><script id="click-heart" src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/click-heart.min.js" async="" mobile="false"></script><script src="//code.tidio.co//tk571vck0ua2wjoalfbp8wyrlsdaunmz.js" async=""></script><script>(() => {
  const isChatBtn = true
  const isChatHideShow = true

  if (isChatBtn) {
    let isShow = false
    const close = () => {
      window.tidioChatApi.hide()
      isShow = false
      document.body.style.position = 'relative';
      document.documentElement.style.overflow = 'auto'
    }
    
    const open = () => {
      window.tidioChatApi.open()
      window.tidioChatApi.show()
      isShow = true
    }

    const onTidioChatApiReady = () => {
      window.tidioChatApi.hide()
      window.tidioChatApi.on("close", close)
    }
    if (window.tidioChatApi) {
      window.tidioChatApi.on("ready", onTidioChatApiReady)
    } else {
      document.addEventListener("tidioChat-ready", onTidioChatApiReady)
    }

    window.chatBtnFn = () => {
      if (!window.tidioChatApi) return
      isShow ? close() : open()
    }
  } else if (isChatHideShow) {
    window.chatBtn = {
      hide: () => {
        window.tidioChatApi && window.tidioChatApi.hide()
      },
      show: () => {
        window.tidioChatApi && window.tidioChatApi.show()
      }
    }
  }
})()</script><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.css" media="print" onload="this.media=&quot;all&quot;"><script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.js"></script><script src="https://npm.elemecdn.com/meting@2.0.1/dist/Meting.min.js"></script><script src="https://lib.baomitu.com/pjax/0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","meta[property=\"og:type\"]","meta[property=\"og:site_name\"]","meta[property=\"og:description\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: true,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '[object Object]', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div>
    <link rel="stylesheet" href="https://ai.tianli0.top/static/public/postChatUser_summary.min.css">
    <script>
        let tianliGPT_key = '';
        let tianliGPT_postSelector = '#post-container .post-content';
        let tianliGPT_Title = '✨ AI 文章摘要';
        let tianliGPT_postURL = '/^https?:\/\/[^\/]+\/[0-9]{4}\/[0-9]{2}\/[0-9]{2}\/';
        let tianliGPT_blacklist = '';
        let tianliGPT_wordLimit = '1000';
        let tianliGPT_typingAnimate = true;
        let tianliGPT_theme = 'default';
        var postChatConfig = {
          backgroundColor: "#4d648d",
          bottom: "76px",
          left: "16px",
          fill: "#FFFFFF",
          width: "50px",
          frameWidth: "380px",
          frameHeight: "600px",
          defaultInput: true,
          upLoadWeb: true,
          showInviteLink: true,
          userTitle: "💬 智能助手",
          userDesc: "我是 Prorise 博客的 AI 助手，有任何关于网站内容的问题都可以问我哦～",
          addButton: true,
          beginningText: "这篇文章介绍了",
          userIcon: "https://ai.tianli0.top/static/img/PostChat.webp",
          userMode: "magic",
          defaultChatQuestions: ["你好","你是谁"],
          defaultSearchQuestions: ["视频压缩","设计"]
        };
    </script>
    <script data-postchat_key="" src="https://ai.tianli0.top/static/public/tianli_gpt.min.js"></script>
  </body></html>