<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><title>3. 会话核心 API 深度解析 | 格物致知</title><meta name="keywords" content="Java微服务-AI篇"><meta name="author" content="Prorise"><meta name="copyright" content="Prorise"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#cee8ff"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="3. 会话核心 API 深度解析"><meta name="application-name" content="3. 会话核心 API 深度解析"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#cee8ff"><meta property="og:type" content="article"><meta property="og:title" content="3. 会话核心 API 深度解析"><meta property="og:url" content="https://prorise-cool.github.io/posts/21190.html"><meta property="og:site_name" content="格物致知"><meta property="og:description" content="3.1 调试与洞察 —— 解密 ChatClient 的通信“黑盒”在进行任何复杂的系统开发时，可观测性（Observability）都是成功的基石。对于 AI 应用开发而言，这一点尤为重要。我们通过 ChatClient 的流畅API与大语言模型（LLM）交互，但这层优雅的抽象也可能成为一个“黑"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://bu.dusays.com/2025/06/19/68535b23089d0.webp"><meta property="article:author" content="Prorise"><meta property="article:tag" content="全栈, Full Stack, 前端, 后端, Node.js, Vue, React, 数据库, Linux, Docker, 个人博客, 技术分享"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://bu.dusays.com/2025/06/19/68535b23089d0.webp"><meta name="description" content="3.1 调试与洞察 —— 解密 ChatClient 的通信“黑盒”在进行任何复杂的系统开发时，可观测性（Observability）都是成功的基石。对于 AI 应用开发而言，这一点尤为重要。我们通过 ChatClient 的流畅API与大语言模型（LLM）交互，但这层优雅的抽象也可能成为一个“黑"><link rel="shortcut icon" href="/img/icons/favicon.ico"><link rel="canonical" href="https://prorise-cool.github.io/posts/21190.html"><link rel="preconnect" href="//cdn.cbd.int"><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="google-site-verification" content="xxx"><meta name="baidu-site-verification" content="code-xxx"><meta name="msvalidate.01" content="xxx"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/6.0.0/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/node-snackbar/0.1.16/snackbar.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload='this.media="all"'><script async src="https://www.googletagmanager.com/gtag/js?id=[object Object]"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","[object Object]")</script><script>const GLOBAL_CONFIG = {
  linkPageTop: {"enable":true,"title":"与数百名博主无限进步","addFriendPlaceholder":"昵称（请勿包含博客等字样）：\n网站地址（要求博客地址，请勿提交个人主页）：\n头像图片url（请提供尽可能清晰的图片，我会上传到我自己的图床）：\n描述：\n站点截图（可选）：\n"},
  peoplecanvas: undefined,
  postHeadAiDescription: {"enable":true,"gptName":"Prorise","mode":"tianli","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"S-DNA1JM95BX2F9L0N","Referer":"https://xx.xx/"},
  diytitle: undefined,
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: 'https://twikoo.prorise666.site/',
  commentBarrageConfig:{"enable":true,"maxBarrage":1,"barrageTime":10000,"accessToken":"b39753735ed0ed5ffeb771bc108e3158","mailMd5":"ec3291d59a8d7d3675df8a0537fcbc979f0fa611c8df55841fb7f4fd162bd07a"},
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: {"mode":"both","api":"https://img2color-go.vercel.app/api?img=","cover_change":true},
  authorStatus: {"skills":["🤣 全栈开发工程师","🙂 前端架构设计师","🙃 后端服务构建者","🤩 移动端应用开发","🤯 数据库设计专家","🥳 DevOps运维实践者","🤭 技术栈多面手","😎 性能优化达人"]},
  algolia: {"appId":"K8Y7M0RMXQ","apiKey":"11fa7380e2694483a44b143044e69e6e","indexName":"prorise_blog","hits":{"per_page":6},"languages":{"input_placeholder":"输入关键词后按下回车查找","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":3,"position":"top","messagePrev":"距离上次更新已经过了","messageNext":"天，文章内容可能已经过时。"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    simplehomepage: false,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: Prorise","link":"链接: ","source":"来源: 格物致知","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: true,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={configTitle:"格物致知",title:"3. 会话核心 API 深度解析",postAI:"false",pageFillDescription:"3.1 调试与洞察 —— 解密 ChatClient 的通信黑盒, 3.1.1 核心利器 Advisor 与 SimpleLoggerAdvisor, 3.1.2 实战配置, 步骤一：配置日志级别, 步骤二：在 ChatClient Bean 中应用顾问, 3.1.3 解读日志输出, 3.2 对话记忆 (Chat Memory) —— 赋予 AI 上下文感知能力, 3.2.1 核心设计：策略与存储分离, 3.2.2 记忆策略：MessageWindowChatMemory, 3.2.3 记忆存储：ChatMemoryRepository 的多种实现, JdbcChatMemoryRepository 深度配置, 3.2.4 注入记忆：MessageChatMemoryAdvisor, 3.2.5 传递会话 ID (Conversation ID), 3.3 会话历史管理 —— 从数据库到业务服务的完整链路, 3.3.1 后端服务搭建：基于 MyBatis-Plus 的高效实践, 步骤一：环境准备, 步骤二：数据访问层 (DAO), 步骤三：业务逻辑层 (Service), 步骤四：API 接口层 (Controller), 3.4 后端服务接口文档, 1. 获取所有会话列表, 2. 获取指定会话详情, 3. 删除指定会话调试与洞察解密的通信黑盒在进行任何复杂的系统开发时可观测性都是成功的基石对于应用开发而言这一点尤为重要我们通过的流畅与大语言模型交互但这层优雅的抽象也可能成为一个黑盒我们编写的你好在框架内部可能会被动态地与系统级指令历史对话甚至是函数调用的定义组合在一起形成一个远比我们想象中复杂的最终请求体当模型的响应与我们的预期出现偏差例如它没有遵循我们的系统指令或者忘记了之前的对话内容我们面临的第一个也是最核心的难题便是我的应用最终到底向发送了什么内容如果无法看清这个黑盒的内部后续的提示词工程上下文管理优化乃至错误排查都将无从谈起本章节将深入探讨提供的核心调试工具让我们能够点亮一盏灯彻底照亮的内部通信链路核心利器与为了解决上述的可观测性问题引入了名为顾问的优雅设计模式在软件工程领域这与面向切面编程中的通知或网络编程中的拦截器中间件思想一脉相承允许我们在不侵入核心逻辑的前提下在其请求发送前和响应返回后织入我们自定义的横切关注点如日志记录指标监控请求响应修改等在众多的内置实现中是我们进行开发和调试时最不可或缺的利器它的核心作用可以简洁地概括如下特性描述核心职责打印完整的和工作模式日志级别为时激活适用场景开发调试调优上下文问题排查性质只读无侵入不修改请求或响应实战配置在的生态中启用的过程极其简单充分体现了约定优于配置的理念步骤一配置日志级别使用强大的作为默认日志框架框架中的每个类都属于一个特定的包我们可以为不同的包路径设置不同的日志级别如的代码位于包下其内部通过判断或来决定是否执行打印逻辑因此我们的第一步就是告诉日志系统我们关心这个包下的信息在文件中添加或修改配置关键将包的日志级别设置为只有这样内部的判断才会为从而执行日志打印逻辑可选但推荐将我们自己应用的包也设为方便观察从到的完整调用链路深度注释这个配置是动态的在应用运行时我们甚至可以通过的端点来动态修改日志级别从而在不重启应用的情况下开启或关闭的输出这在调试线上临时出现的问题时非常有用步骤二在中应用顾问接下来我们需要将的一个实例告知最标准最符合依赖注入思想的做法是在的定义中进行配置文件路径定义的容器会负责创建和管理这个的生命周期会根据我们的配置文件如自动配置好一个实例我们可以在这里直接注入它无需关心其具体实现是还是一个配置了日志顾问的实例关键调用方法将一个或多个顾问应用到该实例的所有调用中这是一种一次配置处处生效的高效方式我们在这里创建了一个的新实例深度注释返回一个建造者模式的实例是其一个配置方法当方法被调用时这些顾问会被存储在最终的实例内部的一个列表中每当或被触发时内部会遍历这个顾问列表依次执行它们的前置和后置逻辑解读日志输出完成了以上配置并重启应用后当我们调用任何一个使用该的接口时的控制台或应用的日志文件中将自动出现详尽的调试信息你是一个由创作出来的大模型名字叫做小请你在以后的回复中以新的身份和语气回复我你好你好我是小很高兴能为您服务有什么可以帮助您的吗这段日志是极其宝贵的调试信息我们可以从中进行深度解读这部分内容至关重要它展示了最终被序列化并准备通过发送给大语言模型的完整消息列表这是一个数组每个对象代表一条这对应了中的角色它通常用于提供高级别的指令或设定的角色对整个对话产生持续影响通过日志我们可以确认通过或方法设置的指令是否被正确应用对应角色代表最终用户的输入结构与顺序这个消息列表的结构和顺序直接影响模型的回答例如在多轮对话中这里会包含历史的和消息通过观察这个列表我们可以精确诊断上下文管理是否出现了问题这部分展示了从收到的响应主体中解析出的核心生成内容对应角色代表的回复生成的具体文本元数据如果日志级别设置为还会打印出更详细的响应信息包括中的元数据如消耗信息和对话结束原因这对于成本估算和流式响应的完整性判断非常有帮助对话记忆赋予上下文感知能力大语言模型的接口遵循协议其核心特性之一就是无状态这意味着服务器不会保存任何关于客户端先前请求的信息每一次调用都是一次全新的独立的对话它对之前的任何交互都一无所知如果我们直接调用问完我的名字是小明之后再问我叫什么它将无法回答这种金鱼记忆显然无法满足构建一个能持续对话的智能应用的需求为了解决这一核心痛点提供了强大而灵活的功能它并非一个单一的类而是一套完整的用于在多次交互中有效存储检索和管理对话上下文的机制理解它是从单次问答迈向智能对话的关键一步核心设计策略与存储分离在对话记忆功能上的核心设计思想是软件工程中关注点分离原则的经典体现将记忆的策略如何记住与记忆的存储记在哪里相分离是与紧密协作的核心组件这一思想通过两个核心接口得以实现策略接口它定义了记忆的行为和策略它的职责不是物理存储而是管理一个列表例如它决定当对话历史过长时应该保留哪些消息遗忘哪些消息这是一种业务逻辑存储接口它定义了记忆的物理存储和检索它的职责非常纯粹就是提供和等方法在后端如内存数据库存取数据这是一种技术实现这个设计的巨大优势在于灵活性和可扩展性我们可以随意组合不同的策略和存储方式比如我们可以用滑动窗口策略配合数据库存储也可以用更复杂的摘要策略配合存储而应用层的代码几乎无需改动在深入之前我们必须严格辨析两个极易混淆的概念概念定义与范围目的与用途对话记忆用于构建下一次的一个相关的有限的对话历史子集为服务让理解上下文进行连贯对话对话记录一次会话中全部完整的消息交换历史为应用和用户服务用于审计回溯查看历史简而言之是的短期工作记忆而是应用的永久档案机制的运行会产生的持久化数据记忆策略是中最常用也是默认的记忆策略它实现了一种高效的滑动窗口机制它的工作原理非常直观我们预设一个窗口大小即最大消息数当需要为新的请求提供上下文时它会从中取出该会話的所有历史消息然后截取最新的条即作为上下文举个例子如果设为那么用户与之间的一轮对话则算两条若超出了这两轮对话的记忆就会被回溯至最后一条这种策略是在成本性能和上下文相关性之间取得最佳平衡的实用方案能有效防止超出模型限制和控制费用记忆存储的多种实现负责将对话消息进行物理存储提供了多种开箱即用的实现实现类存储介质优点缺点适用场景内存零配置极速数据易失开发测试原型关系型数据库可靠持久化需配置生产环境深度配置要在生产环境中使用数据库进行持久化我们需要进行以下配置引入依赖数据库表结构这是期望的表结构理解每个字段的含义至关重要会话的唯一标识符所有属于同一次对话的消息共享此这是实现多会话隔离的关键消息的具体文本内容消息的角色类型通常是或消息创建的时间戳用于排序为未来的多模态消息预留的字段格式存储额外元数据的字段格式如使用量等关键索引为会话创建索引极大地提升按会话查询历史记录的性能避坑指南数据库管理提供了属性可以自动创建上述表结构这在开发时非常方便但在生产环境中是危险的生产环境的数据库表结构变更必须是受控的可追溯的最佳实践在中设置使用专业的数据库迁移工具如或来管理你的数据库将上述语句放入一个版本化的迁移文件中由迁移工具在应用启动时安全地执行这能确保所有环境开发测试生产的数据库结构一致并能安全地回滚配置使用兼容协议注意这里不能加后缀在年的更新中明确指定了不需要后缀很多还是会错以为需要后缀控制何时初始化数据库表结构手动指定数据库平台如注入记忆有了策略和存储我们需要一个胶水将它们粘合起来并自动应用到的调用流程中这个胶水就是下面是一个完整的生产级的持久化记忆配置示例展示了所有组件如何通过的依赖注入优雅地协同工作文件路径定义记忆策略这是一个核心的业务逻辑配置它声明了我们的记忆行为会根据依赖和配置自动注入一个的实现例如当我们引入了时它就是一个实例这种面向接口编程的方式让我们的代码更具灵活性实例代表了使用特定存储的条消息的滑动窗口这一记忆策略指定记忆的仓库指定记忆的策略定义最终的自动配置的实例我们上面定义的策略一个配置了持久化记忆功能的实例关键在接收到策略后会在每次请求前使用传入的调用来加载历史消息并在每次响应后调用来保存新的请求和响应消息传递会话要让记忆机制生效最后一步也是至关重要的一步在调用时我们必须告诉它当前这次对话属于哪个会话以便它能从数据库中加载正确的历史记录并将新的对话存入正确的档案这是通过在每次调用时传递一个会话来实现的层改造层需要能接收并将其通过方法传递给的调用链引入方法带聊天记忆的流式对话用户输入消息会话用于维护和隔离不同对话的聊天记忆回复的文本内容流用户输入消息关键通过方法的将会话作为参数传递给记忆顾问顾问在执行时会从上下文中查找这个从而知道该为哪个会话加载保存记忆是官方提供的标准强烈推荐使用以保持兼容性层改造相应地的接口也需要增加一个参数以从前端或客户端的请求中接收这个关键从请求参数中接收会话至此我们的后端就拥有了完整的可持久化的多会话记忆能力每一个唯一的都会在表中拥有自己独立的可追溯的聊天记录而也能够基于这些记录实现真正智能连贯的多轮对话会话历史管理从数据库到业务服务的完整链路上一章我们成功地利用和让拥有了可持久化的记忆每一次对话相关的都会被自动存入数据库表中这解决了的上下文问题但同时也为我们留下了一笔宝贵的数据资产完整的用户对话记录现在我们的角色将从框架的使用者转变为应用功能的开发者本章的核心任务是直接操作这张由维护的表使用业界流行的框架为其构建一套完整的面向业务的和最终目标是实现一个功能完备的后端服务能够让前端应用查询会话列表加载指定会话的完整历史以及删除会话从而完成一个真正生产级应用的核心闭环后端服务搭建基于的高效实践我们将按照标准的三层架构来搭建我们的历史管理服务步骤一环境准备首先我们需要在项目中集成在中添加依赖在主启动类上添加注解这个注解会告诉框架去哪里扫描我们的接口扫描接口所在的包在中添加配置虽然有很多配置项但对于基础使用配置驼峰命名转换和日志打印就足够了相关配置开启驼峰命名自动转换如数据库的会自动映射到实体的将执行的打印到控制台方便开发调试步骤二数据访问层数据访问层负责与数据库直接交互它包含实体类和接口实体类我们创建一个专门用于操作的实体类它精确地映射到数据库表使用独立的实体类是一种良好的实践可以避免与框架内部模型产生耦合使用注解精确指定数据库表名避免因命名策略不同导致的问题指定主键字段和其生成策略将属性与数据库列名进行映射或接口接口是的核心通过继承我们无需编写任何或语句即可免费获得一套极其强大的单表增删改查能力继承后我们已经拥有了如等所有基础数据库操作对于更复杂的查询我们将使用以获得更好的类型安全和灵活性步骤三业务逻辑层层负责封装核心的业务逻辑它调用层来完成数据操作服务接口定义我们对外提供的所有历史记录管理功能获取所有会话的聚合列表用于前端会话列表展示返回的不是原始消息而是每个会话的概要信息一个列表每个代表一个会话包含等信息根据会话获取该会话的完整聊天记录会话该会话的所有消息实体列表按时间升序排列根据会话删除该会话的所有聊天记录会话操作是否成功服务实现这是所有业务逻辑的具体实现地方法的逻辑相对复杂因为它需要对数据进行聚合处理先查询出所有记录的和按时间倒序排列确保后续处理时能拿到最新的会话使用的方法对所有进行去重得到所有唯一的会话列表由于上一步是倒序的这个列表的顺序会优先保留最新交互的会话遍历每一个唯一的会话为它们分别构建前端需要的概要信息获取该会话的第一条用户消息我们约定用它作为会话的默认标题新的会话对过长的标题进行截断以优化前端显示获取该会话的最后一条消息的时间戳作为会话的最后更新时间用于前端排序构建查询条件查询指定的所有记录并按时间升序排列构建删除条件删除所有匹配指定的记录步骤四接口层最后创建一个全新的将我们的方法暴露为供未来的前端或其他服务调用是和的组合表示该类的所有方法都直接返回或数据为历史记录管理设置统一的有意义的前缀符合设计风格获取所有会话的聚合列表会话列表每个会话包含等信息获取指定会话的完整聊天记录通过路径变量传入的会话该会话的所有消息实体列表删除指定会话的所有聊天记录通过路径变量传入的会话一个包含操作结果的便于客户端判断操作是否成功并获取提示信息删除成功删除失败或会话不存在后端服务接口文档以下是为会话历史管理功能提供的后端接口文档基础获取所有会话列表获取所有已存在的会话的概要信息列表按最后更新时间倒序排列请求请求参数无成功响应你好介绍一下你自己请用写一个快排响应字段说明字段类型描述会话的唯一标识符根据会话第一条用户消息生成的默认标题最长个字符会话的最后更新时间格式获取指定会话详情根据提供的获取该会话的完整聊天记录按消息时间升序排列请求请求参数路径参数参数类型状态描述必需要查询的会话成功响应你好介绍一下你自己你好我是一个由驱动的大语言模型响应字段说明字段类型描述消息的数据库主键所属会话的消息的文本内容消息角色值为或消息的创建时间戳格式删除指定会话根据提供的删除该会话的所有相关聊天记录这是一个破坏性操作请求请求参数路径参数参数类型状态描述必需要删除的会话成功响应删除成功响应字段说明字段类型描述操作是否成功表示成功表示失败操作结果的文本描述信息",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2025-06-21 22:22:46",postMainColor:""}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0F1C2E')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#cee8ff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/index_media.css" media="(max-width:0),screen and (prefers-reduced-motion:reduce)" onload="this.media=`screen`"><link rel="stylesheet" href="/css/post-ui.css" "=""><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://bu.dusays.com/2025/06/16/684f747174bc3.webp"><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"><script async src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="/" title="博客"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="博客"><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" href="/" title="后续项目..."><img class="back-menu-item-icon" src="https://image.anheyu.com/favicon.ico" alt="后续项目..."><span class="back-menu-item-text">后续项目...</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">格物致知</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)" rel="external nofollow noreferrer">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><span>文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size:.9em"></i><span> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size:.9em"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size:.9em"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><span>个人</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size:.9em"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size:.9em"></i><span> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/todolist/"><i class="fas fa-check-double faa-tada"></i><span> 代办清单</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/awesome-links/"><i class="fas fa-link faa-tada"></i><span> 实用网站</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><span>预览</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?server=netease&amp;id=3117791189"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size:.9em"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size:.9em"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/messages/"><i class="fas fa-comments faa-tada"></i><span> 评论总览</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><span>关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size:.9em"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size:.9em"></i><span> 即刻短文</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size:.9em"></i><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="background-change-button"><a class="site-page" onclick="toggleWinbox()" title="切换背景" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-palette"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" rel="external nofollow noreferrer" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole()"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://tc.z.wiki/autoupload/iXoPwUD80CPTvQUyITTBFOykMT9FcWW5SasRoXZEs3Wyl5f0KlZfm6UsKj-HyTuv/20250609/bYMH/418X445/ef9a3f68-d36a-441a-95fe-8179b1a25992.png" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://tc.z.wiki/autoupload/iXoPwUD80CPTvQUyITTBFOykMT9FcWW5SasRoXZEs3Wyl5f0KlZfm6UsKj-HyTuv/20250609/bYMH/418X445/ef9a3f68-d36a-441a-95fe-8179b1a25992.png"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://tc.z.wiki/autoupload/iXoPwUD80CPTvQUyITTBFOykMT9FcWW5SasRoXZEs3Wyl5f0KlZfm6UsKj-HyTuv/20250609/cYu3/347X390/zfb.png" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://tc.z.wiki/autoupload/iXoPwUD80CPTvQUyITTBFOykMT9FcWW5SasRoXZEs3Wyl5f0KlZfm6UsKj-HyTuv/20250609/cYu3/347X390/zfb.png"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title">最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">音乐</div><span class="author-content-item-title">灵魂的碰撞💥</span></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/06/"><span class="card-archive-list-date">六月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">15</span><span>篇</span></div></a></li></ul></div></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);" rel="external nofollow noreferrer"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/" itemprop="url">后端技术</a><i class="anzhiyufont anzhiyu-icon-angle-right post-meta-separator"></i><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Java/" itemprop="url">Java</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/Java%E5%BE%AE%E6%9C%8D%E5%8A%A1-AI%E7%AF%87/" tabindex="-1" itemprop="url"> <span><i class="anzhiyufont anzhiyu-icon-hashtag"></i>Java微服务-AI篇</span></a></span></div></div><h1 class="post-title" itemprop="name headline">3. 会话核心 API 深度解析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2025-06-15T10:13:45.000Z" title="发表于 2025-06-15 18:13:45">2025-06-15</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-06-21T14:22:46.014Z" title="更新于 2025-06-21 22:22:46">2025-06-21</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span data-flag-title="3. 会话核心 API 深度解析"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="twikoo_visitors" title="访问量"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator"> </span><span class="post-meta-position" title="作者IP属地为广东"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>广东</span><span class="post-meta-separator"></span><span class="post-meta-commentcount"><i class="anzhiyufont anzhiyu-icon-comments post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/21190.html#post-comment" tabindex="-1"><span id="twikoo-count"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></a></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://bu.dusays.com/2025/06/19/68535b23089d0.webp"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://prorise-cool.github.io/posts/21190.html"><header><a class="post-meta-categories" href="/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/" itemprop="url">后端技术</a><a class="post-meta-categories" href="/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Java/" itemprop="url">Java</a><a href="/tags/Java%E5%BE%AE%E6%9C%8D%E5%8A%A1-AI%E7%AF%87/" tabindex="-1" itemprop="url">Java微服务-AI篇</a><h1 id="CrawlerTitle" itemprop="name headline">3. 会话核心 API 深度解析</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">Prorise</span><time itemprop="dateCreated datePublished" datetime="2025-06-15T10:13:45.000Z" title="发表于 2025-06-15 18:13:45">2025-06-15</time><time itemprop="dateCreated datePublished" datetime="2025-06-21T14:22:46.014Z" title="更新于 2025-06-21 22:22:46">2025-06-21</time></header><div id="postchat_postcontent"><hr><h2 id="3-1-调试与洞察-——-解密-ChatClient-的通信“黑盒”"><a href="#3-1-调试与洞察-——-解密-ChatClient-的通信“黑盒”" class="headerlink" title="3.1 调试与洞察 —— 解密 ChatClient 的通信“黑盒”"></a>3.1 调试与洞察 —— 解密 <code>ChatClient</code> 的通信“黑盒”</h2><p>在进行任何复杂的系统开发时，可观测性（Observability）都是成功的基石。对于 AI 应用开发而言，这一点尤为重要。我们通过 <code>ChatClient</code> 的流畅API与大语言模型（LLM）交互，但这层优雅的抽象也可能成为一个“黑盒”。我们编写的 <code>.user("你好")</code>，在 Spring AI 框架内部，可能会被动态地与系统级指令、历史对话、甚至是函数调用（Function Calling）的定义组合在一起，形成一个远比我们想象中复杂的最终请求体。</p><p>当模型的响应与我们的预期出现偏差——例如，它没有遵循我们的系统指令，或者忘记了之前的对话内容——我们面临的第一个、也是最核心的难题便是：<strong>我的应用最终到底向 AI 发送了什么内容？</strong> 如果无法看清这个“黑盒”的内部，后续的 Prompt Engineering（提示词工程）、上下文管理优化、乃至错误排查都将无从谈起。本章节将深入探讨 Spring AI 提供的核心调试工具，让我们能够点亮一盏灯，彻底照亮 <code>ChatClient</code> 的内部通信链路。</p><h3 id="3-1-1-核心利器-Advisor-与-SimpleLoggerAdvisor"><a href="#3-1-1-核心利器-Advisor-与-SimpleLoggerAdvisor" class="headerlink" title="3.1.1 核心利器: Advisor 与 SimpleLoggerAdvisor"></a>3.1.1 核心利器: <code>Advisor</code> 与 <code>SimpleLoggerAdvisor</code></h3><p>为了解决上述的可观测性问题，Spring AI 引入了名为 <strong><code>Advisor</code> (顾问)</strong> 的优雅设计模式。在软件工程领域，这与面向切面编程（AOP）中的“通知”（Advice）或网络编程中的“拦截器”（Interceptor）/“中间件”（Middleware）思想一脉相承。<code>Advisor</code> 允许我们在不侵入 <code>ChatClient</code> 核心逻辑的前提下，在其请求发送前和响应返回后“织入”我们自定义的横切关注点（Cross-Cutting Concerns），如日志记录、指标监控、请求/响应修改等。</p><p>在众多 <code>Advisor</code> 的内置实现中，<code>SimpleLoggerAdvisor</code> 是我们进行开发和调试时最不可或缺的利器。它的核心作用可以简洁地概括如下：</p><table><thead><tr><th align="left">特性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><strong>核心职责</strong></td><td align="left">打印完整的<code>ChatRequest</code>和<code>ChatResponse</code></td></tr><tr><td align="left"><strong>工作模式</strong></td><td align="left">日志级别为<code>DEBUG</code>/<code>TRACE</code>时激活</td></tr><tr><td align="left"><strong>适用场景</strong></td><td align="left">开发调试、Prompt调优、上下文问题排查</td></tr><tr><td align="left"><strong>性质</strong></td><td align="left">只读、无侵入，不修改请求或响应</td></tr></tbody></table><h3 id="3-1-2-实战配置"><a href="#3-1-2-实战配置" class="headerlink" title="3.1.2 实战配置"></a>3.1.2 实战配置</h3><p>在 Spring Boot 的生态中，启用 <code>SimpleLoggerAdvisor</code> 的过程极其简单，充分体现了“约定优于配置”的理念。</p><h4 id="步骤一：配置日志级别"><a href="#步骤一：配置日志级别" class="headerlink" title="步骤一：配置日志级别"></a>步骤一：配置日志级别</h4><p>Spring Boot 使用强大的 <code>Logback</code> 作为默认日志框架。框架中的每个类都属于一个特定的包，我们可以为不同的包路径设置不同的日志级别（如 <code>ERROR</code>, <code>WARN</code>, <code>INFO</code>, <code>DEBUG</code>, <code>TRACE</code>）。<code>SimpleLoggerAdvisor</code> 的代码位于 <code>org.springframework.ai.chat.client.advisor</code> 包下，其内部通过判断 <code>logger.isDebugEnabled()</code> 或 <code>logger.isTraceEnabled()</code> 来决定是否执行打印逻辑。因此，我们的第一步就是告诉日志系统，我们关心这个包下的 <code>DEBUG</code> 信息。</p><p>在 <code>src/main/resources/application.yml</code> 文件中添加或修改 <code>logging.level</code> 配置：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># src/main/resources/application.yml</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="comment"># 关键：将 advisor 包的日志级别设置为 DEBUG。</span></span><br><span class="line">    <span class="comment"># 只有这样，SimpleLoggerAdvisor 内部的 isDebugEnabled() 判断才会为 true，从而执行日志打印逻辑。</span></span><br><span class="line">    <span class="attr">org.springframework.ai.chat.client.advisor:</span> <span class="string">DEBUG</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 可选，但推荐：将我们自己应用的包也设为 DEBUG，方便观察从 Controller 到 Service 的完整调用链路。</span></span><br><span class="line">    <span class="attr">com.example.hellospringai:</span> <span class="string">DEBUG</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong>深度注释：</strong> 这个配置是动态的。在应用运行时，我们甚至可以通过 Spring Boot Actuator 的 <code>/loggers</code> 端点来动态修改日志级别，从而在不重启应用的情况下开启或关闭 <code>SimpleLoggerAdvisor</code> 的输出，这在调试线上临时出现的问题时非常有用。</p></blockquote><h4 id="步骤二：在-ChatClient-Bean-中应用顾问"><a href="#步骤二：在-ChatClient-Bean-中应用顾问" class="headerlink" title="步骤二：在 ChatClient Bean 中应用顾问"></a>步骤二：在 <code>ChatClient</code> Bean 中应用顾问</h4><p>接下来，我们需要将 <code>SimpleLoggerAdvisor</code> 的一个实例告知 <code>ChatClient</code>。最标准、最符合依赖注入思想的做法是在 <code>ChatClient</code> 的 <code>@Bean</code> 定义中进行配置。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件路径: src/main/java/com/example/hellospringai/config/CommonConfiguration.java</span></span><br><span class="line"><span class="keyword">package</span> com.example.hellospringai.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.ai.chat.client.ChatClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.ai.chat.client.advisor.SimpleLoggerAdvisor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.ai.chat.model.ChatModel;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonConfiguration</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义 ChatClient Bean。Spring 的 IoC 容器会负责创建和管理这个 Bean 的生命周期。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> chatModel Spring Boot 会根据我们的配置文件（如 spring.ai.openai.api-key）自动配置好一个 ChatModel 实例，</span></span><br><span class="line"><span class="comment">     * 我们可以在这里直接注入它，无需关心其具体实现是 OpenAIChatModel 还是 OllamaChatModel。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 一个配置了日志顾问的 ChatClient 实例。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ChatClient <span class="title function_">chatClient</span><span class="params">(ChatModel chatModel)</span> {</span><br><span class="line">        <span class="keyword">return</span> ChatClient.builder(chatModel)</span><br><span class="line">                <span class="comment">// 关键：调用 .defaultAdvisors() 方法，将一个或多个顾问应用到该 ChatClient 实例的所有调用中。</span></span><br><span class="line">                <span class="comment">// 这是一种“一次配置，处处生效”的高效方式。</span></span><br><span class="line">                <span class="comment">// 我们在这里创建了一个 SimpleLoggerAdvisor 的新实例。</span></span><br><span class="line">                .defaultAdvisors(<span class="keyword">new</span> <span class="title class_">SimpleLoggerAdvisor</span>())</span><br><span class="line">                .build();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong>深度注释：</strong> <code>ChatClient.builder()</code> 返回一个建造者模式的实例，<code>.defaultAdvisors()</code> 是其一个配置方法。当 <code>build()</code> 方法被调用时，这些顾问会被存储在最终的 <code>ChatClient</code> 实例内部的一个列表中。每当 <code>call()</code> 或 <code>stream()</code> 被触发时，<code>ChatClient</code> 内部会遍历这个顾问列表，依次执行它们的前置和后置逻辑。</p></blockquote><h3 id="3-1-3-解读日志输出"><a href="#3-1-3-解读日志输出" class="headerlink" title="3.1.3 解读日志输出"></a>3.1.3 解读日志输出</h3><p>完成了以上配置并重启应用后，当我们调用任何一个使用该 <code>ChatClient</code> 的API接口时，IDE的控制台（或应用的日志文件）中将自动出现详尽的调试信息：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">2025-06-21 23:30:00.123 DEBUG 12345 --- [nio-8080-exec-1] o.s.a.c.c.a.SimpleLoggerAdvisor      :</span><br><span class="line">--- Request:</span><br><span class="line">[</span><br><span class="line">  {</span><br><span class="line">    "messageType": "SYSTEM",</span><br><span class="line">    "content": "你是一个由Prorise创作出来的AI大模型，名字叫做小P，请你在以后的回复中以新的身份和语气回复我"</span><br><span class="line">  },</span><br><span class="line">  {</span><br><span class="line">    "messageType": "USER",</span><br><span class="line">    "content": "你好"</span><br><span class="line">  }</span><br><span class="line">]</span><br><span class="line">--- Response:</span><br><span class="line">{</span><br><span class="line">  "messageType": "ASSISTANT",</span><br><span class="line">  "content": "你好！我是小P，很高兴能为您服务。有什么可以帮助您的吗？"</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这段日志是极其宝贵的调试信息，我们可以从中进行深度解读：</p><ul><li><p><strong><code>--- Request:</code></strong><br>这部分内容至关重要，它展示了<strong>最终被序列化并准备通过HTTP发送给大语言模型API</strong>的完整消息列表。这是一个JSON数组，每个对象代表一条 <code>Message</code>。</p><ul><li><code>"messageType": "SYSTEM"</code>: 这对应了 OpenAI API 中的 <code>system</code> 角色。它通常用于提供高级别的指令或设定AI的角色，对整个对话产生持续影响。通过日志，我们可以确认通过 <code>.defaultSystem()</code> 或 <code>.system()</code> 方法设置的指令是否被正确应用。</li><li><code>"messageType": "USER"</code>: 对应 <code>user</code> 角色，代表最终用户的输入。</li><li><strong>结构与顺序</strong>: 这个消息列表的结构和顺序直接影响模型的回答。例如，在多轮对话中，这里会包含历史的 <code>USER</code> 和 <code>ASSISTANT</code> 消息。通过观察这个列表，我们可以精确诊断上下文管理是否出现了问题。</li></ul></li><li><p><strong><code>--- Response:</code></strong><br>这部分展示了从LLM API收到的响应主体中解析出的核心AI生成内容。</p></li><li><p><code>"messageType": "ASSISTANT"</code>: 对应 <code>assistant</code> 角色，代表AI的回复。</p><ul><li><code>"content"</code>: AI生成的具体文本。</li><li><strong>元数据（Metadata）</strong>: 如果日志级别设置为 <code>TRACE</code>，<code>SimpleLoggerAdvisor</code> 还会打印出更详细的响应信息，包括 <code>ChatResponse</code> 中的元数据，如 <code>usage</code>（Token消耗信息）和 <code>finishReason</code>（对话结束原因），这对于成本估算和流式响应的完整性判断非常有帮助。</li></ul></li></ul><hr><h2 id="3-2-对话记忆-Chat-Memory-——-赋予-AI-上下文感知能力"><a href="#3-2-对话记忆-Chat-Memory-——-赋予-AI-上下文感知能力" class="headerlink" title="3.2 对话记忆 (Chat Memory) —— 赋予 AI 上下文感知能力"></a>3.2 对话记忆 (Chat Memory) —— 赋予 AI 上下文感知能力</h2><p>大语言模型（LLM）的API接口遵循HTTP协议，其核心特性之一就是<strong>无状态（Stateless）</strong>。这意味着服务器不会保存任何关于客户端先前请求的信息。每一次API调用都是一次全新的、独立的对话，它对之前的任何交互都一无所知。如果我们直接调用，问完“我的名字是小明”之后再问“我叫什么？”，它将无法回答。这种“金鱼记忆”显然无法满足构建一个能持续对话的智能应用的需求。</p><p>为了解决这一核心痛点，Spring AI 提供了强大而灵活的<code>ChatMemory</code>功能。它并非一个单一的类，而是一套完整的、用于在多次交互中有效存储、检索和管理对话上下文的机制。理解它，是从“单次问答”迈向“智能对话”的关键一步。</p><h3 id="3-2-1-核心设计：策略与存储分离"><a href="#3-2-1-核心设计：策略与存储分离" class="headerlink" title="3.2.1 核心设计：策略与存储分离"></a>3.2.1 核心设计：策略与存储分离</h3><p>Spring AI在对话记忆功能上的核心设计思想，是软件工程中“关注点分离”原则的经典体现：<strong>将记忆的策略（如何记住）与记忆的存储（记在哪里）相分离</strong>。</p><p><code>ChatMemory</code> 是与 <code>ChatClient</code> 紧密协作的核心组件。这一思想通过两个核心接口得以实现：</p><ol><li><strong><code>ChatMemory</code> (策略接口)</strong>: 它定义了记忆的<strong>行为和策略</strong>。它的职责不是物理存储，而是管理一个<code>Message</code>列表。例如，它决定当对话历史过长时，应该保留哪些消息、遗忘哪些消息，这是一种业务逻辑。</li><li><strong><code>ChatMemoryRepository</code> (存储接口)</strong>: 它定义了记忆的<strong>物理存储和检索</strong>。它的职责非常纯粹，就是提供<code>add</code>和<code>get</code>等方法，在后端（如内存、数据库、Redis）存取<code>Message</code>数据，这是一种技术实现。</li></ol><p>这个设计的巨大优势在于<strong>灵活性和可扩展性</strong>。我们可以随意组合不同的策略和存储方式。比如，我们可以用“滑动窗口策略”配合“数据库存储”，也可以用更复杂的“摘要策略”配合“Redis存储”，而应用层的代码几乎无需改动。</p><p>在深入之前，我们必须严格辨析两个极易混淆的概念：</p><table><thead><tr><th align="left">概念</th><th align="left">定义与范围</th><th align="left">目的与用途</th></tr></thead><tbody><tr><td align="left"><strong>对话记忆 (Chat Memory)</strong></td><td align="left">用于构建下一次Prompt的、一个相关的、有限的对话历史<strong>子集</strong>。</td><td align="left"><strong>为AI服务</strong>，让AI理解上下文，进行连贯对话。</td></tr><tr><td align="left"><strong>对话记录 (Chat History)</strong></td><td align="left">一次会话中<strong>全部、完整的</strong>消息交换历史。</td><td align="left"><strong>为应用和用户服务</strong>，用于审计、回溯、查看历史。</td></tr></tbody></table><p>简而言之，<code>ChatMemory</code> 是AI的“短期工作记忆”，而<code>Chat History</code>是应用的“永久档案”。<code>ChatMemory</code>机制的运行会产生<code>Chat History</code>的持久化数据。</p><h3 id="3-2-2-记忆策略：MessageWindowChatMemory"><a href="#3-2-2-记忆策略：MessageWindowChatMemory" class="headerlink" title="3.2.2 记忆策略：MessageWindowChatMemory"></a>3.2.2 记忆策略：<code>MessageWindowChatMemory</code></h3><p><code>MessageWindowChatMemory</code>是Spring AI中最常用、也是默认的记忆策略。它实现了一种高效的<code>“滑动窗口”</code>机制。</p><p>它的工作原理非常直观：我们预设一个窗口大小（即最大消息数 <code>maxMessages</code>）。当<code>ChatMemory</code>需要为新的API请求提供上下文时，它会从<code>ChatMemoryRepository</code>中取出该会話的所有历史消息，然后截取<strong>最新的N条</strong>（N即<code>maxMessages</code>）作为上下文。<br>举个例子，如果<code>maxMessages</code>设为4，那么用户与AI之间的一轮对话则算两条，若超出了这两轮对话,AI的记忆就会被回溯至最后一条..</p><p>这种策略是在成本、性能和上下文相关性之间取得最佳平衡的实用方案，能有效防止超出模型Token限制和控制API费用。</p><h3 id="3-2-3-记忆存储：ChatMemoryRepository-的多种实现"><a href="#3-2-3-记忆存储：ChatMemoryRepository-的多种实现" class="headerlink" title="3.2.3 记忆存储：ChatMemoryRepository 的多种实现"></a>3.2.3 记忆存储：<code>ChatMemoryRepository</code> 的多种实现</h3><p><code>ChatMemoryRepository</code>负责将对话消息进行物理存储。Spring AI提供了多种开箱即用的实现：</p><table><thead><tr><th align="left">实现类</th><th align="left">存储介质</th><th align="left">优点</th><th align="left">缺点</th><th align="left">适用场景</th></tr></thead><tbody><tr><td align="left"><code>InMemory...Repository</code></td><td align="left">JVM 内存</td><td align="left">零配置, 极速</td><td align="left">数据易失</td><td align="left">开发, 测试, 原型</td></tr><tr><td align="left"><code>Jdbc...Repository</code></td><td align="left">关系型数据库</td><td align="left">可靠, 持久化</td><td align="left">需配置</td><td align="left"><strong>生产环境</strong></td></tr></tbody></table><h4 id="JdbcChatMemoryRepository-深度配置"><a href="#JdbcChatMemoryRepository-深度配置" class="headerlink" title="JdbcChatMemoryRepository 深度配置"></a><code>JdbcChatMemoryRepository</code> 深度配置</h4><p>要在生产环境中使用数据库进行持久化，我们需要进行以下配置：</p><ol><li><p><strong>引入依赖 (<code>pom.xml</code>)</strong>:</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.ai<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-ai-jdbc-store-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>数据库表结构 (DDL for MySQL)</strong>:<br>这是<code>JdbcChatMemoryRepository</code>期望的表结构。理解每个字段的含义至关重要。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> `spring_ai_chat_memory` (</span><br><span class="line">  `id` <span class="type">bigint</span> <span class="keyword">NOT NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="comment">-- 会话的唯一标识符，所有属于同一次对话的消息共享此ID。这是实现多会话隔离的关键。</span></span><br><span class="line">  `conversation_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">NOT NULL</span>,</span><br><span class="line">  <span class="comment">-- 消息的具体文本内容。</span></span><br><span class="line">  `content` text <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">NOT NULL</span>,</span><br><span class="line">  <span class="comment">-- 消息的角色类型，通常是 'USER' 或 'ASSISTANT'。</span></span><br><span class="line">  `type` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">NOT NULL</span>,</span><br><span class="line">  <span class="comment">-- 消息创建的时间戳，用于排序。</span></span><br><span class="line">  `<span class="type">timestamp</span>` <span class="type">timestamp</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  <span class="comment">-- 为未来的多模态消息预留的字段 (JSON格式)。</span></span><br><span class="line">  `media` json <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="comment">-- 存储额外元数据的字段 (JSON格式)，如token使用量等。</span></span><br><span class="line">  `metadata` json <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`id`),</span><br><span class="line">  <span class="comment">-- 关键索引：为会话ID创建索引，极大地提升按会话查询历史记录的性能。</span></span><br><span class="line">  KEY `idx_conversation_id` (`conversation_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_unicode_ci;</span><br></pre></td></tr></tbody></table></figure></li></ol><blockquote><p><strong>避坑指南：数据库Schema管理</strong></p><p>Spring AI提供了<code>spring.ai.chat.memory.repository.jdbc.initialize-schema</code>属性，可以自动创建上述表结构。这在开发时非常方便，但在生产环境中是<strong>危险</strong>的。生产环境的数据库表结构变更必须是受控的、可追溯的。</p><p><strong>最佳实践</strong>：</p><ul><li>在<code>application.yml</code>中设置<code>spring.ai.chat.memory.repository.jdbc.initialize-schema: never</code>。</li><li>使用专业的数据库迁移工具如 <strong>Flyway</strong> 或 <strong>Liquibase</strong> 来管理你的数据库Schema。将上述DDL语句放入一个版本化的SQL迁移文件中，由迁移工具在应用启动时安全地执行。这能确保所有环境（开发、测试、生产）的数据库结构一致，并能安全地回滚。</li></ul></blockquote><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># src/main/resources/application.yml</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">ai:</span></span><br><span class="line">    <span class="attr">openai:</span></span><br><span class="line">      <span class="comment"># DeepSeek API 配置 - 使用 OpenAI 兼容协议</span></span><br><span class="line">      <span class="comment"># 注意！这里不能加v1后缀，在2025年的DeepSeek更新中明确指定了不需要v1后缀</span></span><br><span class="line">      <span class="comment"># 很多AI还是会错以为需要v1后缀</span></span><br><span class="line">      <span class="attr">base-url:</span> <span class="string">https://api.deepseek.com</span></span><br><span class="line">      <span class="attr">api-key:</span> <span class="string">"sk-xxxx"</span></span><br><span class="line">      <span class="attr">chat:</span></span><br><span class="line">        <span class="attr">options:</span></span><br><span class="line">          <span class="attr">model:</span> <span class="string">deepseek-chat</span></span><br><span class="line">          <span class="attr">temperature:</span> <span class="number">0.7</span></span><br><span class="line">    <span class="attr">chat:</span></span><br><span class="line">      <span class="attr">memory:</span></span><br><span class="line">        <span class="attr">repository:</span></span><br><span class="line">          <span class="attr">jdbc:</span></span><br><span class="line">            <span class="comment"># 控制何时初始化数据库表结构</span></span><br><span class="line">            <span class="attr">initialize-schema:</span> <span class="string">never</span></span><br><span class="line">            <span class="comment"># 手动指定数据库平台（如 mysql, postgresql）</span></span><br><span class="line">            <span class="attr">platform:</span> <span class="string">mysql</span></span><br></pre></td></tr></tbody></table></figure><h3 id="3-2-4-注入记忆：MessageChatMemoryAdvisor"><a href="#3-2-4-注入记忆：MessageChatMemoryAdvisor" class="headerlink" title="3.2.4 注入记忆：MessageChatMemoryAdvisor"></a>3.2.4 注入记忆：<code>MessageChatMemoryAdvisor</code></h3><p>有了策略和存储，我们需要一个“胶水”将它们粘合起来，并自动应用到<code>ChatClient</code>的调用流程中。这个胶水就是<code>MessageChatMemoryAdvisor</code>。</p><p>下面是一个完整的、生产级的持久化记忆配置示例，展示了所有组件如何通过Spring的依赖注入（DI）优雅地协同工作。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件路径: src/main/java/com/example/hellospringai/config/CommonConfiguration.java</span></span><br><span class="line"><span class="keyword">package</span> com.example.hellospringai.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.ai.chat.client.ChatClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.ai.chat.client.advisor.MessageChatMemoryAdvisor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.ai.chat.memory.ChatMemory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.ai.chat.memory.MessageWindowChatMemory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.ai.chat.memory.repository.ChatMemoryRepository;</span><br><span class="line"><span class="keyword">import</span> org.springframework.ai.chat.model.ChatModel;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonConfiguration</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义记忆策略Bean。</span></span><br><span class="line"><span class="comment">     * 这是一个核心的业务逻辑配置，它声明了我们的记忆行为。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> chatMemoryRepository Spring Boot 会根据依赖和配置自动注入一个ChatMemoryRepository的实现</span></span><br><span class="line"><span class="comment">     * (例如，当我们引入了spring-ai-jdbc-store-spring-boot-starter时，它就是一个JdbcChatMemoryRepository实例)。</span></span><br><span class="line"><span class="comment">     * 这种“面向接口编程”的方式让我们的代码更具灵活性。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ChatMemory 实例，代表了“使用特定存储的、50条消息的滑动窗口”这一记忆策略。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ChatMemory <span class="title function_">chatMemory</span><span class="params">(ChatMemoryRepository chatMemoryRepository)</span> {</span><br><span class="line">        <span class="keyword">return</span> MessageWindowChatMemory.builder()</span><br><span class="line">                .withChatMemoryRepository(chatMemoryRepository) <span class="comment">// 指定记忆的“仓库”</span></span><br><span class="line">                .withMaxMessages(<span class="number">50</span>) <span class="comment">// 指定记忆的“策略”</span></span><br><span class="line">                .build();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义最终的 ChatClient Bean。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> chatModel 自动配置的ChatModel实例。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> chatMemory 我们上面定义的ChatMemory策略Bean。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 一个配置了持久化记忆功能的ChatClient实例。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ChatClient <span class="title function_">chatClient</span><span class="params">(ChatModel chatModel, ChatMemory chatMemory)</span> {</span><br><span class="line">        <span class="keyword">return</span> ChatClient.builder(chatModel)</span><br><span class="line">                .defaultAdvisors(</span><br><span class="line">                        <span class="comment">// 关键: MessageChatMemoryAdvisor在接收到chatMemory策略后，</span></span><br><span class="line">                        <span class="comment">// 会在每次请求前，使用传入的conversationId调用chatMemory.get()来加载历史消息，</span></span><br><span class="line">                        <span class="comment">// 并在每次响应后，调用chatMemory.add()来保存新的请求和响应消息。</span></span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">MessageChatMemoryAdvisor</span>(chatMemory)</span><br><span class="line">                )</span><br><span class="line">                .build();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="3-2-5-传递会话-ID-Conversation-ID"><a href="#3-2-5-传递会话-ID-Conversation-ID" class="headerlink" title="3.2.5 传递会话 ID (Conversation ID)"></a>3.2.5 传递会话 ID (Conversation ID)</h3><p>要让记忆机制生效，最后一步也是至关重要的一步：在调用 <code>ChatClient</code> 时，我们必须告诉它当前这次对话属于哪个“会话 (Conversation)”，以便它能从数据库中加载正确的历史记录，并将新的对话存入正确的“档案”。这是通过在每次调用时传递一个<strong>会话ID (<code>conversationId</code>)</strong> 来实现的。</p><ul><li><p><strong>Service 层改造</strong>:<br>Service层需要能接收<code>conversationId</code>，并将其通过<code>.advisors()</code>方法传递给<code>ChatClient</code>的调用链。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.hellospringai.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.ai.chat.client.ChatClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.ai.chat.memory.ChatMemory; <span class="comment">// 引入 ChatMemory</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Flux;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatService</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ChatClient chatClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ChatService</span><span class="params">(ChatClient chatClient)</span> {</span><br><span class="line">        <span class="built_in">this</span>.chatClient = chatClient;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 【方法】带聊天记忆的流式对话</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 用户输入消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> conversationId 会话ID，用于维护和隔离不同对话的聊天记忆</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> AI回复的文本内容流</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Flux&lt;String&gt; <span class="title function_">getChatStreamWithMemory</span><span class="params">(String message, String conversationId)</span> {</span><br><span class="line">        <span class="keyword">return</span> chatClient.prompt()</span><br><span class="line">                .user(message) <span class="comment">// 用户输入消息</span></span><br><span class="line">                <span class="comment">// 关键：通过 .advisors() 方法的 Consumer，将会话ID作为参数传递给记忆顾问。</span></span><br><span class="line">                <span class="comment">// 顾问在执行时会从上下文中查找这个Key，从而知道该为哪个会话加载/保存记忆。</span></span><br><span class="line">                <span class="comment">// ChatMemory.CONVERSATION_ID 是官方提供的标准Key，强烈推荐使用以保持兼容性。</span></span><br><span class="line">                .advisors(a -&gt; a.param(ChatMemory.CONVERSATION_ID, conversationId))</span><br><span class="line">                .stream()</span><br><span class="line">                .content();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>Controller 层改造</strong>:<br>相应地，<code>ChatController</code>的接口也需要增加一个<code>chatId</code>参数，以从前端或API客户端的请求中接收这个ID。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.hellospringai.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.hellospringai.service.ChatService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Flux;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping("/ai")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatController</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ChatService chatService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ChatController</span><span class="params">(ChatService chatService)</span> {</span><br><span class="line">        <span class="built_in">this</span>.chatService = chatService;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = "/chat", produces = "text/event-stream;charset=utf-8")</span></span><br><span class="line">    <span class="keyword">public</span> Flux&lt;String&gt; <span class="title function_">streamChat</span><span class="params">(<span class="meta">@RequestParam(value = "message")</span> String message,</span></span><br><span class="line"><span class="params">                                     // 关键: 从请求参数中接收会话ID</span></span><br><span class="line"><span class="params">                                     <span class="meta">@RequestParam(value = "chatId")</span> String chatId)</span> {</span><br><span class="line">        <span class="keyword">return</span> chatService.getChatStreamWithMemory(message, chatId);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><p>至此，我们的后端就拥有了完整的、可持久化的多会话记忆能力。每一个唯一的<code>chatId</code>都会在<code>spring_ai_chat_memory</code>表中拥有自己独立的、可追溯的聊天记录，而<code>ChatClient</code>也能够基于这些记录，实现真正智能、连贯的多轮对话。</p><hr><h2 id="3-3-会话历史管理-——-从数据库到业务服务的完整链路"><a href="#3-3-会话历史管理-——-从数据库到业务服务的完整链路" class="headerlink" title="3.3 会话历史管理 —— 从数据库到业务服务的完整链路"></a>3.3 会话历史管理 —— 从数据库到业务服务的完整链路</h2><p>上一章，我们成功地利用<code>ChatMemory</code>和<code>JdbcChatMemoryRepository</code>让AI拥有了可持久化的记忆。每一次对话，相关的<code>Message</code>都会被自动存入<code>spring_ai_chat_memory</code>数据库表中。这解决了AI的上下文问题，但同时也为我们留下了一笔宝贵的数据资产——完整的用户对话记录。</p><p>现在，我们的角色将从“AI框架的使用者”转变为“应用功能的开发者”。本章的核心任务是，直接操作这张由Spring AI维护的表，使用业界流行的ORM框架<strong>MyBatis-Plus</strong>，为其构建一套完整的、面向业务的<code>Service</code>和<code>Controller</code>。最终目标是实现一个功能完备的后端服务，能够让前端应用查询会话列表、加载指定会话的完整历史、以及删除会话，从而完成一个真正生产级AI应用的核心闭环。</p><h3 id="3-3-1-后端服务搭建：基于-MyBatis-Plus-的高效实践"><a href="#3-3-1-后端服务搭建：基于-MyBatis-Plus-的高效实践" class="headerlink" title="3.3.1 后端服务搭建：基于 MyBatis-Plus 的高效实践"></a>3.3.1 后端服务搭建：基于 MyBatis-Plus 的高效实践</h3><p>我们将按照标准的Spring Boot三层架构（Controller, Service, Mapper/DAO）来搭建我们的历史管理服务。</p><h4 id="步骤一：环境准备"><a href="#步骤一：环境准备" class="headerlink" title="步骤一：环境准备"></a>步骤一：环境准备</h4><p>首先，我们需要在项目中集成MyBatis-Plus。</p><ol><li><p><strong>在 <code>pom.xml</code> 中添加 MyBatis-Plus 依赖</strong>:</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-spring-boot3-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>在主启动类上添加 <code>@MapperScan</code> 注解</strong>:<br>这个注解会告诉MyBatis-Plus框架去哪里扫描我们的Mapper接口。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.hellospringai;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扫描Mapper接口所在的包</span></span><br><span class="line"><span class="meta">@MapperScan("com.example.hellospringai.mapper")</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloSpringAiApplication</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        SpringApplication.run(HelloSpringAiApplication.class, args);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>在 <code>application.yml</code> 中添加 MyBatis-Plus 配置</strong>:<br>虽然MyBatis-Plus有很多配置项，但对于基础使用，配置驼峰命名转换和SQL日志打印就足够了。</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mybatis-plus相关配置</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="comment"># 开启驼峰命名自动转换, 如数据库的 conversation_id 会自动映射到Java实体的 conversationId</span></span><br><span class="line">    <span class="attr">map-underscore-to-camel-case:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 将执行的SQL打印到控制台，方便开发调试</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></tbody></table></figure></li></ol><h4 id="步骤二：数据访问层-DAO"><a href="#步骤二：数据访问层-DAO" class="headerlink" title="步骤二：数据访问层 (DAO)"></a>步骤二：数据访问层 (DAO)</h4><p>数据访问层负责与数据库直接交互。它包含实体类（Entity）和Mapper接口。</p><ul><li><p><strong>实体类 <code>ChatMemoryEntity.java</code></strong>:<br>我们创建一个专门用于MyBatis-Plus操作的实体类，它精确地映射到<code>spring_ai_chat_memory</code>数据库表。使用独立的实体类是一种良好的实践，可以避免与框架内部模型产生耦合。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.hellospringai.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.*;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="comment">// 使用 @TableName 注解精确指定数据库表名，避免因命名策略不同导致的问题</span></span><br><span class="line"><span class="meta">@TableName("spring_ai_chat_memory")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatMemoryEntity</span> {</span><br><span class="line">    <span class="comment">// @TableId 指定主键字段和其生成策略</span></span><br><span class="line">    <span class="meta">@TableId(value = "id", type = IdType.AUTO)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// @TableField 将Java属性与数据库列名进行映射</span></span><br><span class="line">    <span class="meta">@TableField("conversation_id")</span></span><br><span class="line">    <span class="keyword">private</span> String conversationId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableField("content")</span></span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableField("type")</span></span><br><span class="line">    <span class="keyword">private</span> String type; <span class="comment">// USER 或 ASSISTANT</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableField("timestamp")</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime timestamp;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>Mapper 接口 <code>ChatMemoryMapper.java</code></strong>:<br>Mapper接口是MyBatis-Plus的核心，通过继承<code>BaseMapper</code>，我们无需编写任何XML或SQL语句，即可免费获得一套极其强大的单表CRUD（增删改查）能力。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.hellospringai.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.mapper.BaseMapper;</span><br><span class="line"><span class="keyword">import</span> com.example.hellospringai.entity.ChatMemoryEntity;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Mapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ChatMemoryMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;ChatMemoryEntity&gt; {</span><br><span class="line">    <span class="comment">// 继承 BaseMapper&lt;ChatMemoryEntity&gt; 后，我们已经拥有了如</span></span><br><span class="line">    <span class="comment">// insert, deleteById, delete(wrapper), updateById, selectById, selectList(wrapper) 等所有基础数据库操作。</span></span><br><span class="line">    <span class="comment">// 对于更复杂的查询，我们将使用 QueryWrapper，以获得更好的类型安全和灵活性。</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="步骤三：业务逻辑层-Service"><a href="#步骤三：业务逻辑层-Service" class="headerlink" title="步骤三：业务逻辑层 (Service)"></a>步骤三：业务逻辑层 (Service)</h4><p>Service层负责封装核心的业务逻辑，它调用Mapper层来完成数据操作。</p><ul><li><p><strong>服务接口 <code>IChatHistoryService.java</code></strong>:<br>定义我们对外提供的所有历史记录管理功能。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.hellospringai.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.IService;</span><br><span class="line"><span class="keyword">import</span> com.example.hellospringai.entity.ChatMemoryEntity;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IChatHistoryService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;ChatMemoryEntity&gt; {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取所有会话的聚合列表，用于前端会话列表展示。</span></span><br><span class="line"><span class="comment">     * 返回的不是原始消息，而是每个会话的概要信息。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 一个Map列表，每个Map代表一个会话，包含id, label, updatedAt等信息。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">getAllConversations</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据会话ID获取该会话的完整聊天记录。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> conversationId 会话ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 该会话的所有消息实体列表，按时间升序排列。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;ChatMemoryEntity&gt; <span class="title function_">getChatHistory</span><span class="params">(String conversationId)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据会话ID删除该会话的所有聊天记录。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> conversationId 会话ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 操作是否成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">deleteChatHistory</span><span class="params">(String conversationId)</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>服务实现 <code>ChatHistoryServiceImpl.java</code></strong>:<br>这是所有业务逻辑的具体实现地。<code>getAllConversations</code>方法的逻辑相对复杂，因为它需要对数据进行聚合处理。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.hellospringai.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line"><span class="keyword">import</span> com.example.hellospringai.entity.ChatMemoryEntity;</span><br><span class="line"><span class="keyword">import</span> com.example.hellospringai.mapper.ChatMemoryMapper;</span><br><span class="line"><span class="keyword">import</span> com.example.hellospringai.service.IChatHistoryService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatHistoryServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;ChatMemoryMapper, ChatMemoryEntity&gt; <span class="keyword">implements</span> <span class="title class_">IChatHistoryService</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">getAllConversations</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 1. 先查询出所有记录的 conversation_id 和 timestamp，按时间倒序排列，确保后续处理时能拿到最新的会话。</span></span><br><span class="line">        QueryWrapper&lt;ChatMemoryEntity&gt; idQueryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">        idQueryWrapper.select(<span class="string">"conversation_id"</span>, <span class="string">"timestamp"</span>).orderByDesc(<span class="string">"timestamp"</span>);</span><br><span class="line">        List&lt;ChatMemoryEntity&gt; allRecords = <span class="built_in">this</span>.list(idQueryWrapper);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 使用 Java Stream 的 distinct() 方法，对所有 conversation_id 进行去重，得到所有唯一的会话ID列表。</span></span><br><span class="line">        <span class="comment">// 由于上一步是倒序的，这个列表的顺序会优先保留最新交互的会话。</span></span><br><span class="line">        List&lt;String&gt; distinctConvIds = allRecords.stream()</span><br><span class="line">                .map(ChatMemoryEntity::getConversationId)</span><br><span class="line">                .distinct()</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 遍历每一个唯一的会话ID，为它们分别构建前端需要的概要信息。</span></span><br><span class="line">        <span class="keyword">return</span> distinctConvIds.stream().map(id -&gt; {</span><br><span class="line">            Map&lt;String, Object&gt; conversationInfo = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            conversationInfo.put(<span class="string">"id"</span>, id);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.1 获取该会话的第一条用户消息，我们约定用它作为会话的默认标题。</span></span><br><span class="line">            <span class="type">ChatMemoryEntity</span> <span class="variable">firstUserMessage</span> <span class="operator">=</span> <span class="built_in">this</span>.query()</span><br><span class="line">                    .eq(<span class="string">"conversation_id"</span>, id).eq(<span class="string">"type"</span>, <span class="string">"USER"</span>)</span><br><span class="line">                    .orderByAsc(<span class="string">"timestamp"</span>).last(<span class="string">"LIMIT 1"</span>).one();</span><br><span class="line">            <span class="type">String</span> <span class="variable">title</span> <span class="operator">=</span> (firstUserMessage != <span class="literal">null</span> &amp;&amp; firstUserMessage.getContent() != <span class="literal">null</span>)</span><br><span class="line">                    ? firstUserMessage.getContent().trim() : <span class="string">"新的会话"</span>;</span><br><span class="line">            <span class="comment">// 对过长的标题进行截断，以优化前端显示</span></span><br><span class="line">            conversationInfo.put(<span class="string">"label"</span>, title.length() &gt; <span class="number">20</span> ? title.substring(<span class="number">0</span>, <span class="number">20</span>) + <span class="string">"..."</span> : title);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.2 获取该会话的最后一条消息的时间戳，作为会话的“最后更新时间”，用于前端排序。</span></span><br><span class="line">            <span class="type">ChatMemoryEntity</span> <span class="variable">lastMessage</span> <span class="operator">=</span> <span class="built_in">this</span>.query()</span><br><span class="line">                    .eq(<span class="string">"conversation_id"</span>, id).orderByDesc(<span class="string">"timestamp"</span>)</span><br><span class="line">                    .last(<span class="string">"LIMIT 1"</span>).one();</span><br><span class="line">            conversationInfo.put(<span class="string">"updatedAt"</span>, lastMessage != <span class="literal">null</span> ? lastMessage.getTimestamp() : LocalDateTime.now());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> conversationInfo;</span><br><span class="line">        }).collect(Collectors.toList());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;ChatMemoryEntity&gt; <span class="title function_">getChatHistory</span><span class="params">(String conversationId)</span> {</span><br><span class="line">        <span class="comment">// 构建查询条件：查询指定 conversation_id 的所有记录，并按时间升序排列。</span></span><br><span class="line">        QueryWrapper&lt;ChatMemoryEntity&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(<span class="string">"conversation_id"</span>, conversationId).orderByAsc(<span class="string">"timestamp"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.list(queryWrapper);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">deleteChatHistory</span><span class="params">(String conversationId)</span> {</span><br><span class="line">        <span class="comment">// 构建删除条件：删除所有匹配指定 conversation_id 的记录。</span></span><br><span class="line">        QueryWrapper&lt;ChatMemoryEntity&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(<span class="string">"conversation_id"</span>, conversationId);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.remove(queryWrapper);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="步骤四：API-接口层-Controller"><a href="#步骤四：API-接口层-Controller" class="headerlink" title="步骤四：API 接口层 (Controller)"></a>步骤四：API 接口层 (Controller)</h4><p>最后，创建一个全新的 Controller，将我们的 Service 方法暴露为 RESTful API，供（未来的）前端或其他服务调用。</p><ul><li><p><strong><code>ChatHistoryController.java</code></strong>:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.hellospringai.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.hellospringai.entity.ChatMemoryEntity;</span><br><span class="line"><span class="keyword">import</span> com.example.hellospringai.service.IChatHistoryService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @RestController 是 @Controller 和 @ResponseBody 的组合，表示该类的所有方法都直接返回JSON或XML数据。</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="comment">// 为历史记录管理API设置统一的、有意义的URL前缀，符合RESTful设计风格。</span></span><br><span class="line"><span class="meta">@RequestMapping("/api/chat-history")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatHistoryController</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IChatHistoryService chatHistoryService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ChatHistoryController</span><span class="params">(IChatHistoryService chatHistoryService)</span> {</span><br><span class="line">        <span class="built_in">this</span>.chatHistoryService = chatHistoryService;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取所有会话的聚合列表。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 会话列表，每个会话包含id, label, updatedAt等信息。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping("/conversations")</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">getAllConversations</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> chatHistoryService.getAllConversations();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取指定会话的完整聊天记录。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> conversationId 通过URL路径变量传入的会话ID。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 该会话的所有消息实体列表。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping("/conversation/{conversationId}")</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;ChatMemoryEntity&gt; <span class="title function_">getChatHistory</span><span class="params">(<span class="meta">@PathVariable</span> String conversationId)</span> {</span><br><span class="line">        <span class="keyword">return</span> chatHistoryService.getChatHistory(conversationId);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除指定会话的所有聊天记录。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> conversationId 通过URL路径变量传入的会话ID。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 一个包含操作结果的Map，便于客户端判断操作是否成功并获取提示信息。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@DeleteMapping("/conversation/{conversationId}")</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">deleteChatHistory</span><span class="params">(<span class="meta">@PathVariable</span> String conversationId)</span> {</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> chatHistoryService.deleteChatHistory(conversationId);</span><br><span class="line">        <span class="keyword">return</span> Map.of(</span><br><span class="line">            <span class="string">"success"</span>, success,</span><br><span class="line">            <span class="string">"message"</span>, success ? <span class="string">"删除成功"</span> : <span class="string">"删除失败或会话不存在"</span></span><br><span class="line">        );</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><hr><h2 id="3-4-后端服务接口文档"><a href="#3-4-后端服务接口文档" class="headerlink" title="3.4 后端服务接口文档"></a>3.4 后端服务接口文档</h2><p>以下是为“会话历史管理”功能提供的后端RESTful API接口文档。</p><p><strong>基础URL (Base URL)</strong>: <code>http://localhost:8080</code></p><hr><h3 id="1-获取所有会话列表"><a href="#1-获取所有会话列表" class="headerlink" title="1. 获取所有会话列表"></a>1. 获取所有会话列表</h3><p>获取所有已存在的会话的概要信息列表，按最后更新时间倒序排列。</p><ul><li><p><strong>请求</strong></p><p><code>GET /api/chat-history/conversations</code></p></li><li><p><strong>请求参数</strong></p><p>无</p></li><li><p><strong>成功响应 (<code>200 OK</code>)</strong></p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"id"</span><span class="punctuation">:</span> <span class="string">"conv_1718985665_a1b2c3d4"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"label"</span><span class="punctuation">:</span> <span class="string">"你好，介绍一下你自己"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"updatedAt"</span><span class="punctuation">:</span> <span class="string">"2025-06-22T01:21:05.123456"</span></span><br><span class="line">  <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"id"</span><span class="punctuation">:</span> <span class="string">"conv_1718985601_e5f6g7h8"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"label"</span><span class="punctuation">:</span> <span class="string">"请用Java写一个快排..."</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"updatedAt"</span><span class="punctuation">:</span> <span class="string">"2025-06-22T01:20:01.789012"</span></span><br><span class="line">  <span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>响应字段说明</strong></p></li></ul><table><thead><tr><th align="left">字段</th><th align="left">类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>id</code></td><td align="left"><code>String</code></td><td align="left">会话的唯一标识符。</td></tr><tr><td align="left"><code>label</code></td><td align="left"><code>String</code></td><td align="left">根据会话第一条用户消息生成的默认标题（最长20个字符）。</td></tr><tr><td align="left"><code>updatedAt</code></td><td align="left"><code>String</code></td><td align="left">会话的最后更新时间（ISO 8601格式）。</td></tr></tbody></table><hr><h3 id="2-获取指定会话详情"><a href="#2-获取指定会话详情" class="headerlink" title="2. 获取指定会话详情"></a>2. 获取指定会话详情</h3><p>根据提供的<code>conversationId</code>，获取该会话的完整聊天记录，按消息时间升序排列。</p><ul><li><p><strong>请求</strong></p><p><code>GET /api/chat-history/conversation/{conversationId}</code></p></li><li><p><strong>请求参数</strong></p><p><strong>路径参数 (Path Parameters):</strong></p></li></ul><table><thead><tr><th align="left">参数</th><th align="left">类型</th><th align="left">状态</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>conversationId</code></td><td align="left"><code>String</code></td><td align="left"><strong>必需</strong></td><td align="left">要查询的会话ID。</td></tr></tbody></table><ul><li><p><strong>成功响应 (<code>200 OK</code>)</strong></p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"id"</span><span class="punctuation">:</span> <span class="number">101</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"conversationId"</span><span class="punctuation">:</span> <span class="string">"conv_1718985665_a1b2c3d4"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"content"</span><span class="punctuation">:</span> <span class="string">"你好，介绍一下你自己"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"USER"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"timestamp"</span><span class="punctuation">:</span> <span class="string">"2025-06-22T01:21:00.123456"</span></span><br><span class="line">  <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"id"</span><span class="punctuation">:</span> <span class="number">102</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"conversationId"</span><span class="punctuation">:</span> <span class="string">"conv_1718985665_a1b2c3d4"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"content"</span><span class="punctuation">:</span> <span class="string">"你好！我是一个由Spring AI驱动的大语言模型..."</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"ASSISTANT"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"timestamp"</span><span class="punctuation">:</span> <span class="string">"2025-06-22T01:21:05.123456"</span></span><br><span class="line">  <span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>响应字段说明</strong></p></li></ul><table><thead><tr><th align="left">字段</th><th align="left">类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>id</code></td><td align="left"><code>Long</code></td><td align="left">消息的数据库主键ID。</td></tr><tr><td align="left"><code>conversationId</code></td><td align="left"><code>String</code></td><td align="left">所属会话的ID。</td></tr><tr><td align="left"><code>content</code></td><td align="left"><code>String</code></td><td align="left">消息的文本内容。</td></tr><tr><td align="left"><code>type</code></td><td align="left"><code>String</code></td><td align="left">消息角色，值为 <code>USER</code> 或 <code>ASSISTANT</code>。</td></tr><tr><td align="left"><code>timestamp</code></td><td align="left"><code>String</code></td><td align="left">消息的创建时间戳（ISO 8601格式）。</td></tr></tbody></table><hr><h3 id="3-删除指定会话"><a href="#3-删除指定会话" class="headerlink" title="3. 删除指定会话"></a>3. 删除指定会话</h3><p>根据提供的<code>conversationId</code>，删除该会话的所有相关聊天记录。这是一个<strong>破坏性</strong>操作。</p><ul><li><p><strong>请求</strong></p><p><code>DELETE /api/chat-history/conversation/{conversationId}</code></p></li><li><p><strong>请求参数</strong></p><p><strong>路径参数 (Path Parameters):</strong></p></li></ul><table><thead><tr><th align="left">参数</th><th align="left">类型</th><th align="left">状态</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>conversationId</code></td><td align="left"><code>String</code></td><td align="left"><strong>必需</strong></td><td align="left">要删除的会话ID。</td></tr></tbody></table><ul><li><p><strong>成功响应 (<code>200 OK</code>)</strong></p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">  <span class="attr">"success"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"message"</span><span class="punctuation">:</span> <span class="string">"删除成功"</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>响应字段说明</strong></p></li></ul><table><thead><tr><th align="left">字段</th><th align="left">类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>success</code></td><td align="left"><code>Boolean</code></td><td align="left">操作是否成功。<code>true</code>表示成功，<code>false</code>表示失败。</td></tr><tr><td align="left"><code>message</code></td><td align="left"><code>String</code></td><td align="left">操作结果的文本描述信息。</td></tr></tbody></table></div></article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/06/16/684f747174bc3.webp" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/06/16/684f747174bc3.webp" title="头像" alt="头像"></a><div class="post-copyright__author_name">Prorise</div><div class="post-copyright__author_desc">这聒噪的世界让沉默的人显得另类</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://prorise-cool.github.io/posts/21190.html">原创</a><a class="post-copyright-title"><span onclick='rm.copyPageUrl("https://prorise-cool.github.io/posts/21190.html")'>3. 会话核心 API 深度解析</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://tc.z.wiki/autoupload/iXoPwUD80CPTvQUyITTBFOykMT9FcWW5SasRoXZEs3Wyl5f0KlZfm6UsKj-HyTuv/20250609/bYMH/418X445/ef9a3f68-d36a-441a-95fe-8179b1a25992.png" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://tc.z.wiki/autoupload/iXoPwUD80CPTvQUyITTBFOykMT9FcWW5SasRoXZEs3Wyl5f0KlZfm6UsKj-HyTuv/20250609/bYMH/418X445/ef9a3f68-d36a-441a-95fe-8179b1a25992.png" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://tc.z.wiki/autoupload/iXoPwUD80CPTvQUyITTBFOykMT9FcWW5SasRoXZEs3Wyl5f0KlZfm6UsKj-HyTuv/20250609/cYu3/347X390/zfb.png" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://tc.z.wiki/autoupload/iXoPwUD80CPTvQUyITTBFOykMT9FcWW5SasRoXZEs3Wyl5f0KlZfm6UsKj-HyTuv/20250609/cYu3/347X390/zfb.png" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display:none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://prorise-cool.github.io/posts/21190.html"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=3. 会话核心 API 深度解析&amp;url=https://prorise-cool.github.io/posts/21190.html&amp;pic=https://bu.dusays.com/2025/06/19/68535b23089d0.webp" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl(){var e=window.location.href,t=document.createElement("input");t.setAttribute("value",e),document.body.appendChild(t),t.select(),t.setSelectionRange(0,99999),document.execCommand("copy"),document.body.removeChild(t)}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://Prorise-cool.github.io" target="_blank">格物致知</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__category-list"><a class="post-meta__box__categoryes" href="/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/"><span class="categoryes-punctuation"><i class="anzhiyufont anzhiyu-icon-inbox"></i></span>后端技术<span class="categoryesPageCount">15</span></a><a class="post-meta__box__categoryes" href="/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/Java/"><span class="categoryes-punctuation"> <i class="anzhiyufont anzhiyu-icon-inbox"></i></span>Java<span class="categoryesPageCount">15</span></a></div><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/Java%E5%BE%AE%E6%9C%8D%E5%8A%A1-AI%E7%AF%87/"><span class="tags-punctuation"><i class="anzhiyufont anzhiyu-icon-tag"></i></span>Java微服务-AI篇<span class="tagsPageCount">15</span></a></div></div><div class="post_share"><div class="social-share" data-image="https://bu.dusays.com/2025/06/19/68535b23089d0.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://lib.baomitu.com/social-share.js/1.0.16/js/social-share.min.js" defer></script></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/12027.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/06/19/68535b23089d0.webp" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">2. 快速入门：构建你的第一个 AI 应用</div></div></a></div><div class="next-post pull-right"><a href="/posts/25888.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/06/19/68535b23089d0.webp" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">4. 深入 Prompt 工程</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size:1.5rem;margin-right:4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/posts/12027.html" title="2. 快速入门：构建你的第一个 AI 应用"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/06/19/68535b23089d0.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-06-15</div><div class="title">2. 快速入门：构建你的第一个 AI 应用</div></div></a></div><div><a href="/posts/59558.html" title="1. 序章：迎接 Java AI 开发新纪元"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/06/19/68535b23089d0.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-06-15</div><div class="title">1. 序章：迎接 Java AI 开发新纪元</div></div></a></div><div><a href="/posts/17745.html" title="12. 生产环境考量与部署"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/06/19/68535b23089d0.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-06-16</div><div class="title">12. 生产环境考量与部署</div></div></a></div><div><a href="/posts/36675.html" title="13. 实战项目：构建一个完整的 AI 知识库应用"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/06/19/68535b23089d0.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-06-16</div><div class="title">13. 实战项目：构建一个完整的 AI 知识库应用</div></div></a></div><div><a href="/posts/57498.html" title="10. 构建高级 RAG 应用"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/06/19/68535b23089d0.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-06-16</div><div class="title">10. 构建高级 RAG 应用</div></div></a></div><div><a href="/posts/24414.html" title="11. ETL 框架：文档处理与数据摄取"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/06/19/68535b23089d0.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-06-16</div><div class="title">11. ETL 框架：文档处理与数据摄取</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)" rel="external nofollow noreferrer">匿名评论</a><a href="/privacy" style="margin-left:4px">隐私政策</a></div><div class="comment-switch"><span class="first-comment">Twikoo</span><span id="switch-btn"></span><span class="second-comment">Waline</span></div><div class="comment-tips" id="comment-tips"><span>✅ 你无需删除空行，直接评论以获取最佳展示效果</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div><div><div id="waline-wrap"></div></div></div></div><div class="comment-barrage"></div><script>window.postData={title:"3. 会话核心 API 深度解析",date:"2025-06-15 18:13:45",updated:"2025-06-21 22:22:46",tags:["Java微服务-AI篇"],categories:["后端技术","Java"],content:'\n\n\n\n-----\n\n## 3.1 调试与洞察 —— 解密 `ChatClient` 的通信“黑盒”\n\n在进行任何复杂的系统开发时，可观测性（Observability）都是成功的基石。对于 AI 应用开发而言，这一点尤为重要。我们通过 `ChatClient` 的流畅API与大语言模型（LLM）交互，但这层优雅的抽象也可能成为一个“黑盒”。我们编写的 `.user("你好")`，在 Spring AI 框架内部，可能会被动态地与系统级指令、历史对话、甚至是函数调用（Function Calling）的定义组合在一起，形成一个远比我们想象中复杂的最终请求体。\n\n当模型的响应与我们的预期出现偏差——例如，它没有遵循我们的系统指令，或者忘记了之前的对话内容——我们面临的第一个、也是最核心的难题便是：**我的应用最终到底向 AI 发送了什么内容？** 如果无法看清这个“黑盒”的内部，后续的 Prompt Engineering（提示词工程）、上下文管理优化、乃至错误排查都将无从谈起。本章节将深入探讨 Spring AI 提供的核心调试工具，让我们能够点亮一盏灯，彻底照亮 `ChatClient` 的内部通信链路。\n\n### 3.1.1 核心利器: `Advisor` 与 `SimpleLoggerAdvisor`\n\n为了解决上述的可观测性问题，Spring AI 引入了名为 **`Advisor` (顾问)** 的优雅设计模式。在软件工程领域，这与面向切面编程（AOP）中的“通知”（Advice）或网络编程中的“拦截器”（Interceptor）/“中间件”（Middleware）思想一脉相承。`Advisor` 允许我们在不侵入 `ChatClient` 核心逻辑的前提下，在其请求发送前和响应返回后“织入”我们自定义的横切关注点（Cross-Cutting Concerns），如日志记录、指标监控、请求/响应修改等。\n\n在众多 `Advisor` 的内置实现中，`SimpleLoggerAdvisor` 是我们进行开发和调试时最不可或缺的利器。它的核心作用可以简洁地概括如下：\n\n| 特性 | 描述 |\n| :--- | :--- |\n| **核心职责** | 打印完整的`ChatRequest`和`ChatResponse` |\n| **工作模式** | 日志级别为`DEBUG`/`TRACE`时激活 |\n| **适用场景** | 开发调试、Prompt调优、上下文问题排查 |\n| **性质** | 只读、无侵入，不修改请求或响应 |\n\n### 3.1.2 实战配置\n\n在 Spring Boot 的生态中，启用 `SimpleLoggerAdvisor` 的过程极其简单，充分体现了“约定优于配置”的理念。\n\n#### 步骤一：配置日志级别\n\nSpring Boot 使用强大的 `Logback` 作为默认日志框架。框架中的每个类都属于一个特定的包，我们可以为不同的包路径设置不同的日志级别（如 `ERROR`, `WARN`, `INFO`, `DEBUG`, `TRACE`）。`SimpleLoggerAdvisor` 的代码位于 `org.springframework.ai.chat.client.advisor` 包下，其内部通过判断 `logger.isDebugEnabled()` 或 `logger.isTraceEnabled()` 来决定是否执行打印逻辑。因此，我们的第一步就是告诉日志系统，我们关心这个包下的 `DEBUG` 信息。\n\n在 `src/main/resources/application.yml` 文件中添加或修改 `logging.level` 配置：\n\n```yaml\n# src/main/resources/application.yml\nlogging:\n  level:\n    # 关键：将 advisor 包的日志级别设置为 DEBUG。\n    # 只有这样，SimpleLoggerAdvisor 内部的 isDebugEnabled() 判断才会为 true，从而执行日志打印逻辑。\n    org.springframework.ai.chat.client.advisor: DEBUG\n    \n    # 可选，但推荐：将我们自己应用的包也设为 DEBUG，方便观察从 Controller 到 Service 的完整调用链路。\n    com.example.hellospringai: DEBUG\n```\n\n> **深度注释：** 这个配置是动态的。在应用运行时，我们甚至可以通过 Spring Boot Actuator 的 `/loggers` 端点来动态修改日志级别，从而在不重启应用的情况下开启或关闭 `SimpleLoggerAdvisor` 的输出，这在调试线上临时出现的问题时非常有用。\n\n#### 步骤二：在 `ChatClient` Bean 中应用顾问\n\n接下来，我们需要将 `SimpleLoggerAdvisor` 的一个实例告知 `ChatClient`。最标准、最符合依赖注入思想的做法是在 `ChatClient` 的 `@Bean` 定义中进行配置。\n\n```java\n// 文件路径: src/main/java/com/example/hellospringai/config/CommonConfiguration.java\npackage com.example.hellospringai.config;\n\nimport org.springframework.ai.chat.client.ChatClient;\nimport org.springframework.ai.chat.client.advisor.SimpleLoggerAdvisor;\nimport org.springframework.ai.chat.model.ChatModel;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class CommonConfiguration {\n\n    /**\n     * 定义 ChatClient Bean。Spring 的 IoC 容器会负责创建和管理这个 Bean 的生命周期。\n     * @param chatModel Spring Boot 会根据我们的配置文件（如 spring.ai.openai.api-key）自动配置好一个 ChatModel 实例，\n     * 我们可以在这里直接注入它，无需关心其具体实现是 OpenAIChatModel 还是 OllamaChatModel。\n     * @return 一个配置了日志顾问的 ChatClient 实例。\n     */\n    @Bean\n    public ChatClient chatClient(ChatModel chatModel) {\n        return ChatClient.builder(chatModel)\n                // 关键：调用 .defaultAdvisors() 方法，将一个或多个顾问应用到该 ChatClient 实例的所有调用中。\n                // 这是一种“一次配置，处处生效”的高效方式。\n                // 我们在这里创建了一个 SimpleLoggerAdvisor 的新实例。\n                .defaultAdvisors(new SimpleLoggerAdvisor())\n                .build();\n    }\n}\n```\n\n> **深度注释：** `ChatClient.builder()` 返回一个建造者模式的实例，`.defaultAdvisors()` 是其一个配置方法。当 `build()` 方法被调用时，这些顾问会被存储在最终的 `ChatClient` 实例内部的一个列表中。每当 `call()` 或 `stream()` 被触发时，`ChatClient` 内部会遍历这个顾问列表，依次执行它们的前置和后置逻辑。\n\n### 3.1.3 解读日志输出\n\n完成了以上配置并重启应用后，当我们调用任何一个使用该 `ChatClient` 的API接口时，IDE的控制台（或应用的日志文件）中将自动出现详尽的调试信息：\n\n```log\n2025-06-21 23:30:00.123 DEBUG 12345 --- [nio-8080-exec-1] o.s.a.c.c.a.SimpleLoggerAdvisor      :\n--- Request:\n[\n  {\n    "messageType": "SYSTEM",\n    "content": "你是一个由Prorise创作出来的AI大模型，名字叫做小P，请你在以后的回复中以新的身份和语气回复我"\n  },\n  {\n    "messageType": "USER",\n    "content": "你好"\n  }\n]\n--- Response:\n{\n  "messageType": "ASSISTANT",\n  "content": "你好！我是小P，很高兴能为您服务。有什么可以帮助您的吗？"\n}\n```\n\n这段日志是极其宝贵的调试信息，我们可以从中进行深度解读：\n\n  * **`--- Request:`**\n    这部分内容至关重要，它展示了**最终被序列化并准备通过HTTP发送给大语言模型API**的完整消息列表。这是一个JSON数组，每个对象代表一条 `Message`。\n\n      * `"messageType": "SYSTEM"`: 这对应了 OpenAI API 中的 `system` 角色。它通常用于提供高级别的指令或设定AI的角色，对整个对话产生持续影响。通过日志，我们可以确认通过 `.defaultSystem()` 或 `.system()` 方法设置的指令是否被正确应用。\n      * `"messageType": "USER"`: 对应 `user` 角色，代表最终用户的输入。\n      * **结构与顺序**: 这个消息列表的结构和顺序直接影响模型的回答。例如，在多轮对话中，这里会包含历史的 `USER` 和 `ASSISTANT` 消息。通过观察这个列表，我们可以精确诊断上下文管理是否出现了问题。\n\n  * **`--- Response:`**\n    这部分展示了从LLM API收到的响应主体中解析出的核心AI生成内容。\n  * `"messageType": "ASSISTANT"`: 对应 `assistant` 角色，代表AI的回复。\n      * `"content"`: AI生成的具体文本。\n      * **元数据（Metadata）**: 如果日志级别设置为 `TRACE`，`SimpleLoggerAdvisor` 还会打印出更详细的响应信息，包括 `ChatResponse` 中的元数据，如 `usage`（Token消耗信息）和 `finishReason`（对话结束原因），这对于成本估算和流式响应的完整性判断非常有帮助。\n\n\n\n\n\n\n-----\n\n## 3.2 对话记忆 (Chat Memory) —— 赋予 AI 上下文感知能力\n\n大语言模型（LLM）的API接口遵循HTTP协议，其核心特性之一就是**无状态（Stateless）**。这意味着服务器不会保存任何关于客户端先前请求的信息。每一次API调用都是一次全新的、独立的对话，它对之前的任何交互都一无所知。如果我们直接调用，问完“我的名字是小明”之后再问“我叫什么？”，它将无法回答。这种“金鱼记忆”显然无法满足构建一个能持续对话的智能应用的需求。\n\n为了解决这一核心痛点，Spring AI 提供了强大而灵活的`ChatMemory`功能。它并非一个单一的类，而是一套完整的、用于在多次交互中有效存储、检索和管理对话上下文的机制。理解它，是从“单次问答”迈向“智能对话”的关键一步。\n\n### 3.2.1 核心设计：策略与存储分离\n\nSpring AI在对话记忆功能上的核心设计思想，是软件工程中“关注点分离”原则的经典体现：**将记忆的策略（如何记住）与记忆的存储（记在哪里）相分离**。\n\n\n\n`ChatMemory` 是与 `ChatClient` 紧密协作的核心组件。这一思想通过两个核心接口得以实现：\n\n1.  **`ChatMemory` (策略接口)**: 它定义了记忆的**行为和策略**。它的职责不是物理存储，而是管理一个`Message`列表。例如，它决定当对话历史过长时，应该保留哪些消息、遗忘哪些消息，这是一种业务逻辑。\n2.  **`ChatMemoryRepository` (存储接口)**: 它定义了记忆的**物理存储和检索**。它的职责非常纯粹，就是提供`add`和`get`等方法，在后端（如内存、数据库、Redis）存取`Message`数据，这是一种技术实现。\n\n这个设计的巨大优势在于**灵活性和可扩展性**。我们可以随意组合不同的策略和存储方式。比如，我们可以用“滑动窗口策略”配合“数据库存储”，也可以用更复杂的“摘要策略”配合“Redis存储”，而应用层的代码几乎无需改动。\n\n在深入之前，我们必须严格辨析两个极易混淆的概念：\n\n| 概念 | 定义与范围 | 目的与用途 |\n| :--- | :--- | :--- |\n| **对话记忆 (Chat Memory)** | 用于构建下一次Prompt的、一个相关的、有限的对话历史**子集**。 | **为AI服务**，让AI理解上下文，进行连贯对话。 |\n| **对话记录 (Chat History)** | 一次会话中**全部、完整的**消息交换历史。 | **为应用和用户服务**，用于审计、回溯、查看历史。 |\n\n简而言之，`ChatMemory` 是AI的“短期工作记忆”，而`Chat History`是应用的“永久档案”。`ChatMemory`机制的运行会产生`Chat History`的持久化数据。\n\n### 3.2.2 记忆策略：`MessageWindowChatMemory`\n\n`MessageWindowChatMemory`是Spring AI中最常用、也是默认的记忆策略。它实现了一种高效的`“滑动窗口”`机制。\n\n它的工作原理非常直观：我们预设一个窗口大小（即最大消息数 `maxMessages`）。当`ChatMemory`需要为新的API请求提供上下文时，它会从`ChatMemoryRepository`中取出该会話的所有历史消息，然后截取**最新的N条**（N即`maxMessages`）作为上下文。\n举个例子，如果`maxMessages`设为4，那么用户与AI之间的一轮对话则算两条，若超出了这两轮对话,AI的记忆就会被回溯至最后一条..\n\n这种策略是在成本、性能和上下文相关性之间取得最佳平衡的实用方案，能有效防止超出模型Token限制和控制API费用。\n\n### 3.2.3 记忆存储：`ChatMemoryRepository` 的多种实现\n\n`ChatMemoryRepository`负责将对话消息进行物理存储。Spring AI提供了多种开箱即用的实现：\n\n| 实现类 | 存储介质 | 优点 | 缺点 | 适用场景 |\n| :--- | :--- | :--- | :--- | :--- |\n| `InMemory...Repository` | JVM 内存 | 零配置, 极速 | 数据易失 | 开发, 测试, 原型 |\n| `Jdbc...Repository` | 关系型数据库 | 可靠, 持久化 | 需配置 | **生产环境** |\n\n#### `JdbcChatMemoryRepository` 深度配置\n\n要在生产环境中使用数据库进行持久化，我们需要进行以下配置：\n\n1.  **引入依赖 (`pom.xml`)**:\n\n    ```xml\n    <dependency>\n        <groupId>org.springframework.ai</groupId>\n        <artifactId>spring-ai-jdbc-store-spring-boot-starter</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>com.mysql</groupId>\n        <artifactId>mysql-connector-j</artifactId>\n        <scope>runtime</scope>\n    </dependency>\n    ```\n\n2.  **数据库表结构 (DDL for MySQL)**:\n    这是`JdbcChatMemoryRepository`期望的表结构。理解每个字段的含义至关重要。\n\n    ```sql\n    CREATE TABLE `spring_ai_chat_memory` (\n      `id` bigint NOT NULL AUTO_INCREMENT,\n      -- 会话的唯一标识符，所有属于同一次对话的消息共享此ID。这是实现多会话隔离的关键。\n      `conversation_id` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,\n      -- 消息的具体文本内容。\n      `content` text COLLATE utf8mb4_unicode_ci NOT NULL,\n      -- 消息的角色类型，通常是 \'USER\' 或 \'ASSISTANT\'。\n      `type` varchar(50) COLLATE utf8mb4_unicode_ci NOT NULL,\n      -- 消息创建的时间戳，用于排序。\n      `timestamp` timestamp NULL DEFAULT CURRENT_TIMESTAMP,\n      -- 为未来的多模态消息预留的字段 (JSON格式)。\n      `media` json DEFAULT NULL,\n      -- 存储额外元数据的字段 (JSON格式)，如token使用量等。\n      `metadata` json DEFAULT NULL,\n      PRIMARY KEY (`id`),\n      -- 关键索引：为会话ID创建索引，极大地提升按会话查询历史记录的性能。\n      KEY `idx_conversation_id` (`conversation_id`)\n    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n    ```\n\n> **避坑指南：数据库Schema管理**\n>\n> Spring AI提供了`spring.ai.chat.memory.repository.jdbc.initialize-schema`属性，可以自动创建上述表结构。这在开发时非常方便，但在生产环境中是**危险**的。生产环境的数据库表结构变更必须是受控的、可追溯的。\n>\n> **最佳实践**：\n>\n>   * 在`application.yml`中设置`spring.ai.chat.memory.repository.jdbc.initialize-schema: never`。\n>   * 使用专业的数据库迁移工具如 **Flyway** 或 **Liquibase** 来管理你的数据库Schema。将上述DDL语句放入一个版本化的SQL迁移文件中，由迁移工具在应用启动时安全地执行。这能确保所有环境（开发、测试、生产）的数据库结构一致，并能安全地回滚。\n\n```yaml\n# src/main/resources/application.yml\nspring:\n  ai:\n    openai:\n      # DeepSeek API 配置 - 使用 OpenAI 兼容协议\n      # 注意！这里不能加v1后缀，在2025年的DeepSeek更新中明确指定了不需要v1后缀\n      # 很多AI还是会错以为需要v1后缀\n      base-url: https://api.deepseek.com\n      api-key: "sk-xxxx"\n      chat:\n        options:\n          model: deepseek-chat\n          temperature: 0.7\n    chat:\n      memory:\n        repository:\n          jdbc:\n            # 控制何时初始化数据库表结构\n            initialize-schema: never\n            # 手动指定数据库平台（如 mysql, postgresql）\n            platform: mysql\n```\n\n\n\n### 3.2.4 注入记忆：`MessageChatMemoryAdvisor`\n\n有了策略和存储，我们需要一个“胶水”将它们粘合起来，并自动应用到`ChatClient`的调用流程中。这个胶水就是`MessageChatMemoryAdvisor`。\n\n下面是一个完整的、生产级的持久化记忆配置示例，展示了所有组件如何通过Spring的依赖注入（DI）优雅地协同工作。\n\n```java\n// 文件路径: src/main/java/com/example/hellospringai/config/CommonConfiguration.java\npackage com.example.hellospringai.config;\n\nimport org.springframework.ai.chat.client.ChatClient;\nimport org.springframework.ai.chat.client.advisor.MessageChatMemoryAdvisor;\nimport org.springframework.ai.chat.memory.ChatMemory;\nimport org.springframework.ai.chat.memory.MessageWindowChatMemory;\nimport org.springframework.ai.chat.memory.repository.ChatMemoryRepository;\nimport org.springframework.ai.chat.model.ChatModel;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class CommonConfiguration {\n\n    /**\n     * 定义记忆策略Bean。\n     * 这是一个核心的业务逻辑配置，它声明了我们的记忆行为。\n     * @param chatMemoryRepository Spring Boot 会根据依赖和配置自动注入一个ChatMemoryRepository的实现\n     * (例如，当我们引入了spring-ai-jdbc-store-spring-boot-starter时，它就是一个JdbcChatMemoryRepository实例)。\n     * 这种“面向接口编程”的方式让我们的代码更具灵活性。\n     * @return ChatMemory 实例，代表了“使用特定存储的、50条消息的滑动窗口”这一记忆策略。\n     */\n    @Bean\n    public ChatMemory chatMemory(ChatMemoryRepository chatMemoryRepository) {\n        return MessageWindowChatMemory.builder()\n                .withChatMemoryRepository(chatMemoryRepository) // 指定记忆的“仓库”\n                .withMaxMessages(50) // 指定记忆的“策略”\n                .build();\n    }\n\n    /**\n     * 定义最终的 ChatClient Bean。\n     * @param chatModel 自动配置的ChatModel实例。\n     * @param chatMemory 我们上面定义的ChatMemory策略Bean。\n     * @return 一个配置了持久化记忆功能的ChatClient实例。\n     */\n    @Bean\n    public ChatClient chatClient(ChatModel chatModel, ChatMemory chatMemory) {\n        return ChatClient.builder(chatModel)\n                .defaultAdvisors(\n                        // 关键: MessageChatMemoryAdvisor在接收到chatMemory策略后，\n                        // 会在每次请求前，使用传入的conversationId调用chatMemory.get()来加载历史消息，\n                        // 并在每次响应后，调用chatMemory.add()来保存新的请求和响应消息。\n                        new MessageChatMemoryAdvisor(chatMemory)\n                )\n                .build();\n    }\n}\n```\n\n### 3.2.5 传递会话 ID (Conversation ID)\n\n要让记忆机制生效，最后一步也是至关重要的一步：在调用 `ChatClient` 时，我们必须告诉它当前这次对话属于哪个“会话 (Conversation)”，以便它能从数据库中加载正确的历史记录，并将新的对话存入正确的“档案”。这是通过在每次调用时传递一个**会话ID (`conversationId`)** 来实现的。\n\n  * **Service 层改造**:\n    Service层需要能接收`conversationId`，并将其通过`.advisors()`方法传递给`ChatClient`的调用链。\n\n    ```java\n    package com.example.hellospringai.service;\n\n    import org.springframework.ai.chat.client.ChatClient;\n    import org.springframework.ai.chat.memory.ChatMemory; // 引入 ChatMemory\n    import org.springframework.stereotype.Service;\n    import reactor.core.publisher.Flux;\n\n    @Service\n    public class ChatService {\n        private final ChatClient chatClient;\n\n        public ChatService(ChatClient chatClient) {\n            this.chatClient = chatClient;\n        }\n\n        /**\n         * 【方法】带聊天记忆的流式对话\n         * @param message 用户输入消息\n         * @param conversationId 会话ID，用于维护和隔离不同对话的聊天记忆\n         * @return AI回复的文本内容流\n         */\n        public Flux<String> getChatStreamWithMemory(String message, String conversationId) {\n            return chatClient.prompt()\n                    .user(message) // 用户输入消息\n                    // 关键：通过 .advisors() 方法的 Consumer，将会话ID作为参数传递给记忆顾问。\n                    // 顾问在执行时会从上下文中查找这个Key，从而知道该为哪个会话加载/保存记忆。\n                    // ChatMemory.CONVERSATION_ID 是官方提供的标准Key，强烈推荐使用以保持兼容性。\n                    .advisors(a -> a.param(ChatMemory.CONVERSATION_ID, conversationId))\n                    .stream()\n                    .content();\n        }\n    }\n    ```\n\n  * **Controller 层改造**:\n    相应地，`ChatController`的接口也需要增加一个`chatId`参数，以从前端或API客户端的请求中接收这个ID。\n\n    ```java\n    package com.example.hellospringai.controller;\n\n    import com.example.hellospringai.service.ChatService;\n    import org.springframework.web.bind.annotation.*;\n    import reactor.core.publisher.Flux;\n\n    @RestController\n    @RequestMapping("/ai")\n    public class ChatController {\n        private final ChatService chatService;\n\n        public ChatController(ChatService chatService) {\n            this.chatService = chatService;\n        }\n\n        @GetMapping(value = "/chat", produces = "text/event-stream;charset=utf-8")\n        public Flux<String> streamChat(@RequestParam(value = "message") String message,\n                                         // 关键: 从请求参数中接收会话ID\n                                         @RequestParam(value = "chatId") String chatId) {\n            return chatService.getChatStreamWithMemory(message, chatId);\n        }\n    }\n    ```\n\n至此，我们的后端就拥有了完整的、可持久化的多会话记忆能力。每一个唯一的`chatId`都会在`spring_ai_chat_memory`表中拥有自己独立的、可追溯的聊天记录，而`ChatClient`也能够基于这些记录，实现真正智能、连贯的多轮对话。\n\n\n\n\n\n-----\n\n## 3.3 会话历史管理 —— 从数据库到业务服务的完整链路\n\n上一章，我们成功地利用`ChatMemory`和`JdbcChatMemoryRepository`让AI拥有了可持久化的记忆。每一次对话，相关的`Message`都会被自动存入`spring_ai_chat_memory`数据库表中。这解决了AI的上下文问题，但同时也为我们留下了一笔宝贵的数据资产——完整的用户对话记录。\n\n现在，我们的角色将从“AI框架的使用者”转变为“应用功能的开发者”。本章的核心任务是，直接操作这张由Spring AI维护的表，使用业界流行的ORM框架**MyBatis-Plus**，为其构建一套完整的、面向业务的`Service`和`Controller`。最终目标是实现一个功能完备的后端服务，能够让前端应用查询会话列表、加载指定会话的完整历史、以及删除会话，从而完成一个真正生产级AI应用的核心闭环。\n\n### 3.3.1 后端服务搭建：基于 MyBatis-Plus 的高效实践\n\n我们将按照标准的Spring Boot三层架构（Controller, Service, Mapper/DAO）来搭建我们的历史管理服务。\n\n#### 步骤一：环境准备\n\n首先，我们需要在项目中集成MyBatis-Plus。\n\n1.  **在 `pom.xml` 中添加 MyBatis-Plus 依赖**:\n\n    ```xml\n    <dependency>\n        <groupId>com.baomidou</groupId>\n        <artifactId>mybatis-plus-spring-boot3-starter</artifactId>\n        <version>3.5.7</version> </dependency>\n    ```\n\n2.  **在主启动类上添加 `@MapperScan` 注解**:\n    这个注解会告诉MyBatis-Plus框架去哪里扫描我们的Mapper接口。\n\n    ```java\n    package com.example.hellospringai;\n\n    import org.mybatis.spring.annotation.MapperScan;\n    import org.springframework.boot.SpringApplication;\n    import org.springframework.boot.autoconfigure.SpringBootApplication;\n\n    // 扫描Mapper接口所在的包\n    @MapperScan("com.example.hellospringai.mapper")\n    @SpringBootApplication\n    public class HelloSpringAiApplication {\n        public static void main(String[] args) {\n            SpringApplication.run(HelloSpringAiApplication.class, args);\n        }\n    }\n    ```\n\n3.  **在 `application.yml` 中添加 MyBatis-Plus 配置**:\n    虽然MyBatis-Plus有很多配置项，但对于基础使用，配置驼峰命名转换和SQL日志打印就足够了。\n\n    ```yaml\n    # mybatis-plus相关配置\n    mybatis-plus:\n      configuration:\n        # 开启驼峰命名自动转换, 如数据库的 conversation_id 会自动映射到Java实体的 conversationId\n        map-underscore-to-camel-case: true\n        # 将执行的SQL打印到控制台，方便开发调试\n        log-impl: org.apache.ibatis.logging.stdout.StdOutImpl\n    ```\n\n#### 步骤二：数据访问层 (DAO)\n\n数据访问层负责与数据库直接交互。它包含实体类（Entity）和Mapper接口。\n\n  * **实体类 `ChatMemoryEntity.java`**:\n    我们创建一个专门用于MyBatis-Plus操作的实体类，它精确地映射到`spring_ai_chat_memory`数据库表。使用独立的实体类是一种良好的实践，可以避免与框架内部模型产生耦合。\n\n    ```java\n    package com.example.hellospringai.entity;\n\n    import com.baomidou.mybatisplus.annotation.*;\n    import lombok.Data;\n    import java.time.LocalDateTime;\n\n    @Data\n    // 使用 @TableName 注解精确指定数据库表名，避免因命名策略不同导致的问题\n    @TableName("spring_ai_chat_memory")\n    public class ChatMemoryEntity {\n        // @TableId 指定主键字段和其生成策略\n        @TableId(value = "id", type = IdType.AUTO)\n        private Long id;\n\n        // @TableField 将Java属性与数据库列名进行映射\n        @TableField("conversation_id")\n        private String conversationId;\n\n        @TableField("content")\n        private String content;\n\n        @TableField("type")\n        private String type; // USER 或 ASSISTANT\n\n        @TableField("timestamp")\n        private LocalDateTime timestamp;\n    }\n    ```\n\n  * **Mapper 接口 `ChatMemoryMapper.java`**:\n    Mapper接口是MyBatis-Plus的核心，通过继承`BaseMapper`，我们无需编写任何XML或SQL语句，即可免费获得一套极其强大的单表CRUD（增删改查）能力。\n\n    ```java\n    package com.example.hellospringai.mapper;\n\n    import com.baomidou.mybatisplus.core.mapper.BaseMapper;\n    import com.example.hellospringai.entity.ChatMemoryEntity;\n    import org.apache.ibatis.annotations.Mapper;\n\n    @Mapper\n    public interface ChatMemoryMapper extends BaseMapper<ChatMemoryEntity> {\n        // 继承 BaseMapper<ChatMemoryEntity> 后，我们已经拥有了如\n        // insert, deleteById, delete(wrapper), updateById, selectById, selectList(wrapper) 等所有基础数据库操作。\n        // 对于更复杂的查询，我们将使用 QueryWrapper，以获得更好的类型安全和灵活性。\n    }\n    ```\n\n#### 步骤三：业务逻辑层 (Service)\n\nService层负责封装核心的业务逻辑，它调用Mapper层来完成数据操作。\n\n  * **服务接口 `IChatHistoryService.java`**:\n    定义我们对外提供的所有历史记录管理功能。\n\n    ```java\n    package com.example.hellospringai.service;\n\n    import com.baomidou.mybatisplus.extension.service.IService;\n    import com.example.hellospringai.entity.ChatMemoryEntity;\n    import java.util.List;\n    import java.util.Map;\n\n    public interface IChatHistoryService extends IService<ChatMemoryEntity> {\n\n        /**\n         * 获取所有会话的聚合列表，用于前端会话列表展示。\n         * 返回的不是原始消息，而是每个会话的概要信息。\n         * @return 一个Map列表，每个Map代表一个会话，包含id, label, updatedAt等信息。\n         */\n        List<Map<String, Object>> getAllConversations();\n\n        /**\n         * 根据会话ID获取该会话的完整聊天记录。\n         * @param conversationId 会话ID\n         * @return 该会话的所有消息实体列表，按时间升序排列。\n         */\n        List<ChatMemoryEntity> getChatHistory(String conversationId);\n\n        /**\n         * 根据会话ID删除该会话的所有聊天记录。\n         * @param conversationId 会话ID\n         * @return 操作是否成功\n         */\n        boolean deleteChatHistory(String conversationId);\n    }\n    ```\n\n  * **服务实现 `ChatHistoryServiceImpl.java`**:\n    这是所有业务逻辑的具体实现地。`getAllConversations`方法的逻辑相对复杂，因为它需要对数据进行聚合处理。\n\n    ```java\n    package com.example.hellospringai.service.impl;\n\n    import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;\n    import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;\n    import com.example.hellospringai.entity.ChatMemoryEntity;\n    import com.example.hellospringai.mapper.ChatMemoryMapper;\n    import com.example.hellospringai.service.IChatHistoryService;\n    import org.springframework.stereotype.Service;\n    import java.time.LocalDateTime;\n    import java.util.HashMap;\n    import java.util.List;\n    import java.util.Map;\n    import java.util.stream.Collectors;\n\n    @Service\n    public class ChatHistoryServiceImpl extends ServiceImpl<ChatMemoryMapper, ChatMemoryEntity> implements IChatHistoryService {\n\n        @Override\n        public List<Map<String, Object>> getAllConversations() {\n            // 1. 先查询出所有记录的 conversation_id 和 timestamp，按时间倒序排列，确保后续处理时能拿到最新的会话。\n            QueryWrapper<ChatMemoryEntity> idQueryWrapper = new QueryWrapper<>();\n            idQueryWrapper.select("conversation_id", "timestamp").orderByDesc("timestamp");\n            List<ChatMemoryEntity> allRecords = this.list(idQueryWrapper);\n\n            // 2. 使用 Java Stream 的 distinct() 方法，对所有 conversation_id 进行去重，得到所有唯一的会话ID列表。\n            // 由于上一步是倒序的，这个列表的顺序会优先保留最新交互的会话。\n            List<String> distinctConvIds = allRecords.stream()\n                    .map(ChatMemoryEntity::getConversationId)\n                    .distinct()\n                    .collect(Collectors.toList());\n\n            // 3. 遍历每一个唯一的会话ID，为它们分别构建前端需要的概要信息。\n            return distinctConvIds.stream().map(id -> {\n                Map<String, Object> conversationInfo = new HashMap<>();\n                conversationInfo.put("id", id);\n\n                // 3.1 获取该会话的第一条用户消息，我们约定用它作为会话的默认标题。\n                ChatMemoryEntity firstUserMessage = this.query()\n                        .eq("conversation_id", id).eq("type", "USER")\n                        .orderByAsc("timestamp").last("LIMIT 1").one();\n                String title = (firstUserMessage != null && firstUserMessage.getContent() != null)\n                        ? firstUserMessage.getContent().trim() : "新的会话";\n                // 对过长的标题进行截断，以优化前端显示\n                conversationInfo.put("label", title.length() > 20 ? title.substring(0, 20) + "..." : title);\n\n                // 3.2 获取该会话的最后一条消息的时间戳，作为会话的“最后更新时间”，用于前端排序。\n                ChatMemoryEntity lastMessage = this.query()\n                        .eq("conversation_id", id).orderByDesc("timestamp")\n                        .last("LIMIT 1").one();\n                conversationInfo.put("updatedAt", lastMessage != null ? lastMessage.getTimestamp() : LocalDateTime.now());\n\n                return conversationInfo;\n            }).collect(Collectors.toList());\n        }\n\n        @Override\n        public List<ChatMemoryEntity> getChatHistory(String conversationId) {\n            // 构建查询条件：查询指定 conversation_id 的所有记录，并按时间升序排列。\n            QueryWrapper<ChatMemoryEntity> queryWrapper = new QueryWrapper<>();\n            queryWrapper.eq("conversation_id", conversationId).orderByAsc("timestamp");\n            return this.list(queryWrapper);\n        }\n\n        @Override\n        public boolean deleteChatHistory(String conversationId) {\n            // 构建删除条件：删除所有匹配指定 conversation_id 的记录。\n            QueryWrapper<ChatMemoryEntity> queryWrapper = new QueryWrapper<>();\n            queryWrapper.eq("conversation_id", conversationId);\n            return this.remove(queryWrapper);\n        }\n    }\n    ```\n\n#### 步骤四：API 接口层 (Controller)\n\n最后，创建一个全新的 Controller，将我们的 Service 方法暴露为 RESTful API，供（未来的）前端或其他服务调用。\n\n  * **`ChatHistoryController.java`**:\n\n    ```java\n    package com.example.hellospringai.controller;\n\n    import com.example.hellospringai.entity.ChatMemoryEntity;\n    import com.example.hellospringai.service.IChatHistoryService;\n    import org.springframework.web.bind.annotation.*;\n    import java.util.List;\n    import java.util.Map;\n\n    // @RestController 是 @Controller 和 @ResponseBody 的组合，表示该类的所有方法都直接返回JSON或XML数据。\n    @RestController\n    // 为历史记录管理API设置统一的、有意义的URL前缀，符合RESTful设计风格。\n    @RequestMapping("/api/chat-history")\n    public class ChatHistoryController {\n\n        private final IChatHistoryService chatHistoryService;\n\n        public ChatHistoryController(IChatHistoryService chatHistoryService) {\n            this.chatHistoryService = chatHistoryService;\n        }\n\n        /**\n         * 获取所有会话的聚合列表。\n         * @return 会话列表，每个会话包含id, label, updatedAt等信息。\n         */\n        @GetMapping("/conversations")\n        public List<Map<String, Object>> getAllConversations() {\n            return chatHistoryService.getAllConversations();\n        }\n\n        /**\n         * 获取指定会话的完整聊天记录。\n         * @param conversationId 通过URL路径变量传入的会话ID。\n         * @return 该会话的所有消息实体列表。\n         */\n        @GetMapping("/conversation/{conversationId}")\n        public List<ChatMemoryEntity> getChatHistory(@PathVariable String conversationId) {\n            return chatHistoryService.getChatHistory(conversationId);\n        }\n\n        /**\n         * 删除指定会话的所有聊天记录。\n         * @param conversationId 通过URL路径变量传入的会话ID。\n         * @return 一个包含操作结果的Map，便于客户端判断操作是否成功并获取提示信息。\n         */\n        @DeleteMapping("/conversation/{conversationId}")\n        public Map<String, Object> deleteChatHistory(@PathVariable String conversationId) {\n            boolean success = chatHistoryService.deleteChatHistory(conversationId);\n            return Map.of(\n                "success", success,\n                "message", success ? "删除成功" : "删除失败或会话不存在"\n            );\n        }\n    }\n    ```\n\n\n\n-----\n\n## 3.4 后端服务接口文档\n\n以下是为“会话历史管理”功能提供的后端RESTful API接口文档。\n\n**基础URL (Base URL)**: `http://localhost:8080`\n\n-----\n\n### 1\\. 获取所有会话列表\n\n获取所有已存在的会话的概要信息列表，按最后更新时间倒序排列。\n\n  * **请求**\n\n    `GET /api/chat-history/conversations`\n\n  * **请求参数**\n\n    无\n\n  * **成功响应 (`200 OK`)**\n\n    ```json\n    [\n      {\n        "id": "conv_1718985665_a1b2c3d4",\n        "label": "你好，介绍一下你自己",\n        "updatedAt": "2025-06-22T01:21:05.123456"\n      },\n      {\n        "id": "conv_1718985601_e5f6g7h8",\n        "label": "请用Java写一个快排...",\n        "updatedAt": "2025-06-22T01:20:01.789012"\n      }\n    ]\n    ```\n\n  * **响应字段说明**\n\n| 字段 | 类型 | 描述 |\n| :--- | :--- | :--- |\n| `id` | `String` | 会话的唯一标识符。 |\n| `label` | `String` | 根据会话第一条用户消息生成的默认标题（最长20个字符）。 |\n| `updatedAt` | `String` | 会话的最后更新时间（ISO 8601格式）。 |\n\n-----\n\n### 2\\. 获取指定会话详情\n\n根据提供的`conversationId`，获取该会话的完整聊天记录，按消息时间升序排列。\n\n  * **请求**\n\n    `GET /api/chat-history/conversation/{conversationId}`\n\n  * **请求参数**\n\n    **路径参数 (Path Parameters):**\n\n| 参数 | 类型 | 状态 | 描述 |\n| :--- | :--- | :--- | :--- |\n| `conversationId` | `String` | **必需** | 要查询的会话ID。 |\n\n  * **成功响应 (`200 OK`)**\n\n    ```json\n    [\n      {\n        "id": 101,\n        "conversationId": "conv_1718985665_a1b2c3d4",\n        "content": "你好，介绍一下你自己",\n        "type": "USER",\n        "timestamp": "2025-06-22T01:21:00.123456"\n      },\n      {\n        "id": 102,\n        "conversationId": "conv_1718985665_a1b2c3d4",\n        "content": "你好！我是一个由Spring AI驱动的大语言模型...",\n        "type": "ASSISTANT",\n        "timestamp": "2025-06-22T01:21:05.123456"\n      }\n    ]\n    ```\n\n  * **响应字段说明**\n\n| 字段 | 类型 | 描述 |\n| :--- | :--- | :--- |\n| `id` | `Long` | 消息的数据库主键ID。 |\n| `conversationId` | `String` | 所属会话的ID。 |\n| `content` | `String` | 消息的文本内容。 |\n| `type` | `String` | 消息角色，值为 `USER` 或 `ASSISTANT`。 |\n| `timestamp` | `String` | 消息的创建时间戳（ISO 8601格式）。 |\n\n-----\n\n### 3\\. 删除指定会话\n\n根据提供的`conversationId`，删除该会话的所有相关聊天记录。这是一个**破坏性**操作。\n\n  * **请求**\n\n    `DELETE /api/chat-history/conversation/{conversationId}`\n\n  * **请求参数**\n\n    **路径参数 (Path Parameters):**\n\n| 参数 | 类型 | 状态 | 描述 |\n| :--- | :--- | :--- | :--- |\n| `conversationId` | `String` | **必需** | 要删除的会话ID。 |\n\n  * **成功响应 (`200 OK`)**\n\n    ```json\n    {\n      "success": true,\n      "message": "删除成功"\n    }\n    ```\n\n  * **响应字段说明**\n\n| 字段 | 类型 | 描述 |\n| :--- | :--- | :--- |\n| `success` | `Boolean` | 操作是否成功。`true`表示成功，`false`表示失败。 |\n| `message` | `String` | 操作结果的文本描述信息。 |'}</script></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/06/16/684f747174bc3.webp" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/user/status.png" alt="status"></div></div><div class="author-info__description"><div style="line-height:1.4;color:rgba(255,255,255,.9);text-align:center">🚀 全栈开发者，专注于构建优雅高效的数字解决方案<br><span style="color:#fff;font-weight:700">前端 · 后端 · 架构 · 优化</span><br>📚 分享实战经验，一起探索技术边界</div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">Prorise</h1><div class="author-info__desc">这聒噪的世界让沉默的人显得另类</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/361040115?spm_id_from=333.1387.0.0" rel="external nofollow noreferrer" target="_blank" title="BiliBili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a></div></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background:url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center/100% no-repeat"></div><div class="back face" style="background:url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center/100% no-repeat"></div></div></div></div><div class="card-widget card-latest-comments"><div class="item-headline"><i class="fas fa-comments"></i><span>最新评论</span></div><div class="item-content"><a href="/messages/" class="headline-right" title="查看更多"><i class="fas fa-angle-right"></i></a><div class="aside-list" id="latest-comments"></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E8%B0%83%E8%AF%95%E4%B8%8E%E6%B4%9E%E5%AF%9F-%E2%80%94%E2%80%94-%E8%A7%A3%E5%AF%86-ChatClient-%E7%9A%84%E9%80%9A%E4%BF%A1%E2%80%9C%E9%BB%91%E7%9B%92%E2%80%9D"><span class="toc-number">1.</span> <span class="toc-text">3.1 调试与洞察 —— 解密 ChatClient 的通信“黑盒”</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-%E6%A0%B8%E5%BF%83%E5%88%A9%E5%99%A8-Advisor-%E4%B8%8E-SimpleLoggerAdvisor"><span class="toc-number">1.1.</span> <span class="toc-text">3.1.1 核心利器: Advisor 与 SimpleLoggerAdvisor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2-%E5%AE%9E%E6%88%98%E9%85%8D%E7%BD%AE"><span class="toc-number">1.2.</span> <span class="toc-text">3.1.2 实战配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4%E4%B8%80%EF%BC%9A%E9%85%8D%E7%BD%AE%E6%97%A5%E5%BF%97%E7%BA%A7%E5%88%AB"><span class="toc-number">1.2.1.</span> <span class="toc-text">步骤一：配置日志级别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4%E4%BA%8C%EF%BC%9A%E5%9C%A8-ChatClient-Bean-%E4%B8%AD%E5%BA%94%E7%94%A8%E9%A1%BE%E9%97%AE"><span class="toc-number">1.2.2.</span> <span class="toc-text">步骤二：在 ChatClient Bean 中应用顾问</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-3-%E8%A7%A3%E8%AF%BB%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA"><span class="toc-number">1.3.</span> <span class="toc-text">3.1.3 解读日志输出</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E5%AF%B9%E8%AF%9D%E8%AE%B0%E5%BF%86-Chat-Memory-%E2%80%94%E2%80%94-%E8%B5%8B%E4%BA%88-AI-%E4%B8%8A%E4%B8%8B%E6%96%87%E6%84%9F%E7%9F%A5%E8%83%BD%E5%8A%9B"><span class="toc-number">2.</span> <span class="toc-text">3.2 对话记忆 (Chat Memory) —— 赋予 AI 上下文感知能力</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-%E6%A0%B8%E5%BF%83%E8%AE%BE%E8%AE%A1%EF%BC%9A%E7%AD%96%E7%95%A5%E4%B8%8E%E5%AD%98%E5%82%A8%E5%88%86%E7%A6%BB"><span class="toc-number">2.1.</span> <span class="toc-text">3.2.1 核心设计：策略与存储分离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-%E8%AE%B0%E5%BF%86%E7%AD%96%E7%95%A5%EF%BC%9AMessageWindowChatMemory"><span class="toc-number">2.2.</span> <span class="toc-text">3.2.2 记忆策略：MessageWindowChatMemory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-3-%E8%AE%B0%E5%BF%86%E5%AD%98%E5%82%A8%EF%BC%9AChatMemoryRepository-%E7%9A%84%E5%A4%9A%E7%A7%8D%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.3.</span> <span class="toc-text">3.2.3 记忆存储：ChatMemoryRepository 的多种实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JdbcChatMemoryRepository-%E6%B7%B1%E5%BA%A6%E9%85%8D%E7%BD%AE"><span class="toc-number">2.3.1.</span> <span class="toc-text">JdbcChatMemoryRepository 深度配置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-4-%E6%B3%A8%E5%85%A5%E8%AE%B0%E5%BF%86%EF%BC%9AMessageChatMemoryAdvisor"><span class="toc-number">2.4.</span> <span class="toc-text">3.2.4 注入记忆：MessageChatMemoryAdvisor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-5-%E4%BC%A0%E9%80%92%E4%BC%9A%E8%AF%9D-ID-Conversation-ID"><span class="toc-number">2.5.</span> <span class="toc-text">3.2.5 传递会话 ID (Conversation ID)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E4%BC%9A%E8%AF%9D%E5%8E%86%E5%8F%B2%E7%AE%A1%E7%90%86-%E2%80%94%E2%80%94-%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%B0%E4%B8%9A%E5%8A%A1%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%AE%8C%E6%95%B4%E9%93%BE%E8%B7%AF"><span class="toc-number">3.</span> <span class="toc-text">3.3 会话历史管理 —— 从数据库到业务服务的完整链路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1-%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA%EF%BC%9A%E5%9F%BA%E4%BA%8E-MyBatis-Plus-%E7%9A%84%E9%AB%98%E6%95%88%E5%AE%9E%E8%B7%B5"><span class="toc-number">3.1.</span> <span class="toc-text">3.3.1 后端服务搭建：基于 MyBatis-Plus 的高效实践</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4%E4%B8%80%EF%BC%9A%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87"><span class="toc-number">3.1.1.</span> <span class="toc-text">步骤一：环境准备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4%E4%BA%8C%EF%BC%9A%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E5%B1%82-DAO"><span class="toc-number">3.1.2.</span> <span class="toc-text">步骤二：数据访问层 (DAO)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4%E4%B8%89%EF%BC%9A%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E5%B1%82-Service"><span class="toc-number">3.1.3.</span> <span class="toc-text">步骤三：业务逻辑层 (Service)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4%E5%9B%9B%EF%BC%9AAPI-%E6%8E%A5%E5%8F%A3%E5%B1%82-Controller"><span class="toc-number">3.1.4.</span> <span class="toc-text">步骤四：API 接口层 (Controller)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3"><span class="toc-number">4.</span> <span class="toc-text">3.4 后端服务接口文档</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%8E%B7%E5%8F%96%E6%89%80%E6%9C%89%E4%BC%9A%E8%AF%9D%E5%88%97%E8%A1%A8"><span class="toc-number">4.1.</span> <span class="toc-text">1. 获取所有会话列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%8E%B7%E5%8F%96%E6%8C%87%E5%AE%9A%E4%BC%9A%E8%AF%9D%E8%AF%A6%E6%83%85"><span class="toc-number">4.2.</span> <span class="toc-text">2. 获取指定会话详情</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9A%E4%BC%9A%E8%AF%9D"><span class="toc-number">4.3.</span> <span class="toc-text">3. 删除指定会话</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/56706.html" title="附录"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/06/19/68535b23089d0.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="附录"></a><div class="content"><a class="title" href="/posts/56706.html" title="附录">附录</a><time datetime="2025-06-15T22:13:45.000Z" title="发表于 2025-06-16 06:13:45">2025-06-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/27374.html" title="14. 社区、生态与未来展望"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/06/19/68535b23089d0.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="14. 社区、生态与未来展望"></a><div class="content"><a class="title" href="/posts/27374.html" title="14. 社区、生态与未来展望">14. 社区、生态与未来展望</a><time datetime="2025-06-15T21:13:45.000Z" title="发表于 2025-06-16 05:13:45">2025-06-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/36675.html" title="13. 实战项目：构建一个完整的 AI 知识库应用"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/06/19/68535b23089d0.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="13. 实战项目：构建一个完整的 AI 知识库应用"></a><div class="content"><a class="title" href="/posts/36675.html" title="13. 实战项目：构建一个完整的 AI 知识库应用">13. 实战项目：构建一个完整的 AI 知识库应用</a><time datetime="2025-06-15T20:13:45.000Z" title="发表于 2025-06-16 04:13:45">2025-06-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/17745.html" title="12. 生产环境考量与部署"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/06/19/68535b23089d0.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="12. 生产环境考量与部署"></a><div class="content"><a class="title" href="/posts/17745.html" title="12. 生产环境考量与部署">12. 生产环境考量与部署</a><time datetime="2025-06-15T19:13:45.000Z" title="发表于 2025-06-16 03:13:45">2025-06-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/24414.html" title="11. ETL 框架：文档处理与数据摄取"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/06/19/68535b23089d0.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="11. ETL 框架：文档处理与数据摄取"></a><div class="content"><a class="title" href="/posts/24414.html" title="11. ETL 框架：文档处理与数据摄取">11. ETL 框架：文档处理与数据摄取</a><time datetime="2025-06-15T18:13:45.000Z" title="发表于 2025-06-16 02:13:45">2025-06-16</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="footer_deal"><a class="deal_link" href="mailto:3381292732@qq.com" rel="external nofollow noreferrer" title="email"><i class="anzhiyufont anzhiyu-icon-envelope"></i></a><a class="deal_link" target="_blank" rel="noopener external nofollow noreferrer" href="https://weibo.com/u/7484736298?tabtype=home" title="微博"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a><a class="deal_link" href="/atom.xml" title="RSS"><i class="anzhiyufont anzhiyu-icon-rss"></i></a><img class="footer_mini_logo" title="返回顶部" alt="返回顶部" onclick="anzhiyu.scrollToDest(0,500)" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/06/16/684f745b722d7.webp" size="50px"><a class="deal_link" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/Prorise-cool" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="deal_link" target="_blank" rel="noopener external nofollow noreferrer" href="https://space.bilibili.com/361040115?spm_id_from=333.788.0.0" title="Bilibili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a><a class="deal_link" href="/copyright" title="CC"><i class="anzhiyufont anzhiyu-icon-copyright-line"></i></a></div><div id="workboard"><div id="runtimeTextTip"></div></div><div class="footer_custom_text">这是我的个人博客，分享技术与生活点滴。</div><div id="anzhiyu-footer"><div class="footer-group"><div class="footer-title">服务</div><div class="footer-links"><a class="footer-item" title="51la统计" target="_blank" rel="noopener external nofollow noreferrer" href="https://v6.51.la/">51la统计</a><a class="footer-item" title="十年之约" target="_blank" rel="noopener external nofollow noreferrer" href="https://www.foreverblog.cn/">十年之约</a></div></div><div class="footer-group"><div class="footer-title">主题</div><div class="footer-links"><a class="footer-item" title="文档" href="/docs/">文档</a><a class="footer-item" title="源码" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu">源码</a></div></div><div class="footer-group"><div class="footer-title">导航</div><div class="footer-links"><a class="footer-item" title="即刻短文" href="/essay/">即刻短文</a><a class="footer-item" title="留言板" href="/comments/">留言板</a></div></div><div class="footer-group"><div class="footer-title">协议</div><div class="footer-links"><a class="footer-item" title="隐私协议" href="/privacy/">隐私协议</a><a class="footer-item" title="版权协议" href="/copyright/">版权协议</a></div></div><div class="footer-group"><div class="footer-title-group"><div class="footer-title">友链</div><a class="random-friends-btn" id="footer-random-friends-btn" href="javascript:addFriendLinksInFooter();" rel="external nofollow noreferrer" title="换一批友情链接"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right"></i></a></div><div class="footer-links" id="friend-links-in-footer"></div></div></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" rel="external nofollow noreferrer" style="margin-inline:5px" data-title="博客框架为Hexo7.0" title="博客框架为Hexo7.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Frame-Hexo.svg" alt="博客框架为Hexo7.0"></a><a class="github-badge" target="_blank" href="https://www.dogecloud.com/" rel="external nofollow noreferrer" style="margin-inline:5px" data-title="本站使用多吉云为静态资源提供CDN加速" title="本站使用多吉云为静态资源提供CDN加速"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.2.0/img/badge/CDN-多吉云-3693F3.svg" alt="本站使用多吉云为静态资源提供CDN加速"></a><a class="github-badge" target="_blank" href="https://github.com/" rel="external nofollow noreferrer" style="margin-inline:5px" data-title="本站项目由Github托管" title="本站项目由Github托管"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Source-Github.svg" alt="本站项目由Github托管"></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" style="margin-inline:5px" data-title="本站采用CC BY-NC-SA 4.0协议" title="本站采用CC BY-NC-SA 4.0协议"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.2.0/img/badge/Copyright-BY-NC-SA.svg" alt="本站采用CC BY-NC-SA 4.0协议"></a></p></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">©2025 By <a class="footer-bar-link" href="/about/" title="Prorise" target="_blank">Prorise</a></div></div><div id="footer-type-tips"></div><div class="js-pjax"><script>function subtitleType () {
  fetch('https://v1.hitokoto.cn')
    .then(response => response.json())
    .then(data => {
      if (true) {
        const from = '出自 ' + data.from
        const sub = ["生活明朗, 万物可爱, 人间值得, 未来可期.","愿你眼里的星星，永远亮晶晶。","愿我们每个人都能被世界温柔以待。"]
        sub.unshift(data.hitokoto, from)
        window.typed = new Typed('#footer-type-tips', {
          strings: sub,
          startDelay: 300,
          typeSpeed: 150,
          loop: true,
          backSpeed: 50,
        })
      } else {
        document.getElementById('footer-type-tips').innerHTML = data.hitokoto
      }
    })
}

if (true) {
  if (typeof Typed === 'function') {
    subtitleType()
  } else {
    getScript('https://lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/typed.js/2.0.12/typed.min.js').then(subtitleType)
  }
} else {
  subtitleType()
}</script></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/Prorise-cool?tab=repositories" title="网站源码">网站源码</a><a class="footer-bar-link" target="_blank" rel="noopener external nofollow noreferrer" href="https://beian.miit.gov.cn/" title="湘ICP备23041-302号">湘ICP备23041-302号</a><a class="footer-bar-link cc" href="/copyright" title="cc协议"><i class="anzhiyufont anzhiyu-icon-copyright-line"></i><i class="anzhiyufont anzhiyu-icon-creative-commons-by-line"></i><i class="anzhiyufont anzhiyu-icon-creative-commons-nc-line"></i><i class="anzhiyufont anzhiyu-icon-creative-commons-nd-line"></i></a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">2</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" rel="external nofollow noreferrer" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" href="/" title="后续项目..."><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="后续项目..."><span class="back-menu-item-text">后续项目...</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><span>文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size:.9em"></i><span> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size:.9em"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size:.9em"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><span>个人</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size:.9em"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size:.9em"></i><span> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/todolist/"><i class="fas fa-check-double faa-tada"></i><span> 代办清单</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/awesome-links/"><i class="fas fa-link faa-tada"></i><span> 实用网站</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><span>预览</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?server=netease&amp;id=3117791189"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size:.9em"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size:.9em"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/messages/"><i class="fas fa-comments faa-tada"></i><span> 评论总览</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><span>关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size:.9em"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size:.9em"></i><span> 即刻短文</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size:.9em"></i><span> 随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Java%E5%BE%AE%E6%9C%8D%E5%8A%A1-AI%E7%AF%87/" style="font-size:.88rem">Java微服务-AI篇<sup>15</sup></a></div></div><hr></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="go-down" type="button" title="直达底部" onclick="anzhiyu.scrollToDest(document.body.scrollHeight,500)"><i class="anzhiyufont anzhiyu-icon-arrow-down"></i></button><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="chat-btn" type="button" title="聊天"><i class="anzhiyufont anzhiyu-icon-comment-sms"></i></button><button id="to_comment" type="button" title="直达评论" onclick="FixedCommentBtn()"><i class="anzhiyufont anzhiyu-icon-comments"></i></button><a id="switch-commentBarrage" href="javascript:anzhiyu.switchCommentBarrage();" rel="external nofollow noreferrer" title="开关弹幕"><i class="anzhiyufont anzhiyu-icon-danmu"></i></a><button id="download-md-btn" type="button" title="下载文章源文件"><i class="anzhiyufont anzhiyu-icon-download"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="3117791189" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size:1rem"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://music.163.com/#/playlist?id=3117791189&quot;, &quot;_blank&quot;);" style="display:none"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/instant.page/5.1.0/instantpage.min.js" type="module"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/vanilla-lazyload/17.3.1/lazyload.iife.min.js"></script><script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/node-snackbar/0.1.16/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/pangu/4.0.7/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>//- 从这里开始的所有JS代码，都必须有缩进（例如2个空格）
// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("06/10/2025 00:00:00"); // 此处读取您配置中的建站时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  
  // --- 已将您的专属LOGO和个人信息集成到这里 ---
  const ascll = [
    `欢迎访问 Prorise 的数字空间!`,
    `代码构建世界，思想驱动未来`,
    // 这里的反引号和所有ASCII art行，都必须有正确的缩进
    `
     ____                      _             
    |  _ \\  _ __   ___   _ __  (_) ___   ___  
    | |_) || '__| / _ \\ | '__| | |/ __| / _ \\ 
    |  __/ | |   | (_) || |    | |\\__ \\|  __/ 
    |_|    |_|    \\___/ |_|    |_||___/ \\___| 
                                             
    `,
    "已稳定运行",
    dnum,
    "天",
    `©2025 By Prorise 1.0.0`,
  ];
  
  const ascll2 = [`SYS-INFO`, `前置摄像头拍照成功`, `您的帅气脸庞为：`, `😎`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c${ascll[2]} \n%c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF; font-family:monospace;",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );

  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，朋友.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Created by Prorise %c 你正在访问 Prorise 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 注意，你的所有操作已被记录.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script async>(function () {
  var grt = new Date("06/10/2025 00:00:00"); //设置网站上线时间
  var now = new Date();
  var dnum;
  var hnum;
  var mnum;
  var snum;
  var nowHour;

  // 计算并更新天数、小时数、分钟数和秒数
  function updateTime() {
    now = new Date(); // 更新 now 的值
    nowHour = now.getHours(); // 更新 nowHour 的值
    var days = (now - grt) / 1000 / 60 / 60 / 24;
    dnum = Math.floor(days);
    var hours = (now - grt) / 1000 / 60 / 60 - 24 * dnum;
    hnum = Math.floor(hours);
    if (String(hnum).length == 1) {
      hnum = "0" + hnum;
    }
    var minutes = (now - grt) / 1000 / 60 - 24 * 60 * dnum - 60 * hnum;
    mnum = Math.floor(minutes);
    if (String(mnum).length == 1) {
      mnum = "0" + mnum;
    }
    var seconds = (now - grt) / 1000 - 24 * 60 * 60 * dnum - 60 * 60 * hnum - 60 * mnum;
    snum = Math.round(seconds);
    if (String(snum).length == 1) {
      snum = "0" + snum;
    }
  }

  // 更新网页中显示的网站运行时间
  function updateHtml() {
    const footer = document.getElementById("footer");
    if (!footer) return
    let currentTimeHtml = "";
    if (nowHour < 18 && nowHour >= 9) {
      // 如果是上班时间，默认就是"安知鱼-上班摸鱼中.svg"图片，不需要更改
      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    } else {
      // 如果是下班时间，插入"安知鱼-下班啦.svg"图片
      let img = document.querySelector("#workboard .workSituationImg");
      if (img != null) {
        img.src = "";
        img.title = "下班了就该开开心心的玩耍，嘿嘿~";
        img.alt = "下班了就该开开心心的玩耍，嘿嘿~";
      }

      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    }

    if (document.getElementById("runtimeTextTip")) {
      document.getElementById("runtimeTextTip").innerHTML = currentTimeHtml;
    }
  }

  setInterval(() => {
    updateTime();
    updateHtml();
  }, 1000);
})();</script><script src="https://cdn.cbd.int/algoliasearch@4.18.0/dist/algoliasearch-lite.umd.js"></script><script src="https://cdn.cbd.int/instantsearch.js@4.60.0/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script><div class="js-pjax"><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.cbd.int/mermaid@10.2.4/dist/mermaid.min.js').then(runMermaid)
  }

  anzhiyu.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.prorise666.site/',
      region: 'ap-shanghai',
      onCommentLoaded: () => {
        anzhiyu.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(runFn,0)
    else getScript('https://cdn.cbd.int/twikoo@1.6.39/dist/twikoo.all.min.js').then(runFn)
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.prorise666.site/',
      region: 'ap-shanghai',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const runFn = () => {
    init();
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) anzhiyu.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else {
      loadTwikoo()
    }
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script><script>(() => {
  let initFn = window.walineFn || null

  const initWaline = (Fn) => {
    const waline = Fn(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://waline.prorise666.site',
      pageview: true,
      dark: 'html[data-theme="dark"]',
      path: window.location.pathname,
      comment: true,
      imageUploader: true,
    }, null))

    const destroyWaline = () => {
      waline.destroy()
    }

    anzhiyu.addGlobalFn('pjax', destroyWaline, 'destroyWaline')
  }

  const loadWaline = async () => {
    if (initFn) initWaline(initFn)
    else {
      await getCSS('https://cdn.cbd.int/@waline/client@3.1.3/dist/waline.css')
      if (true) await getCSS('https://cdn.cbd.int/@waline/client@3.1.3/dist/waline-meta.css')
      const { init } = await import('https://cdn.cbd.int/@waline/client@3.1.3/dist/waline.js')
      initFn = init || Waline.init
      initWaline(initFn)
      window.walineFn = initFn
    }
  }

  if ('Twikoo' === 'Waline' || !false) {
    if (false) anzhiyu.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"><script async src="/js/anzhiyu/comment_barrage.js"></script></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'https://twikoo.prorise666.site/',
        region: 'ap-shanghai',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://cdn.cbd.int/twikoo@1.6.39/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'><div class='name'><span>${array[i].nick} </span></div></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script async data-pjax="" src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail=""</script><script async data-pjax="" src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><script src="/js/load-on-demand.js"></script><script src="/custom/js/markdown-download.js"></script><script defer id="fluttering_ribbon" mobile="false" src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer color="0,0,255" opacity="0.7" zindex="-1" count="99" mobile="false" src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script src="//code.tidio.co//tk571vck0ua2wjoalfbp8wyrlsdaunmz.js" async></script><script>(() => {
  const isChatBtn = true
  const isChatHideShow = true

  if (isChatBtn) {
    let isShow = false
    const close = () => {
      window.tidioChatApi.hide()
      isShow = false
      document.body.style.position = 'relative';
      document.documentElement.style.overflow = 'auto'
    }
    
    const open = () => {
      window.tidioChatApi.open()
      window.tidioChatApi.show()
      isShow = true
    }

    const onTidioChatApiReady = () => {
      window.tidioChatApi.hide()
      window.tidioChatApi.on("close", close)
    }
    if (window.tidioChatApi) {
      window.tidioChatApi.on("ready", onTidioChatApiReady)
    } else {
      document.addEventListener("tidioChat-ready", onTidioChatApiReady)
    }

    window.chatBtnFn = () => {
      if (!window.tidioChatApi) return
      isShow ? close() : open()
    }
  } else if (isChatHideShow) {
    window.chatBtn = {
      hide: () => {
        window.tidioChatApi && window.tidioChatApi.hide()
      },
      show: () => {
        window.tidioChatApi && window.tidioChatApi.show()
      }
    }
  }
})()</script><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.js"></script><script src="https://npm.elemecdn.com/meting@2.0.1/dist/Meting.min.js"></script><script src="https://lib.baomitu.com/pjax/0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","meta[property=\"og:type\"]","meta[property=\"og:site_name\"]","meta[property=\"og:description\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: true,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '[object Object]', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div><link rel="stylesheet" href="https://ai.tianli0.top/static/public/postChatUser_summary.min.css"><script>let tianliGPT_key = '';
        let tianliGPT_postSelector = '#post-container .post-content';
        let tianliGPT_Title = '✨ AI 文章摘要';
        let tianliGPT_postURL = '/^https?:\/\/[^\/]+\/[0-9]{4}\/[0-9]{2}\/[0-9]{2}\/';
        let tianliGPT_blacklist = '';
        let tianliGPT_wordLimit = '1000';
        let tianliGPT_typingAnimate = true;
        let tianliGPT_theme = 'default';
        var postChatConfig = {
          backgroundColor: "#4d648d",
          bottom: "76px",
          left: "16px",
          fill: "#FFFFFF",
          width: "50px",
          frameWidth: "380px",
          frameHeight: "600px",
          defaultInput: true,
          upLoadWeb: true,
          showInviteLink: true,
          userTitle: "💬 智能助手",
          userDesc: "我是 Prorise 博客的 AI 助手，有任何关于网站内容的问题都可以问我哦～",
          addButton: true,
          beginningText: "这篇文章介绍了",
          userIcon: "https://ai.tianli0.top/static/img/PostChat.webp",
          userMode: "magic",
          defaultChatQuestions: ["你好","你是谁"],
          defaultSearchQuestions: ["视频压缩","设计"]
        };</script><script data-postchat_key="" src="https://ai.tianli0.top/static/public/tianli_gpt.min.js"></script></body></html>