<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java微服务（二）：2. 快速入门：构建你的第一个 AI 应用</title>
      <link href="/2025/06/18/java%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BA%8C2-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%9E%84%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA-ai-%E5%BA%94%E7%94%A8/"/>
      <url>/2025/06/18/java%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BA%8C2-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%9E%84%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA-ai-%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<div id="postchat_postcontent"><h2 id="2-快速入门：构建你的第一个-AI-应用"><a href="#2-快速入门：构建你的第一个-AI-应用" class="headerlink" title="2. 快速入门：构建你的第一个 AI 应用"></a>2. 快速入门：构建你的第一个 AI 应用</h2><p>理论讲了再多，也不如亲手写下第一行代码来得实在。在本章中，我将手把手地带你完成从项目创建到运行第一个 AI 聊天应用的全部过程。这个过程会非常迅速，你将亲身体会到 Spring AI 如何将复杂的 AI 调用，简化为几次点击和几行代码。</p><h3 id="2-1-环境准备与项目初始化"><a href="#2-1-环境准备与项目初始化" class="headerlink" title="2.1 环境准备与项目初始化"></a>2.1 环境准备与项目初始化</h3><p>在开始之前，请确保你的开发环境中安装了以下必备工具：</p><ul><li><strong>JDK</strong>: Java Development Kit, 版本要求 <strong>17 或更高</strong>。Spring AI 和 Spring Boot 3.x 都是基于 Java 17 构建的。</li><li><strong>Maven&#x2F;Gradle</strong>: Java 项目构建工具。本教程将主要使用 Maven 作为示例。</li><li><strong>IDE</strong>: 集成开发环境。推荐使用 IntelliJ IDEA Ultimate&#x2F;Community 或带有 Spring Tools Suite 插件的 VS Code。</li><li><strong>一个 AI 模型的 API Key</strong>: 我们需要一个 AI 服务提供商的账户和 API 密钥。在本入门示例中，我们将使用 <strong>DeepSeek大语言模型</strong>。请前往 (<a href="https://platform.deepseek.com/api_keys">DeepSeek 开放平台</a>)) 注册并创建一个 API Key。</li></ul><p>准备就绪后，我们使用 Spring 官方的项目生成器——<strong>Spring Initializr</strong> 来创建我们的项目。</p><ol><li><p><strong>访问 <code>start.spring.io</code></strong>：在浏览器中打开 <a href="https://start.spring.io/">https://start.spring.io/</a>。</p></li><li><p><strong>填写项目元数据</strong>：</p></li></ol><table><thead><tr><th align="left">配置项</th><th align="left">值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><strong>Project</strong></td><td align="left"><code>Maven</code></td><td align="left">选择 Maven 作为项目构建工具。</td></tr><tr><td align="left"><strong>Language</strong></td><td align="left"><code>Java</code></td><td align="left">选择 Java 作为开发语言。</td></tr><tr><td align="left"><strong>Spring Boot</strong></td><td align="left"><code>3.3.x</code></td><td align="left">选择一个最新的<strong>稳定版</strong>，避免选择 <code>SNAPSHOT</code> 或 <code>M</code> (Milestone) 版本。</td></tr><tr><td align="left"><strong>Group</strong></td><td align="left"><code>com.example</code></td><td align="left">通常是公司或组织的反向域名。</td></tr><tr><td align="left"><strong>Artifact</strong></td><td align="left"><code>hello-spring-ai</code></td><td align="left">项目的唯一标识符。</td></tr><tr><td align="left"><strong>Package name</strong></td><td align="left"><code>com.example.hellospringai</code></td><td align="left">Java 代码的基础包名。</td></tr><tr><td align="left"><strong>Packaging</strong></td><td align="left"><code>Jar</code></td><td align="left">我们将应用打包成一个可执行的 Jar 文件。</td></tr><tr><td align="left"><strong>Java</strong></td><td align="left"><code>17</code></td><td align="left">必须与你环境中安装的 JDK 版本匹配。</td></tr></tbody></table><ol start="3"><li><p><strong>添加依赖 (Dependencies)</strong>：这是最关键的一步，我们告诉 Spring Initializr 项目需要哪些能力。点击 “ADD DEPENDENCIES…” 按钮，搜索并添加：</p><ul><li><code>Spring Web</code>: 用于构建 RESTful API，让我们能通过 HTTP 请求与应用交互。</li><li><code>Spring AI OpenAI Support</code>: <strong>注意</strong>，即使我们的目标是 DeepSeek，我们依然先添加这个依赖。因为它不仅提供了 OpenAI 的客户端，更重要的是，它提供了一套与 OpenAI API <strong>兼容</strong>的实现。DeepSeek 的 API 正好遵循了这个规范，这为我们后续的无缝切换埋下了伏笔。</li></ul><blockquote><p><em>图片来源：Spring AI 官方文档</em></p></blockquote></li><li><p><strong>生成并下载项目</strong>：点击 “GENERATE” 按钮，下载生成的 <code>.zip</code> 压缩包。解压后，用你的 IDE 将其作为一个 Maven 项目导入。</p></li></ol><h3 id="2-2-核心依赖辨析：BOM-与-Starter"><a href="#2-2-核心依赖辨析：BOM-与-Starter" class="headerlink" title="2.2 核心依赖辨析：BOM 与 Starter"></a>2.2 核心依赖辨析：BOM 与 Starter</h3><p>打开项目的 <code>pom.xml</code> 文件，这是 Maven 项目的“心脏”。我们来解读一下 Spring Initializr 为我们生成的关键配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>17<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.ai<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-ai-bom<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-ai.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.ai<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-ai-openai-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="核心概念解读"><a href="#核心概念解读" class="headerlink" title="核心概念解读"></a><strong>核心概念解读</strong></h4><table><thead><tr><th align="left">概念</th><th align="left">作用</th><th align="left">实际应用场景</th></tr></thead><tbody><tr><td align="left"><strong>BOM</strong> (Bill of Materials)</td><td align="left">定义并管理一组相互兼容的依赖版本。</td><td align="left">在一个大型项目中，手动管理几十个库的版本非常痛苦且容易出错。使用 BOM 后，我们只需引入 BOM 本身，所有清单内的库版本都会被自动、和谐地确定下来。</td></tr><tr><td align="left"><strong>Starter</strong></td><td align="left">Spring Boot 的自动化配置启动器。</td><td align="left">当我们想使用 Redis 时，只需引入 <code>spring-boot-starter-data-redis</code>，所有关于连接、序列化、模板类的 Bean 都会被自动创建。<code>spring-ai-openai-spring-boot-starter</code> 也是同理，它为我们自动创建了 <code>ChatClient</code>。</td></tr></tbody></table><h3 id="2-3-“Hello-AI-”-第一个聊天应用"><a href="#2-3-“Hello-AI-”-第一个聊天应用" class="headerlink" title="2.3 “Hello, AI!”: 第一个聊天应用"></a>2.3 “Hello, AI!”: 第一个聊天应用</h3><p>配置完成，现在进入激动人心的编码环节。</p><p>在这之前我们需要引入lombok为了以后的环节进行便利的操作，在<code>pom.xml</code>文件夹中引入lombok（不要选创建脚手架的lombok，会导致很多的问题）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.20<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-3-1-配置-API-Key-以-OpenAI-为例"><a href="#2-3-1-配置-API-Key-以-OpenAI-为例" class="headerlink" title="2.3.1 配置 API Key (以 OpenAI 为例)"></a>2.3.1 配置 API Key (以 OpenAI 为例)</h4><p>首先，配置 API Key。<strong>永远不要将密钥硬编码在 Java 代码中</strong>，这是安全红线。我们将其配置在 <code>application.yml</code> 文件里。</p><p>打开 <code>src/main/resources/application.properties</code> 并将其重命名为 <code>application.yml</code>（YAML 格式更具结构化，可读性更强），然后添加以下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># src/main/resources/application.yml</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">ai:</span></span><br><span class="line">    <span class="attr">openai:</span></span><br><span class="line">      <span class="comment"># DeepSeek API 配置 - 使用 OpenAI 兼容协议</span></span><br><span class="line">      <span class="comment"># 注意！这里不能加v1后缀，在2025年的DeepSeek更新中明确指定了不需要v1后缀</span></span><br><span class="line">      <span class="comment"># 很多AI还是会错以为需要v1后缀</span></span><br><span class="line">      <span class="attr">base-url:</span> <span class="string">https://api.deepseek.com</span></span><br><span class="line">      <span class="attr">api-key:</span> <span class="string">&quot;sk-xxxxxxxxxxxxxxx&quot;</span></span><br><span class="line">      <span class="attr">chat:</span></span><br><span class="line">        <span class="attr">options:</span></span><br><span class="line">          <span class="attr">model:</span> <span class="string">deepseek-reasoner</span></span><br><span class="line">          <span class="attr">temperature:</span> <span class="number">0.7</span></span><br></pre></td></tr></table></figure><h4 id="2-3-2-配置ClientBean"><a href="#2-3-2-配置ClientBean" class="headerlink" title="2.3.2 配置ClientBean"></a>2.3.2 配置ClientBean</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/main/java/com/example/hellospringai/config/AppConfig.java</span></span><br><span class="line"><span class="keyword">package</span> com.example.hellospringai.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.ai.chat.client.ChatClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.ai.chat.model.ChatModel; <span class="comment">// 1. 导入 ChatModel</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonConfiguration</span>  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 手动创建一个 ChatClient Bean。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> chatModel Spring Boot 根据 application.yml 自动配置好的 ChatModel 实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 一个配置好的 ChatClient 实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ChatClient <span class="title function_">chatClient</span><span class="params">(ChatModel chatModel)</span> &#123; <span class="comment">// 2. 在方法参数中请求注入 ChatModel</span></span><br><span class="line">        <span class="comment">// 3. 将注入的 chatModel 传递给 ChatClient.Builder</span></span><br><span class="line">        <span class="keyword">return</span> ChatClient.builder(chatModel).build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码解读</strong></p><ol><li><strong><code>import org.springframework.ai.chat.model.ChatModel;</code></strong> 我们引入 <code>ChatModel</code> 接口，这是所有聊天模型（如 OpenAI、Ollama、DeepSeek 的实现）的通用父接口。</li><li><strong><code>public ChatClient chatClient(ChatModel chatModel)</code></strong> 这是最关键的一步。我们告诉 Spring：“请帮我创建一个 <code>chatClient</code> Bean，但在创建之前，请把容器里已经存在的那个 <code>ChatModel</code> 类型的 Bean 给我。”<ul><li><strong><code>chatModel</code> 从哪里来？</strong> 它是由 <code>spring-ai-openai-starter</code> 这个依赖根据你的 <code>application.yml</code> 文件自动创建和配置的。它已经“知道”了你的 <code>base-url</code>、<code>api-key</code> 和默认的 <code>model</code> 名称（<code>deepseek-chat</code>）。</li></ul></li><li><strong><code>return ChatClient.builder(chatModel).build();</code></strong> 我们把这个已经配置完毕的 <code>chatModel</code> “塞”给了 <code>ChatClient</code> 的构建器。这样，这个新的 <code>chatClient</code> Bean 就知道该如何与 AI 进行通信了。</li></ol><h4 id="2-3-3-编写-Controller"><a href="#2-3-3-编写-Controller" class="headerlink" title="2.3.3 编写 Controller"></a>2.3.3 编写 Controller</h4><p>接下来，我们创建一个简单的 <code>RestController</code>，它会接收一个问题，然后调用 AI 模型生成答案。</p><p>在 <code>com.example.hellospringai/controller</code> 包下创建一个名为 <code>ChatController</code> 的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// \src\main\java\com\example\hellospringai\controller\</span></span><br><span class="line"><span class="keyword">package</span> com.example.hellospringai.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.ai.chat.client.ChatClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map; <span class="comment">// 1. 导入 Map 类</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/ai&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ChatClient chatClient;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个 GET 请求接口，路径为 /ai/chat</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 接收来自 URL 的查询参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 一个包含 AI 回答的 JSON 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/chat&quot;)</span></span><br><span class="line">    <span class="comment">// 2. 将返回类型从 String 修改为 Map&lt;String, Object&gt;</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">chat</span><span class="params">(<span class="meta">@RequestParam(value = &quot;message&quot;, defaultValue = &quot;给我讲个关于程序员的笑话&quot;)</span> String message)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先获取 AI 的纯文本回复</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">aiResponse</span> <span class="operator">=</span> chatClient.prompt()</span><br><span class="line">                .user(message)</span><br><span class="line">                .call()</span><br><span class="line">                .content();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 将回复包装在一个 Map 对象中返回</span></span><br><span class="line">        <span class="comment">// Spring Boot 会自动将其转换为 JSON</span></span><br><span class="line">        <span class="keyword">return</span> Map.of(<span class="string">&quot;answer&quot;</span>, aiResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>代码是不是非常简洁？让我们来解读一下</code></strong>：<br>这个 ChatController 定义了一个接收用户提问、调用AI、并返回标准 JSON 响应的Web接口。</p><p><strong>注入方式</strong>：通过构造器注入 ChatClient.Builder，这是 Spring 推荐的用法，安全且清晰。</p><p><strong>核心逻辑</strong>：链式调用 <code>chatClient.prompt().user(message).call().content()</code> 的作用可以概括为：</p><p> <strong>构建提示 → 添加用户输入 → 调用 AI → 提取文本结果</strong>。</p><p><strong>返回格式</strong>：方法返回一个 Map 对象，Spring 框架会自动将其转换为 {“answer”: “…”} 格式的 JSON 响应，非常适合现代应用开发。</p><p>但这样他的结果是一次性返回的，会遇到长时间的阻塞，我们可以对代码进行如下的微调，这样子就能实现AI式对话式的响应结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.hellospringai.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.ai.chat.client.ChatClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Flux; <span class="comment">// 1. 导入 Flux</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/ai&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ChatClient chatClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ChatController</span><span class="params">(ChatClient.Builder chatClientBuilder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.chatClient = chatClientBuilder.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个 GET 请求接口，以现代、响应式的方式流式输出 AI 回答</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 接收来自 URL 的查询参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 一个包含 AI 回答文本块的响应式数据流 (Flux)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/chat&quot;, produces = &quot;text/html;charset=utf-8&quot;)</span> <span class="comment">// 这里必须指定编码，否则中文将无法正确编码</span></span><br><span class="line">    <span class="keyword">public</span> Flux&lt;String&gt; <span class="title function_">streamChat</span><span class="params">(<span class="meta">@RequestParam(value = &quot;message&quot;, defaultValue = &quot;给我写一首关于星空的五言绝句&quot;)</span> String message)</span> &#123;</span><br><span class="line">        <span class="comment">// 2. 直接返回 ChatClient 调用链产生的 Flux&lt;String&gt;</span></span><br><span class="line">        <span class="keyword">return</span> chatClient.prompt()</span><br><span class="line">                .user(message)</span><br><span class="line">                .stream()</span><br><span class="line">                .content();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-4-运行与测试"><a href="#2-3-4-运行与测试" class="headerlink" title="2.3.4 运行与测试"></a>2.3.4 运行与测试</h4><p>现在，一切准备就绪。</p><ol><li><strong>运行应用</strong>：在你的 IDE 中找到 <code>HelloSpringAiApplication.java</code> 文件，右键点击并选择 “Run”。或者使用 Maven 命令 <code>./mvnw spring-boot:run</code>。</li><li><strong>测试接口</strong>：应用启动后（默认端口为 8080），打开浏览器或使用 cURL 等工具访问我们的 API 端点。</li></ol><p>   <strong>使用浏览器</strong>：<br>   访问 &#96;<a href="http://localhost:8080/ai/chat">http://localhost:8080/ai/chat</a></p><p>   你会看到类似下面的 JSON 响应：<br>   <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;answer&quot;</span><span class="punctuation">:</span><span class="string">&quot;好的！这是一个经典的程序员笑话：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">---</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">**程序员面试**  </span></span><br><span class="line"><span class="string">面试官： &quot;</span>你简历上写着你擅长Python，那你能说出`is`和`==`的区别吗？<span class="string">&quot;  </span></span><br><span class="line"><span class="string">程序员： &quot;</span>当然！`==`是问‘你们的值相等吗？’，而`is`是问‘你们是不是同一个对象？’……就像我和我女朋友，她总说‘你和代码`is`（是）真爱，但从来不`==`（等于）爱我！’<span class="string">&quot;  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">面试官： &quot;</span>……你被录用了，但建议别让HR听到这个比喻。<span class="string">&quot;  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">---</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">（附：Python中`is`比较内存地址，`==`比较值；笑话的冷度≈程序员咖啡的浓度☕️）&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></p><p>   你也可以在 URL 中附带自己的问题：<br>   <code>http://localhost:8080/ai/chat?message=请用三个词总结一下Spring框架</code></p><p>   响应：<br>   <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;answer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1. **轻量级**  \n2. **依赖注入**  \n3. **模块化**  \n\n（或替代词：AOP、容器、生态）&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><br>   恭喜你！你已经成功构建并运行了你的第一个 Spring AI 应用！</p><h3 id="2-4-项目结构与核心配置解析"><a href="#2-4-项目结构与核心配置解析" class="headerlink" title="2.4 项目结构与核心配置解析"></a>2.4 项目结构与核心配置解析</h3><p>让我们最后回顾一下我们项目的结构和核心配置，这有助于你建立一个清晰的整体认知。</p><h4 id="2-4-1-项目结构最佳实践"><a href="#2-4-1-项目结构最佳实践" class="headerlink" title="2.4.1 项目结构最佳实践"></a>2.4.1 项目结构最佳实践</h4><p>一个典型的 Spring Boot 项目结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">hello-spring-ai</span><br><span class="line">└── src</span><br><span class="line">    ├── main</span><br><span class="line">    │   ├── java</span><br><span class="line">    │   │   └── com</span><br><span class="line">    │   │       └── example</span><br><span class="line">    │   │           └── hellospringai</span><br><span class="line">    │   │               │</span><br><span class="line">    │   │               ├── HelloSpringAiApplication.java  // Spring Boot 主启动类</span><br><span class="line">    │   │               │</span><br><span class="line">    │   │               ├── config               ``  // 存放配置类 (e.g., @Configuration beans)</span><br><span class="line">    │   │               │   └── CommonConfiguration.java</span><br><span class="line">    │   │               │</span><br><span class="line">    │   │               ├── controller             // Web 层：处理HTTP请求，调用Service</span><br><span class="line">    │   │               │   └── ChatController.java</span><br><span class="line">    │   │               │</span><br><span class="line">    │   │               ├── dto                    // 数据传输对象 (Data Transfer Object)</span><br><span class="line">    │   │               │   ├── ChatRequest.java   // 封装请求数据</span><br><span class="line">    │   │               │   └── ChatResponse.java  // 封装响应数据</span><br><span class="line">    │   │               │</span><br><span class="line">    │   │               ├── service                // 业务逻辑层</span><br><span class="line">    │   │               │   ├── impl               // Service接口的实现类</span><br><span class="line">    │   │               │   │   └── ChatServiceImpl.java</span><br><span class="line">    │   │               │   └── ChatService.java   // Service接口，定义业务方法</span><br><span class="line">    │   │               │</span><br><span class="line">    │   │               ├── exception              // 自定义异常及全局异常处理</span><br><span class="line">    │   │               │   └── GlobalExceptionHandler.java</span><br><span class="line">    │   │               │</span><br><span class="line">    │   │               └── repository             // 数据访问层 (如果需要持久化)</span><br><span class="line">    │   │                   └── ConversationRepository.java</span><br><span class="line">    │   │</span><br><span class="line">    │   └── resources</span><br><span class="line">    │       ├── static                         // 存放静态资源 (CSS, JavaScript, images)</span><br><span class="line">    │       │   └── css</span><br><span class="line">    │       │       └── style.css</span><br><span class="line">    │       ├── templates                      // 存放模板文件 (e.g., Thymeleaf, FreeMarker)</span><br><span class="line">    │       │   └── index.html</span><br><span class="line">    │       └── application.yml                // Spring Boot 核心配置文件</span><br><span class="line">    │</span><br><span class="line">    └── <span class="built_in">test</span></span><br><span class="line">        └── java</span><br><span class="line">            └── com</span><br><span class="line">                └── example</span><br><span class="line">                    └── hellospringai</span><br><span class="line">                        ├── controller</span><br><span class="line">                        │   └── ChatControllerTest.java</span><br><span class="line">                        └── service</span><br><span class="line">                            └── ChatServiceImplTest.java</span><br></pre></td></tr></table></figure><p> <strong>请求处理流程示例</strong></p><p>一个典型的请求会像这样在各层之间流动：</p><ol><li>客户端发送 HTTP 请求（例如 <code>POST /ai/chat</code>，请求体是一个包含 <code>message</code> 的 JSON）。</li><li><code>ChatController</code> 接收请求，将 JSON 请求体反序列化为 <code>ChatRequest</code> DTO 对象。</li><li><code>ChatController</code> 调用 <code>ChatService</code> 的方法，并将 <code>ChatRequest</code> 中的数据传递过去。</li><li><code>ChatServiceImpl</code> 执行核心业务逻辑，比如调用 <code>ChatClient</code> 与 AI 交互，或者从 <code>ConversationRepository</code> 读取历史对话记录。</li><li><code>ChatService</code> 将处理结果（AI 的回答）返回给 <code>ChatController</code>。</li><li><code>ChatController</code> 将结果封装成 <code>ChatResponse</code> DTO 对象，Spring Boot 自动将其序列化为 JSON 响应，返回给客户端。</li></ol><p>遵循这套结构，即使未来项目变得再复杂，你也能保持清晰的思路和整洁的代码库。</p><h4 id="2-4-2-核心自动配置类"><a href="#2-4-2-核心自动配置类" class="headerlink" title="2.4.2 核心自动配置类"></a>2.4.2 核心自动配置类</h4><p>我们之所以能如此轻松地使用 <code>ChatClient</code>，完全得益于 Spring Boot 的自动配置机制。<code>spring-ai-openai-spring-boot-starter</code> 中的 <code>org.springframework.ai.openai.boot.OpenAiAutoConfiguration</code> 类在幕后为我们完成了所有繁重的工作。</p><p>它会：</p><ol><li>读取 <code>application.yml</code> 中 <code>spring.ai.openai</code> 前缀下的所有配置。</li><li>使用这些配置（特别是 <code>api-key</code>）创建一个与 OpenAI 服务器通信的 <code>RestTemplate</code>。</li><li>基于这个 <code>RestTemplate</code> 和其他配置（如 <code>model</code>, <code>temperature</code>），最终创建一个 <code>OpenAiChatClient</code> 的实例，并将其注册为 Spring 容器中的一个 Bean。</li><li>同时，它还会注册一个 <code>ChatClient.Builder</code> Bean，方便我们进行自定义构建。</li></ol><p>正是因为这些 Bean 已经被自动注册，我们才能在自己的 <code>ChatController</code> 中通过 <code>@Autowired</code> 轻松地注入并使用它们。这就是 Spring “约定优于配置”理念的完美体现。</p><h4 id="2-4-3-全局配置选项"><a href="#2-4-3-全局配置选项" class="headerlink" title="2.4.3 全局配置选项"></a>2.4.3 全局配置选项</h4><p>在 <code>application.yml</code> 中，除了 <code>api-key</code> 和 <code>model</code>，我们还可以配置更多影响 AI 行为的全局参数。这些参数位于 <code>spring.ai.openai.chat.options</code> 路径下。</p><p>例如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">ai:</span></span><br><span class="line">    <span class="attr">openai:</span></span><br><span class="line">      <span class="attr">api-key:</span> <span class="string">$&#123;OPENAI_API_KEY&#125;</span></span><br><span class="line">      <span class="attr">chat:</span></span><br><span class="line">        <span class="attr">options:</span></span><br><span class="line">          <span class="attr">model:</span> <span class="string">DeepSeek-R1-0528</span></span><br><span class="line">          <span class="comment"># 温度，控制输出的随机性。值越高越随机，越低越确定。范围 0.0 - 2.0</span></span><br><span class="line">          <span class="attr">temperature:</span> <span class="number">0.7</span> </span><br><span class="line">          <span class="comment"># Top P 采样，与温度类似，但更侧重于从概率最高的词汇中选择。不建议与温度同时修改。</span></span><br><span class="line">          <span class="attr">top-p:</span> <span class="number">1</span> </span><br><span class="line">          <span class="comment"># 最大生成的 Token 数量，可以用来控制成本和响应长度</span></span><br><span class="line">          <span class="attr">max-tokens:</span> <span class="number">2000</span></span><br></pre></td></tr></table></figure><p>这些配置会作为默认值，应用到每一次 <code>ChatClient</code> 调用中。当然，你也可以在单次调用中覆盖这些默认值，我们将在后续章节中详细介绍。</p><p>通过本章的快速入门，你应该已经感受到了 Spring AI 的简洁与强大。它将复杂的底层 API 调用封装得严严实实，让我们能以一种极其“Spring”的方式，轻松地将 AI 的智慧融入到应用之中。在接下来的章节里，我们将深入探索 Spring AI 提供的更多核心概念和强大功能。</p></div>]]></content>
      
      
      <categories>
          
          <category> 后端技术 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java微服务-AI篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java微服务（一）：1. 序章：迎接 Java AI 开发新纪元</title>
      <link href="/2025/06/17/java%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%801-%E5%BA%8F%E7%AB%A0%E8%BF%8E%E6%8E%A5-java-ai-%E5%BC%80%E5%8F%91%E6%96%B0%E7%BA%AA%E5%85%83/"/>
      <url>/2025/06/17/java%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%801-%E5%BA%8F%E7%AB%A0%E8%BF%8E%E6%8E%A5-java-ai-%E5%BC%80%E5%8F%91%E6%96%B0%E7%BA%AA%E5%85%83/</url>
      
        <content type="html"><![CDATA[<div id="postchat_postcontent"><h2 id="1-序章：迎接-Java-AI-开发新纪元"><a href="#1-序章：迎接-Java-AI-开发新纪元" class="headerlink" title="1. 序章：迎接 Java AI 开发新纪元"></a>1. 序章：迎接 Java AI 开发新纪元</h2><p>你好，亲爱的读者。在开始这段旅程之前，我想先与你分享我撰写这本教程的初衷。作为一名在 Java 生态中耕耘多年的开发者，我亲眼见证了 Spring 框架如何一次次地简化我们的开发工作，从最初的依赖注入到后来的 Spring Boot，它始终是企业级应用开发的基石。而今，我们正处在一个由人工智能，特别是大语言模型（LLM）引领的全新技术浪潮之巅。</p><p>在这场变革中，Python 生态凭借其先发优势，涌现出了像 LangChain、LlamaIndex 这样的优秀框架，它们极大地推动了 AI 应用的落地。然而，对于广大的 Java 开发者和海量的存量企业级系统而言，我们不禁要问：我们该如何拥抱这股浪潮？难道要放弃我们熟悉的、健壮的 Java 生态，转向一个全新的技术栈吗？</p><p>答案显然是否定的。正是基于这样的背景，Spring AI 应运而生。它不是对 Python 框架的简单复制，而是 Spring 团队深思熟虑后，为我们 Java&#x2F;Spring 开发者量身打造的一柄利器。它承载着一个清晰的使命：<strong>将构建生成式 AI 应用的复杂性，封装在开发者们熟悉的 Spring 模式之下，让每一位 Java 开发者都能快速、低门槛地成为 AI 应用的构建者。</strong></p><p>我希望通过这本教程，不仅能教会你如何使用 Spring AI 的 API，更能与你一同深入理解其背后的设计哲学，探索它如何将企业级的稳定性、可移植性和强大的生态整合能力，注入到 AI 应用开发中。让我们一起，迎接并开创属于 Java 的 AI 开发新纪元。</p><h3 id="1-1-为何需要-Spring-AI？"><a href="#1-1-为何需要-Spring-AI？" class="headerlink" title="1.1 为何需要 Spring AI？"></a>1.1 为何需要 Spring AI？</h3><h4 id="1-1-1-问题背景：Java-开发者的挑战与机遇"><a href="#1-1-1-问题背景：Java-开发者的挑战与机遇" class="headerlink" title="1.1.1 问题背景：Java 开发者的挑战与机遇"></a>1.1.1 问题背景：Java 开发者的挑战与机遇</h4><p>AI 技术的爆发，特别是以 ChatGPT 为代表的大语言模型（LLM）的出现，为软件行业带来了颠覆性的变革。它们不再仅仅是特定领域的算法工具，而是能够理解自然语言、生成内容、进行逻辑推理的通用能力平台。这意味着，未来的软件开发，将不再仅仅是编写精确的代码指令，更多地会涉及到如何与 AI 进行高效“沟通”和“协作”。</p><p>对于我们 Java 开发者而言，这既是挑战也是机遇：</p><ul><li><strong>挑战</strong>：传统的开发模式和技术栈，并未针对与 LLM 的交互进行优化。如何管理复杂的 Prompt、如何将外部知识（如企业内部文档）融入 AI 的回答、如何让 AI 调用已有的业务 API、如何在不同的 AI 服务商之间平滑切换……这些都成了摆在我们面前的现实难题。</li><li><strong>机遇</strong>：全球绝大多数的企业级核心应用和数据都构建在 Java 技术栈之上。如果能将 AI 的强大能力与这些现有的、经过生产环境严苛考验的系统无缝融合，将催生出巨大的商业价值。例如，为传统的 CRM 系统增加一个能理解客户意图的智能客服；让 ERP 系统能够根据自然语言指令生成复杂的财务报表。</li></ul><h4 id="1-1-2-Python-生态的启示"><a href="#1-1-2-Python-生态的启示" class="headerlink" title="1.1.2 Python 生态的启示"></a>1.1.2 Python 生态的启示</h4><p>在 AI 应用开发领域，Python 生态无疑走在了前列。以 LangChain 和 LlamaIndex 为代表的框架，通过提供一系列标准化的组件和链式（Chain）调用模式，极大地简化了构建 LLM 应用的流程。它们的成功揭示了一个关键点：在应用层面，开发者需要的不是从零开始研究模型算法，而是一个<strong>高效的“胶水层”或“编排框架”</strong>，用来粘合业务逻辑、数据和底层的 AI 模型。</p><p>这些框架的核心思想包括：</p><ul><li><strong>模型I&#x2F;O封装</strong>：将与不同 LLM 的 API 交互统一化。</li><li><strong>Prompt 管理</strong>：提供模板化、可复用的 Prompt 工程能力。</li><li><strong>数据连接</strong>：轻松加载、转换和向量化外部文档，为 RAG（检索增强生成）提供支持。</li><li><strong>链与代理</strong>：将多个调用步骤组合成一个连贯的工作流，甚至赋予 AI 自主规划和使用工具的能力。</li></ul><h4 id="1-1-3-Spring-AI-的诞生"><a href="#1-1-3-Spring-AI-的诞生" class="headerlink" title="1.1.3 Spring AI 的诞生"></a>1.1.3 Spring AI 的诞生</h4><p>Spring AI 正是在深刻理解了 Java 开发者的痛点和借鉴了 Python 生态成功经验的基础上诞生的。它并非要成为 LangChain 的 Java 克隆版，而是要成为 <strong>Spring 生态原生的 AI 应用开发框架</strong>。这意味着它将 AI 能力的集成，完全融入了 Spring 的核心理念之中，为 Java 开发者提供了一条熟悉、平滑且强大的 AI 应用开发路径。</p><blockquote><p>Spring AI 的使命，是让 AI 应用的开发过程变得“Spring 化”——即通过自动配置、依赖注入和统一的编程模型，将复杂的底层实现隐藏起来，让开发者能聚焦于业务创新本身。</p></blockquote><h3 id="1-2-Spring-AI-的核心设计哲学"><a href="#1-2-Spring-AI-的核心设计哲学" class="headerlink" title="1.2 Spring AI 的核心设计哲学"></a>1.2 Spring AI 的核心设计哲学</h3><p>Spring AI 的强大之处，并不仅仅在于它提供了哪些功能，更在于其背后遵循的一系列深刻的设计哲学。这些哲学确保了用它构建的应用不仅能快速开发，更能满足企业级的严苛要求。</p><h4 id="1-2-1-可移植性"><a href="#1-2-1-可移植性" class="headerlink" title="1.2.1 可移植性"></a>1.2.1 可移植性</h4><p>这是 Spring AI 最核心的设计原则之一。在当前 AI 模型服务百家争鸣的时代，将应用与某一个特定的 AI 提供商（如 OpenAI）深度绑定，是极具风险的。未来你可能因为成本、性能或特定功能的需求，需要切换到 Azure OpenAI、Anthropic Claude、Google Gemini 或是某个开源的本地模型。</p><p>Spring AI 通过定义一套<strong>统一的、可移植的 API</strong>（如 <code>ChatClient</code>, <code>EmbeddingClient</code>, <code>VectorStore</code>）来解决这个问题。你的业务代码只与这些接口交互，完全感知不到底层具体是哪个模型在提供服务。切换 AI 提供商，在绝大多数情况下，仅仅是更换一个 Maven 依赖和修改几行配置文件的事情，业务代码无需任何改动。</p><ul><li><strong>场景示例</strong>：你的应用最初使用 OpenAI 的模型。后来，公司出于数据合规要求，需要切换到部署在私有云的 Azure OpenAI 服务。使用 Spring AI，你只需要将 <code>spring-boot-starter-openai</code> 依赖更换为 <code>spring-boot-starter-azure-openai</code>，并更新 <code>application.yml</code> 中的配置即可，整个过程可能只需要几分钟。</li></ul><h4 id="1-2-2-模块化"><a href="#1-2-2-模块化" class="headerlink" title="1.2.2 模块化"></a>1.2.2 模块化</h4><p>Spring AI 遵循 Spring Boot 的“按需引入”原则，将不同的功能拆分到独立的模块化 Starter 中。你的应用需要什么功能，就引入对应的依赖，绝不强制你引入一整个庞大而臃肿的全家桶。</p><ul><li>需要与聊天模型交互？引入 <code>spring-ai-openai-spring-boot-starter</code>。</li><li>需要使用向量数据库？引入 <code>spring-ai-pgvector-store-spring-boot-starter</code>。</li><li>需要文生图功能？引入 <code>spring-ai-image-models-spring-boot-starter</code>。</li></ul><p>这种模块化的设计，使得你的应用可以保持轻量和整洁，只包含你真正需要的功能。</p><h4 id="1-2-3-Spring-原生体验"><a href="#1-2-3-Spring-原生体验" class="headerlink" title="1.2.3 Spring 原生体验"></a>1.2.3 Spring 原生体验</h4><p>Spring AI 不是一个孤立的库，它与 Spring 生态系统是血肉相连的。它充分利用了 Spring 框架的强大能力，为开发者提供了无与伦比的便利性。</p><ul><li><strong>自动配置</strong>：你只需要在配置文件中提供 API Key 等少量信息，Spring AI 就能自动为你创建并配置好 <code>ChatClient</code> 等核心组件的 Bean。</li><li><strong>依赖注入</strong> 你可以在任何 Spring 组件（如 <code>@Service</code>, <code>@RestController</code>）中，通过 <code>@Autowired</code> 直接注入 <code>ChatClient</code> 并使用，完全符合 Spring 的开发习惯。</li><li><strong>AOP 与其他 Spring 特性</strong>: 你可以像对其他 Spring Bean 一样，对 AI 相关的 Bean 应用 AOP（如添加日志、事务）、进行精细化的配置（<code>@ConfigurationProperties</code>）等。</li></ul><h4 id="1-2-4-企业级特性"><a href="#1-2-4-企业级特性" class="headerlink" title="1.2.4 企业级特性"></a>1.2.4 企业级特性</h4><p>除了开发便利性，Spring AI 还深刻理解企业级应用对<strong>稳定性、可观测性和安全性</strong>的诉求。</p><ul><li><strong>可观测性</strong>：Spring AI 内置了对 Micrometer 的支持，能够自动暴露与 AI 调用相关的核心指标，如 Token 消耗、请求延迟、错误率等。你可以轻松地将这些指标对接到 Prometheus &amp; Grafana 等监控系统中，实现对 AI 服务成本和性能的精细化度量。</li><li><strong>生产环境部署</strong>: Spring AI 从设计之初就考虑到了云原生和高性能场景，支持虚拟线程以提升 I&#x2F;O 密集型 AI 调用的吞吐量，并兼容 GraalVM 原生镜像，实现应用的快速启动和低内存占用。</li></ul><h3 id="1-3-Spring-AI-在-AI-技术栈中的定位"><a href="#1-3-Spring-AI-在-AI-技术栈中的定位" class="headerlink" title="1.3 Spring AI 在 AI 技术栈中的定位"></a>1.3 Spring AI 在 AI 技术栈中的定位</h3><p>为了更清晰地理解 Spring AI 的角色，我们可以通过一段简述来描绘它在整个 AI 技术栈中的位置。</p><ol><li><strong>向上支撑业务应用</strong>：为上层业务逻辑提供一套稳定、统一、易用的 AI 能力调用接口。业务开发者无需关心底层 AI 模型的具体实现细节和 API 差异。</li><li><strong>向下连接 AI 生态</strong>：它作为适配器，连接并管理着各种底层服务，包括：<ul><li><strong>AI 模型服务</strong>：如 OpenAI, Azure OpenAI, Google Vertex AI, Anthropic, Ollama 等。</li><li><strong>数据源与存储</strong>：特别是向量数据库（Vector Stores），如 PGVector, Milvus, Redis, Chroma 等，它们是实现 RAG（检索增强生成）模式的关键。</li></ul></li></ol><blockquote><p><strong>核心定位</strong>：Spring AI <strong>专注于应用集成与编排，而非模型训练</strong>。它旨在帮助开发者“使用”好 AI 模型，将 AI 的通用能力与具体的业务场景相结合，创造出实际的应用价值。</p></blockquote><h4 id="1-3-1-与-LangChain4j-等框架的对比"><a href="#1-3-1-与-LangChain4j-等框架的对比" class="headerlink" title="1.3.1 与 LangChain4j 等框架的对比"></a>1.3.1 与 LangChain4j 等框架的对比</h4><p>在 Java 的 AI 开发生态中，除了 Spring AI，也存在其他优秀的框架，如 LangChain4j。了解它们之间的异同，有助于我们做出更合适的选型。</p><table><thead><tr><th align="left">特性</th><th align="left">Spring AI</th><th align="left">LangChain4j</th></tr></thead><tbody><tr><td align="left"><strong>核心理念</strong></td><td align="left"><strong>深度融入 Spring 生态</strong>，提供原生的 Spring Boot 开发体验。</td><td align="left"><strong>作为通用的 Java AI 库</strong>，可以独立使用，也可与其他框架（如 Quarkus, Micronaut）集成。</td></tr><tr><td align="left"><strong>配置方式</strong></td><td align="left">强依赖 Spring Boot 的自动配置 (<code>application.properties</code>&#x2F;<code>yml</code>)。</td><td align="left">提供灵活的编程式构建器 (Builder)，配置更自由。</td></tr><tr><td align="left"><strong>生态整合</strong></td><td align="left">与 Spring Data, Spring Batch, Spring Cloud 等生态组件有天然的、深度的整合潜力。</td><td align="left">更加独立，与特定框架的整合需要开发者自行完成。</td></tr><tr><td align="left"><strong>目标用户</strong></td><td align="left"><strong>Spring&#x2F;Spring Boot 开发者</strong>，特别是企业级应用开发者。</td><td align="left">更广泛的 Java 开发者，包括对 Spring 不熟悉的开发者。</td></tr><tr><td align="left"><strong>优势</strong></td><td align="left">开发体验对 Spring 用户极其平滑，企业级特性（如可观测性）集成度高。</td><td align="left">灵活性高，不锁定于任何一个框架，学习曲线可能对非 Spring 用户更平缓。</td></tr></tbody></table><p><strong>结论</strong>：两者都是非常优秀的框架。如果你的技术栈是基于 Spring Boot 的，或者你正在构建复杂的企业级 AI 应用，<strong>Spring AI 几乎是你的不二之选</strong>，因为它能为你提供无与伦比的生态整合能力和开发便利性。如果你需要一个更轻量、更独立的 Java AI 库，或者你的项目未使用 Spring，那么 LangChain4j 会是一个非常好的选择。</p><h3 id="1-4-本教程导览"><a href="#1-4-本教程导览" class="headerlink" title="1.4 本教程导览"></a>1.4 本教程导览</h3><p>本教程将带领你从零开始，逐步深入 Spring AI 的世界。无论你是 AI 领域的新手，还是希望将 AI 能力引入现有 Java 项目的资深开发者，都能在这里找到清晰的学习路径。</p><h4 id="1-4-1-前置知识要求"><a href="#1-4-1-前置知识要求" class="headerlink" title="1.4.1 前置知识要求"></a>1.4.1 前置知识要求</h4><p>为了更好地跟上本教程的节奏，我希望你具备以下基础：</p><ul><li>熟练掌握 <strong>Java</strong> 编程语言（JDK 17+）。</li><li>具备 <strong>Spring Boot</strong> 的基础开发经验，了解依赖注入、Bean、配置文件等核心概念。</li><li>了解 <strong>Maven</strong> 或 <strong>Gradle</strong> 的基本使用。</li></ul><p>你不需要有任何 AI 或机器学习的背景知识，教程中涉及到的所有 AI 概念，我都会用通俗易懂的方式进行解释。</p><h4 id="1-4-4-源码与示例"><a href="#1-4-4-源码与示例" class="headerlink" title="1.4.4 源码与示例"></a>1.4.4 源码与示例</h4><p>本教程所有章节的完整代码示例，都可以在以下 GitHub 仓库中找到。我强烈建议你将项目克隆到本地，一边阅读，一边动手实践。</p><blockquote><p><strong>代码仓库</strong>: <code>https://github.com/your-username/spring-ai-tutorial-examples</code> (此为占位符，请替换为实际地址)</p></blockquote><p>现在，让我们正式启程，构建你的第一个 AI 应用吧！</p><hr></div>]]></content>
      
      
      <categories>
          
          <category> 后端技术 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java微服务-AI篇 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
